

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="阿布">
  <meta name="keywords" content="学习、生活">
  
    <meta name="description" content="Python爬虫知识 学好爬虫需要的知识：  计算机网络协议（http&#x2F;https协议，tcp&#x2F;ip协议，socket编程） 前端基础 正则表达式 数据存储技术（分布式存储） 并发处理技术（多线程，多进程，线程池，协程） 图像识别（处理反爬、验证码），机器学习算法（验证法、数据解析）   爬虫要解决的问题：  爬虫的采集和更新策略 解决反爬 数据解析 数据存储 模拟登录（验证码识别） 爬虫的监督和">
<meta property="og:type" content="article">
<meta property="og:title" content="Python爬虫学习">
<meta property="og:url" content="http://example.com/2025/08/03/Python/index.html">
<meta property="og:site_name" content="Cffljx的学习空间">
<meta property="og:description" content="Python爬虫知识 学好爬虫需要的知识：  计算机网络协议（http&#x2F;https协议，tcp&#x2F;ip协议，socket编程） 前端基础 正则表达式 数据存储技术（分布式存储） 并发处理技术（多线程，多进程，线程池，协程） 图像识别（处理反爬、验证码），机器学习算法（验证法、数据解析）   爬虫要解决的问题：  爬虫的采集和更新策略 解决反爬 数据解析 数据存储 模拟登录（验证码识别） 爬虫的监督和">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-03T02:00:00.000Z">
<meta property="article:modified_time" content="2025-08-03T23:57:25.000Z">
<meta property="article:author" content="阿布">
<meta property="article:tag" content="学习、生活">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Python爬虫学习 - Cffljx的学习空间</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Cffljx的学习空间" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cffljx</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Python爬虫学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-03 10:00" pubdate>
          2025年8月3日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          44k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          368 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Python爬虫学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Python爬虫知识"><a href="#Python爬虫知识" class="headerlink" title="Python爬虫知识"></a>Python爬虫知识</h1><ul>
<li>学好爬虫需要的知识：</li>
<li><ul>
<li>计算机网络协议（http/https协议，tcp/ip协议，socket编程）</li>
<li>前端基础</li>
<li>正则表达式</li>
<li>数据存储技术（分布式存储）</li>
<li>并发处理技术（多线程，多进程，线程池，协程）</li>
<li>图像识别（处理反爬、验证码），机器学习算法（验证法、数据解析）</li>
</ul>
</li>
<li>爬虫要解决的问题：</li>
<li><ul>
<li>爬虫的采集和更新策略</li>
<li>解决反爬</li>
<li>数据解析</li>
<li>数据存储</li>
<li>模拟登录（验证码识别）</li>
<li>爬虫的监督和部署</li>
<li>数据的去重（url去重，内容去重）</li>
</ul>
</li>
</ul>
<h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul>
<li><p>变量：可以发生改变的一个量，变量是用来区分不同数据的，可以指向一个内存空间，帮我们存储一些数据。</p>
</li>
<li><p>变量命名规范：</p>
</li>
<li><ol>
<li>必须是数字或字母或下划线组成。</li>
<li>不能以数字开头，更不能是纯数字。</li>
<li>不能用python关键字。</li>
<li>不要用中文</li>
<li>要有意义</li>
<li>推荐使用下划线或者驼峰命名。</li>
</ol>
</li>
<li><p>常量：可以把所有的变量的字母变成大写就可以认为是常量。</p>
</li>
<li><p>不存在绝对意义的常量。</p>
</li>
</ul>
<h2 id="简单认识数据类型"><a href="#简单认识数据类型" class="headerlink" title="简单认识数据类型"></a>简单认识数据类型</h2><ul>
<li><p>数据类型：区分不同的数据，不同的数据类型应该有不同的操作。</p>
</li>
<li><p>数字：+-*/</p>
<pre><code class="hljs">整数，int
</code></pre>
<p>​    小数，float</p>
</li>
<li><p>文字：展示</p>
<p>​    字符串：str（重点掌握）</p>
<p>​    表示 方式：’ ‘，” “，’’’ ‘’’，””” “””</p>
<p>​    操作：+ ：左右两端必须是字符串，表示字符串连接操作。</p>
<p>​           * ：一个字符串只能乘以一个数字，表示字符串重复次数。    </p>
</li>
<li><p>布尔：条件判断，主要有二个值：True 表示真 和 Flase 表示假</p>
<p>​    布尔运算符中，非0的数值类型表示True，0表示Flase；其它类型中，非空值表示True，空值表示Flase</p>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p>1、if 条件:</p>
<p>​        代码</p>
<p>​    如果条件成立就执行代码，如果不成立，就不执行。</p>
<p>2、if 条件</p>
<p>​       代码1</p>
<p>​      else</p>
<p>​        代码2</p>
<p>​    如果条件成立，执行代码1，不成立执行代码2</p>
<p>3、if语句可以互相嵌套。</p>
<p>​        if 条件</p>
<p>​            if ….:</p>
<p>​            else:</p>
<p>​        else:</p>
<p>​            代码2</p>
<p>4、 if  条件1:</p>
<p>​        代码1</p>
<p>​    else: 条件2</p>
<p>​        代码2</p>
<p>​    else: 条件3</p>
<p>​        代码3</p>
<p>​    ……..</p>
<p>​    else:</p>
<p>​        代码XXXX</p>
</li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul>
<li><p>while循环：</p>
<p>​    while 条件:</p>
<p>​        代码</p>
<p>过程：判断条件是否为真，如果真，执行代码，然后再次判断条件，直到条件为假循环结束。</p>
</li>
<li><p>break：让当前循环立即停止。</p>
</li>
<li><p>continue：停止当前本次循环，继续执行下一次循环。</p>
</li>
<li><p>for循环：</p>
<p>​    for 变量 in 可迭代的成员</p>
<p>​        代码</p>
<p>把可迭代的成员中的每一项内容拿出来，挨个的赋值给变量，每一次赋值都要执行一次循环体（代码）。</p>
<p>循环想要计数，必须借助于range，range(n)：从0到n，不包含n。range(m,n)：从m到n，不包含n。range(m,n,s):从m到n，不包含n，每次间隔为s。</p>
</li>
<li><p>平时用得多的是for循环，while循环用的多的是死循环。</p>
</li>
</ul>
<h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><ul>
<li>pass是代码占位标志。</li>
</ul>
<h2 id="基础数据类型详解"><a href="#基础数据类型详解" class="headerlink" title="基础数据类型详解"></a>基础数据类型详解</h2><ul>
<li><p>“””   int ，float，bool</p>
<p>​    str（非常重要）</p>
<p>​    list（非常重要)</p>
<p>​    tuple (了解就行)</p>
<p>​    set（了解就行)</p>
<p>​    dict（非常重要)</p>
<p>​    bytes（重要)</p>
<p>​    运算符（重要)</p>
<p>​    文件操作(比较重要)</p>
<p>“””</p>
<p>以上是大多数需要记忆内容，理解的东西不多。在python爬虫中会经常用到。 </p>
<p>1。字符串的格式化：</p>
<p>​    %s 字符串占位，也能用在数值占位。</p>
<p>​    %d 数值占位。</p>
<p>​    %f 占位小数。</p>
<p>​    f”{变量}”，格式化一个字符串。</p>
<p>2、索引和切片：</p>
<p>​    索引：按照位置提取无素。可以采用索引的方式来提取某一个字符（文字）。</p>
<p>​    切片：从一个字符串中提取一部分内容。语法：s[start:end]，从start到end进行切片，但是提到不到end。</p>
<p>​    可以给切片添加步长来控制切片的方向：s[::-1] ，负责表示从右往左，正数表示从左往右。</p>
<p>3、字符串的常规操作：</p>
<p>​    字答串的操作不会对原字符串产生影响，一般是返回一个新字符串。</p>
<p>​    s.upper()：把所有字母变成大写字母。用得比较多，常用于条件判断时对输入进行转换比较。</p>
<p>​    s.lower()：把所有字母变成小写字母。</p>
<p>​    s.strip()：去掉字符串左右两端的空白符（空格，\t，\n）。</p>
<p>​    s.replace(old,new)：字符串替换。</p>
<p>​    s.split(“_”)：可以用任字符串进行切割，切割之后的结果会放到列表当中。</p>
<p>​    s.find(“str”)：查找和判断，返回如果是-1就是没有该字符串出现。</p>
<p>​    s.index(“str”)：如果报错就是没有字符串出现。</p>
<p>​    以上二种查找和判断一般不常用，常用的的方法是：”str”  in s  这里in是成员运算符，返回bool值。</p>
<p>​    s.startswitch(“str”)：判断字符串是不是以str开头。返回bool值。</p>
<p>​    s.endswitch(“str”)：判断字符串是不是以str结尾。返回bool值。</p>
<p>​    s.isdigit()：判断s字符串是不是0和正整数，返回bool值。</p>
<p>​    len(s)：输出s字符串长度。</p>
<p>​    s=””.join(list)：将列表list，用双引号中间的字符连接成一个字符串。双引号中间可以是空字符。</p>
<p>4、字符串的循环和遍历：</p>
<p>​    for c  in s:</p>
<p>​        print(c)        字符串中的每一个字符。</p>
<p>5、关于in用在:</p>
<p>​    1.判断XXX是否在XXXX中了现。</p>
<p>​    2.for循环中用到。</p>
</li>
<li><p>列表</p>
<p>定义：列表是能装东西的东西，在python中用[]来表示一个列表，列表中的元素通过”,”隔开。</p>
<p>特性：1、也像字符串一样有索引和切片。2、索引超过范围会报错。3、可用for循环进行遍历。4、用len()拿到列表的长度。</p>
<p>列表的增删改查：</p>
<p>​    lst.append(元素)    添加元素到列表末尾。</p>
<p>​    lst.insrt(索引，元素)    将无素插入到索引处。</p>
<p>​    lst.extend(列表)    可以合并两个列表，批量的添加。</p>
<p>​    ret=lst.pop(索引)    将索引处的元素删除，并将删除的元素返回到ret变量。</p>
<p>​    lst.remove(元素)    删除某个无素。</p>
<p>​    lst[索引]=无素    直接用索引就可以进行修改操作。</p>
<p>​    print(lst[索引])    直接用索引进行查询操作。</p>
<p>列表排序：</p>
<p>​    lst.sort()    对列表进行升序排序。</p>
<p>​    lst.sort(reverse=True)    对列表进行降序排序。</p>
<ul>
<li>元组</li>
</ul>
<p>​    tuple，元组，特点：不可变的列表。用途：当固定某些数据，不允许外界修改时使用。</p>
<p>   元组如果只有一个元素(*，)，需要在元素的末尾添加一个逗号。否则()默认是优先级的使用了。</p>
<p>   关于元组的不可变，是指内存地址变。t=tuple(1,2,3,[‘a’,’b’,’c’])中，元素列表指定的址是不变，但列表内面的元    素是可以变化。</p>
<ul>
<li>集合set</li>
</ul>
<p> set集合是无序的。</p>
<p> 表示方式：s={元素1，元素2，…}</p>
<p> set集合要求存储的数据必须是可以进行哈希计算的，可哈希的数据类型是不可变的有,int,str,tuple,bool。而可变的数据类型有：list,dict,set，它们是不能存在于集合内，成为集合的元素的。</p>
<p> 只能通过s=set()来创造空集合。而列表可通过l=[]或l=list()、元组通过t=()、字符串s=””或s=str()创建空的对象。</p>
<p> 由于集合的无序特性，不能使用索引来定位元素，所以修改集合时只能通过先删除后添加来实现：s.remove(无素)，s.add(无素)，使用s.pop()时，()内面也不能写索引，只会删除最后一个元素，具有不确定性。查询集合元素只能通过for  in 循环来实现。</p>
<p> 集合的一个重要作用是：去重性。常用于将列表重复元素去除，然后重新赋给列表。方法：s=list(set(lst))。但获得的列表与原列表的元素位置会改变。</p>
<ul>
<li>字典：字典是以键值对的形式进行存储数据的。</li>
</ul>
<p> 字典的表示方式：{key:value，key2:value，key3:value，…}，使用时只是把索引变成了key。</p>
<p> 字典的key必须是可哈希的数据类型（不可变）。value可以是任何数据类型。</p>
<p> 字典的增删改查：</p>
<p> dic[key]=”元素”    增加一项key:value。</p>
<p> 再次相同的dis[key]=”元素”    表示修改已存在的key键的value值。</p>
<p> dic.setdefault(key:value)    在字典内面的增加一项默认值，如果key存在，后面的value就不起作用。</p>
<p> dic.pop(key)    删除字典内健为key的一项键值。根据key删除。</p>
<p> print(dic[key])    查询字典对应键的值，如果key不存在程序会报错。当确定key存在的情况用得多。</p>
<p> print(dic.get(key))    功能同上，查询字典对应键的值，但如果key不存在会返回None值。当不确定key的时候用得多。</p>
<p> None是一种类型为NoneType类型，单纯的就是空，表示没有意思，谁都不能用，可放到if语句做判断。而s=””表示空字符串，是能够被其它函数使用的。</p>
<p> 可以用for循环直接拿到key</p>
<p> for key in dic:</p>
<p> ​    print(key,dic[key])</p>
<p> 把所有key保存在一个列表中：</p>
<p> dic.keys()    拿到所有的key了。</p>
<p> list(dic.key())    列表显示字典内所有的key。</p>
<p> list(dic.values())    列表显示字典内所有的value值。</p>
<p> print(list(dic.items()))    直接拿到字典中的所有key和value。</p>
<p> for key,value in dic.items():    字典的items函数直接能拿到key和value的值。</p>
<p>​    print(key,value)        直接将字典每个键对值分别赋给二个变量：key,value。元组和列表也能执                        行该操作，该操作被称为解构（解包）。</p>
<ul>
<li><p>bytes</p>
<p>字符集和编码：电脑通过一系列的0和1存储信息。这一系列的0和1通过编码就能表示对应的字符信息。</p>
<p>首先是美国的ascii编码，共编排了128个文字符号，只需要7个0和1个就可以表示。同时前面加一个0正好是一个字节8位：01111111</p>
<p>当电脑传到其它国家后，其它国家需要在asii码的基础上扩展本国的文字符号，于是美国制订了ANSI标准，每个字符采用16位，2个字节：00000000  01111111，前8位给不同国家自己编码使用，后面的01111111是ascii标准，不允许修改。</p>
<p>到了中国，首先是对二万个常用字符进行了编码（ANSI是16位，2个字节，能表示65536个字符），标准是gb2312编码，后来又扩展成了GBK编码（中文windows默认就是使用这个）</p>
<p>但如果采用ANSI标准编码，不同国家之间的文字要正确显示就必须切换成本国的编码。</p>
<p>为了避免不同国家文字需要切换成本国的编码标准才能正确显示字符。国际标准统一组织就制订了unicode编码，将世界所有国家的文字都进行了编码，又称万国码。</p>
<p>但unicode使用了4个字节，在存储和网络传输时会浪费大量资源。因此，只能是概念性编码，是一种标准，没法实际落地使用。于是在unicode基础上，另一种编码UTF编码产生，它是一种可变长的unicode编码，可以进行数据存储和传输。</p>
<p>utf有二种标准：utf-8表示最短的字节长度为8，对应英文就是8bit，1个字节，对应欧洲文字就是16bit，2个字节，对应中文就是24bit，3个字节；utf-16表示最短的字节长度为16</p>
<p>因此，gbk源自ansi标准，utf-8源自unicode标准，二者之间不能直接就进行转化。相当于二套密码本（编码），要通过一套密码本转换成文字，然后再将文字转换成另一种密码本来进行相互转化。</p>
<p>程序员平时遇见的所有数据最终单位都是字节byte。bytes就是字节串的意思。</p>
<p>将字符串变成字节就是进行编码str.encode(“编码”)，将字节转化成字符串就是进行解码tytes.decode(“编码”)</p>
<p><em># 怎样将一个bgk字节转化成uft-8的字节</em>：</p>
<p>bs=b’\xc0\xee\xbc\xcc\xcf\xfe’ <em>#开头的b表示 bytes类型</em></p>
<p><em># 先用gbk解码成字符串。</em></p>
<p>s=bs.decode(‘gbk’)</p>
<p><em># 再用utf-8重新编码成字节。</em></p>
<p>bs=s.encode(‘utf-8’)</p>
<p>print(bs)</p>
<p>注意：英语字母在所有编码内面都能正常显示，不存在单独编码，因此在字符串中和bytes中都会正常显示成英文。</p>
<p>注意2：python内存中使用的是unicode编码，因为内存数据随时可以抹除，不需要象保存到硬盘中的文件而需要编码来节约资源。</p>
</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符中，a//b表示取商，a%b表示取余数（得到商后剩下的数字）</li>
<li>逻辑运算符运算顺序：先算（）&gt;not&gt;and&gt;or</li>
<li>成员运算符：in  判断xxx是否在xxxx中出现了。not in 判断xxx是否不在xxxx中出现了。</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><p>读取文件语法：f=open(文件路径,mode=”r”,encoding=”utf-8”)	文件路径可以是相对路径或绝对路径；mode是对文件的操作模式，在这里r表示读取，这条命令执行完并不会把文件全部加载到内存，只是在你的程序与文件间建立了一条通道，后读还要使用f.read()或f.readline()等方式将文件内容加载到内存；encoding是指出文件是以什么方式进行编码的（使用的是哪种字符集），一般对文本文件建议加上，对于其它文件如图片，音频等，因为其内容与编码没关系，在这里可以省略这个参数。</p>
<ul>
<li>for line in f:            从f中读取到每一行数据。</li>
</ul>
<p>​    print(line.strip())</p>
</li>
<li><p>写入文件语法：f=open(文件路径,mode=”w”,encoding=”utf-8”)      w模式下，写入的文件不存在会自动创建该文件，如果存在该文件都会清空该文件内容。同理该行代码也只是程序与文件间建立了一条通道，后面还要使用f.write()命令来写入数据内容。</p>
</li>
<li><p>追加写入文件语法：f=open(文件路径,mode=”a”,encoding=”utf-8”)    a模式下，不会清空该文件原来内容，后面使用f.write()时，会在该文件后面追加数据内容。</p>
</li>
<li><p>f.close()    不管读或写，最后注意要使用该语句关闭文件链接（即关闭程序与文件间的通道）。</p>
</li>
<li><p>使用with open(文件路径,mode=”w”,encoding=”utf-8”)  as f:    with表示上下文件管理，这时就不需要使用f.close()了，该语句会自动关闭文件。</p>
</li>
<li><p>对于非文本文件读写语法：f=open(图片或音频等文件路径,mode=”rb”)    要在mode中加入b属性，后面也不能再使用encoding参数了。读取出来的是字节内容。</p>
</li>
<li><p>从源文件中读取内容，写入到新的路径去：with open(图片或音频等文件路径,mode=”rb”) as f1,open(图片或音频等文件路径,mode=”wb”) as f2:</p>
<p>​    for line in f1:</p>
<p>​        f2.write(line)</p>
</li>
<li><p>修改文件的方法：1、从源文件中读取内容。2、在内存中进行修改。3、把修改后的内容写入新文件中。4、删除源文件，将新文件重命名成源文件。</p>
</li>
</ul>
<h2 id="函数编程-上"><a href="#函数编程-上" class="headerlink" title="函数编程_上"></a>函数编程_上</h2><ul>
<li><p>函数：对某一特定功能或代码进行封装，在需要使用该功能的时候直接调用即可。</p>
</li>
<li><p>定义：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数的名字</span>():<br>    函数体		<span class="hljs-comment">#被封装的功能或者代码块</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用方法：函数的名字()    #函数定义后如果不调用是不会执行。</p>
</li>
<li><p>形参与实参：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2</span>，..</span>)	<span class="hljs-comment">#在定义的时候使用，接收调用的时候传过来的参数，在函数体代码中使用。</span><br>	函数体<br>main(实参<span class="hljs-number">1</span>,实参<span class="hljs-number">2</span>，...)	<span class="hljs-comment">#在调用的时候传入。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">*参数</span>)	<span class="hljs-comment">#*号表示接收位置参数的动态传参，参数的类型必须是元组。</span><br>	函数体<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">**参数</span>)	<span class="hljs-comment">#**表示接收关键字参数的动态传参，参数类型必须是字典。</span><br>	函数体<br><span class="hljs-comment">#参数存放顺序：位置&gt;*args&gt;默认值&gt;**kwargs</span><br>main(*参数)	<span class="hljs-comment">#在实参位置使用*号是把列表（或有序数据类型）打散成位置参数进行传递。</span><br> <br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>如果函数体没有return，此时外界收到的返回值是None</li>
<li>函数体执行到return时，会直接返回，如果return后面没有值也会返回None值</li>
<li>如果return 值1，值2，值3，….，这时返回的是一个元组，元组内是该反回值</li>
</ul>
<h2 id="内置函数（上）"><a href="#内置函数（上）" class="headerlink" title="内置函数（上）"></a>内置函数（上）</h2><ul>
<li><p>反射函数4个</p>
</li>
<li><p>基础数据类型相关38个</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tex">一、和数字相关14个<br>	1、数据类型4个<br>		1.bool<br>		2.int	<span class="hljs-params">#</span> a=0b10010,int(a)能将二进制转变成10进制。<br>		3.float<br>		4.complex：复数，实部+虚部<br>	2、进制转换3个<br>		1.bin:	<span class="hljs-params">#</span>输出结果似0b10010，以0b开头。<br>		2.oct	<span class="hljs-params">#</span> 0o22，以0o开头。<br>		3.hex	<span class="hljs-params">#</span> 0x12，以0x开头。<br>	3、数学运算7个<br>		1.obs<br>		2.divmod<br>		3.round<br>		4.pow	<span class="hljs-params">#</span> pow(a,b),次幂，计算a的b次方，与a**b等价。<br>		5.sum	<span class="hljs-params">#</span> sum(lst)，计算列表中所有元素的和。<br>		6.min	<span class="hljs-params">#</span> mix(lst)，计算列表中最小的值。<br>		7.max	<span class="hljs-params">#</span> max(lst)，计算列表中最大的值。<br>二、和数据结构相关24个<br>	1、序列13个<br>		1.列表与元组2个<br>			1.list	<span class="hljs-params">#</span> s={1,2,3} list(s) 将传递进来的集合变成一个列表。<br>			2.tuple<br>		2.相关内置函数2个<br>			1.reversed	<span class="hljs-params">#</span> 翻转<br>			2.slice		<span class="hljs-params">#</span> 切片 s=slice(1,4,2)  lst[s] 与 lst[1,4,2]相同。<br>		3.字符串9个<br>			1.str		<span class="hljs-params">#</span> 字符串，通过encode()能编码成字节串（二进制字符串）<br>			2.format	<span class="hljs-params">#</span> 格式化 a=18 format(a,"08b") 将a格式化8位的二进制，前面不足的补0。<br>			3.bytes		<span class="hljs-params">#</span> bytes类型的字符串，又称字节串（二进制的字符串），是为了满足网络传输时的需要而定义的一种数据类型，通过decode()能解码成字符串，<br>			4.bytearry<br>			5.memoryview<br>			6.ord	<span class="hljs-params">#</span> 输出码位 a='中' ord(a) 将"中"字的unicode的码位输出来。<br>			7.chr	<span class="hljs-params">#</span> chr(20013) 给出码位位置，展示出文字。通过for i in range(65536)展示大量文字<br>			8.ascii	将传入的对象以ascii字节形式做一个切割。<br>			9.repr	<br>	2、数据集合3个<br>		1.字典1个<br>			dict<br>		2.集合2个<br>			1.set<br>			2.frozenset	<span class="hljs-params">#</span> 冻结的集合，不可变，与元组相同。<br>	3、相关内置函数8个<br>		1.len<br>		2.sorted	排序<br>		3.enumerate	通过for item in enumerate(list): 可以拿到索引和元素。<br>		4.all	当成逻辑运算符and来看，all([1,"","abc"]),相当于运算成：t and f and t<br>		5.any	当成逻辑运算符or来看，any([1,"","abc"]),相当于运算成：t or f or t<br>		6.zip	可以把多个可迭代内容进行合并。<br>		7.fiter	筛选<br>		8.map	映射<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>作用域相关2个</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span><span class="hljs-built_in">locals</span> 函数会以字典的类型返回当前位置的全部局部变量<br><span class="hljs-number">2.</span><span class="hljs-built_in">globals</span> 函数以字典的类型返回全部全局变量。<br></code></pre></td></tr></tbody></table></figure>


</li>
<li><p>面向对象相关9个</p>
</li>
<li><p>迭代器/生成器相关3 个</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span><span class="hljs-built_in">range</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">iter</span><br><span class="hljs-number">3.</span><span class="hljs-built_in">next</span><br></code></pre></td></tr></tbody></table></figure>


</li>
<li><p>其它12个</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs te">一、字符串类型代码的执行3个<br>	1.eval	执行字符串类型的代码，并返回最终结果<br>	2.exec	执行字符串类型的代码<br>	3.complie	将一个字符串编辑为字节代码<br>二、输入输出2个<br>	1.input<br>	2.print<br>三、内存相关2个<br>	1.hash	hash(s) 对不可变的类型进行计算出一个数字，转化成内存地址，进行数据存储为字典(集合)哈希表<br>	2.id	id(s) 直接拿到s在内存中的存储地址<br>四、文件操作相关1个<br>	open<br>五、模块相关1个<br>	__import__<br>六、帮助1个<br>	help	help(类型) 查看类型的定义和使用方法等详细信息。<br>七、调用相关1个<br>	callable<br>八、查看内置属性1个<br>	dir	dir(对象) 查看当前对象（数据）能执行哪些操作。<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="函数编程-下"><a href="#函数编程-下" class="headerlink" title="函数编程_下"></a>函数编程_下</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>变量的访问权限：函数外面，顶格左边定义的变量称为全局变量，称全局作用域，在所有定义的函数中都能使用。而在函数内部定义的变量称为局部变量，称作局部作用域，只能在函数内部使用，外部调用不了。如果想要在函数外面访问函数内面的东西，必须要用到return返回值来获取。</li>
<li>顶格左边声明的函数也是全局的，是全局的一个函数，跟变量调用范围相同。</li>
</ul>
<h3 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h3><ul>
<li>在定义函数的内面再定义一个函数就会形成函数嵌套。在内面定义的函数也是局部函数，在外面不能调用。</li>
<li>局部的东西一般都是自己访问使用的。</li>
<li>函数可以作为返回值进行返回，函数也可以作为参数进行相互传递。因此函数名实际上就是一个变量名，都表示一个内存地址。</li>
</ul>
<h3 id="二个关键字"><a href="#二个关键字" class="headerlink" title="二个关键字"></a>二个关键字</h3><ul>
<li>global  把外面的全局变量引入到局部。</li>
<li>nonlocal 在局部，引入外层的局部变量，如果有就引入，如果没有，继续向外一层查找引入，直到全局(不包括)</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><p>闭包本质是内层函数对外层函数的局部变量的使用，此时内层函数被称为闭包函数。用于协作写出高效程序代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs te">1、可以让一个变量常驻与内存。<br>2、可以避免全局变量被修改。<br>def fun():<br>	a=10<br>	def inner():<br>		nonlocal a		# 注意，这里是引入和使用的是外层局部变量。没有在内部重新定义一个a局部变量<br>		a+=1			#这里的局部变量a因为常驻与内存，不会被垃圾回收，值一直在。<br>		return a<br>	return inner<br>a=20<br>ret=fun()<br>r1=ret()<br>print(r1)  <br>r2=ret()<br>print(r2)<br>第一个输出结果是：11<br>第二个输出结果是: 12<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><ul>
<li><p>装饰器本身是一个闭包，它的作用是在不改变原有函数的情况下，给函数增加新的功能。可以这样来理解：可以在函数前后添加新功能，但是不改变原来的代码。</p>
</li>
<li><p>装饰器一般用在用户登录的地方、日志。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#理解装饰器之前需要理解三点知识：1.函数可以作为参数进行传递；2.函数可以作为返回值进行返回；3.函数名称可以当成变量一样进行赋值操作。</span><br><span class="hljs-comment">#装饰器的通用写法：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">fn</span>):	<span class="hljs-comment">#wrapper：装饰器，fn:目标函数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment">#在目标函数执行之前...</span><br>        ret=fn(*args, **kwargs)<br>        <span class="hljs-comment">#在目标函数执行之后...</span><br>        <span class="hljs-keyword">return</span> ret<br>    <span class="hljs-keyword">return</span> inner	<span class="hljs-comment">#不要加()</span><br><span class="hljs-meta">@wrapper</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>()<br>	<span class="hljs-keyword">pass</span><br>target()	<span class="hljs-comment"># 这里调用的inner了。</span><br><br><span class="hljs-comment">#一个函数可以被多个装饰器装饰。</span><br><span class="hljs-meta">@wrapper1</span><br><span class="hljs-meta">@wrapper2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"..."</span>)<br><span class="hljs-comment">#运行的规则与规律：wrapper1 wrapper2 target wrapper2 wrapper1</span><br>---------------------------------------<br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">guanjia</span>(<span class="hljs-params">game</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):		<span class="hljs-comment"># * **表示接收所有参数，打包成元组和字典。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'开始游戏...'</span>)<br>        game(*args, **kwargs)	<span class="hljs-comment">#这里的* **表示把元组和字典打散成位置参数以及关键字参数传递进去。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'结束游戏...'</span>)<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@guanjia    </span><span class="hljs-comment">#相当于pisa=guanjia(pisa)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pisa</span>(<span class="hljs-params">user,password</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'%s欢迎来到Pisa,你的密码是%s'</span>%(user,password))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'正在玩Pisa...'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"获得了返回信息..."</span><br><br><span class="hljs-meta">@guanjia    </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xiaomi</span>(<span class="hljs-params">user,password,title</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'%s欢迎来到xiaomi,你的密码是%s,你选择的型号是%s'</span>%(user,password,title))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'正在玩小米...'</span>)<br><br>ret=pisa(<span class="hljs-string">'admin'</span>,<span class="hljs-string">'123456'</span>)	<span class="hljs-comment">#此时运行的是guanjia的内层函数inner</span><br><span class="hljs-built_in">print</span>(ret)<br>xiaomi(<span class="hljs-string">'admin'</span>,<span class="hljs-string">'123456'</span>,<span class="hljs-string">'note8'</span>)<br>运行结果：<br>开始游戏...<br>admin欢迎来到Pisa,你的密码是<span class="hljs-number">123456</span><br>正在玩Pisa...<br>结束游戏...<br>获得了返回信息...<br>开始游戏...<br>admin欢迎来到xiaomi,你的密码是<span class="hljs-number">123456</span>,你选择的型号是note8<br>正在玩小米...<br>结束游戏...<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li><p>iterable 可迭代的东西，包括：str、list、tuple、dict、set、open()</p>
</li>
<li><p>iterator：迭代器。</p>
</li>
<li><p>可迭代的数据类型都会提供一个叫迭代器的东西，这个迭代器可以帮我们把数据类型中的所有数据逐一拿到。</p>
</li>
<li><p>for内面一定是要拿迭代器的，所以所有不可以迭代的东西不能用for循环。</p>
</li>
<li><p>for循环内面一定有__next__出现。</p>
</li>
<li><p>迭代器统一了不同数据类型的遍历工作。</p>
</li>
<li><p>迭代器本身也是可迭代的。</p>
</li>
<li><p>迭代器本身的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#获取迭代器的两种方案</span><br>	<span class="hljs-number">1.</span>inter() 内置函数可以直接拿到迭代器。<br>    it=<span class="hljs-built_in">iter</span>(<span class="hljs-string">"abc"</span>)<br>	<span class="hljs-built_in">print</span>(it)	<br>    运行结果：<br>    &lt;str_ascii_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x00000212A7091BD0</span>&gt;<br>    <span class="hljs-number">2.</span>__inter__() 特殊方法<br>    it=<span class="hljs-string">"abc"</span>.__iter__()<br>	<span class="hljs-built_in">print</span>(it)<br>    运行结果：<br>    &lt;str_ascii_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000012B1CF41BD0</span>&gt;<br><span class="hljs-comment">#从迭代器中拿到数据</span><br>	<span class="hljs-number">1.</span><span class="hljs-built_in">next</span>()<br>    it=<span class="hljs-built_in">iter</span>(<span class="hljs-string">"abc"</span>)<br>	<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    运行结果：<br>    a<br>	b<br>	c<br>    <span class="hljs-number">2.</span>__iter__() 特殊方法<br>    it=<span class="hljs-string">"abc"</span>.__iter__()<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    运行结果：<br>    a<br>	b<br>	c<br><span class="hljs-comment"># 迭代器本身也可以迭代：</span><br>    s=<span class="hljs-string">"abc"</span><br>    it=<span class="hljs-built_in">iter</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>        <span class="hljs-built_in">print</span>(i)<br>    运行结果：<br>    a<br>	b<br>	c	<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul>
<li><p>generator  生成器，本质就是迭代器，也具有迭代器的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 创建生成器的两种方案</span><br><span class="hljs-number">1.</span>生成器函数 语法：<span class="hljs-keyword">yield</span><br><span class="hljs-number">2.</span>生成器表达式 语法：(数据 <span class="hljs-keyword">for</span>循环 <span class="hljs-keyword">if</span>判断)<br><span class="hljs-comment"># 生成器函数有一个关键字：yield，生成器函数执行的时候，并不会执行函数，得到的是生成器。</span><br><span class="hljs-comment"># yield：只要函数中出现了yield，它就是一个生成。作用：1.可以返回数据。2.可以分段的执行函数中的内容，通过__next__()可以执行到下一个yield位置，用得好这个功能，特别的节省内存。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br><span class="hljs-built_in">print</span>(fun())<br>运行结果：<br>&lt;generator <span class="hljs-built_in">object</span> fun at <span class="hljs-number">0x00000203EE0CCAC0</span>&gt;<br><span class="hljs-comment">#如果要执行函数，就用迭代器去调用，因为生成器本质就是迭代器。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br><span class="hljs-built_in">print</span>(fun().__next__())<br>运行结果：<br>Hello<br><span class="hljs-number">999</span><br><span class="hljs-comment"># yield也有与return相似的返回功能，return是直接返回，后面语句不会执行，但yield后面的语句还可以继续运行。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>fun().__next__()<br>运行结果：<br>hello	<span class="hljs-comment"># 因为没有变量接收yield 999的值，所以仅仅只是执行了fun函数的print语句。</span><br><span class="hljs-comment"># 多个yield分段执行过程：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"World"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">666</span><br>ret=fun()<br><span class="hljs-built_in">print</span>(ret.__next__())<br><span class="hljs-built_in">print</span>(ret.__next__())<br>运行结果：<br>Hello<br><span class="hljs-number">999</span><br>World<br><span class="hljs-number">666</span><br><span class="hljs-comment"># 生成器表达式演示：</span><br>t=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(t)<br>输出结果：<span class="hljs-comment"># 如果是元组推导式的话，t应该会输出元组数据，实际输出t是生成器对象，说明不存在元组推导式。</span><br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x0000024D0E520380</span>&gt;<br><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> gen:		<span class="hljs-comment">#因为生成器本质上是一种迭代器，要获取gen的数据只能通过for循环迭代实现。</span><br>    <span class="hljs-built_in">print</span>(item)<br>输出结果：<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br>lst=<span class="hljs-built_in">list</span>(gen)		<span class="hljs-comment"># 将生成器转换成列表。</span><br><span class="hljs-built_in">print</span>(lst)<br>输出结果：<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]	<span class="hljs-comment"># 结果说明，list()肯定包含了for循环，而for循环肯定就调用了next()函数。</span><br><br><span class="hljs-comment"># 生成器表达式也是一次性的，各前取完后就不存在数据了。</span><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(item)<br>lst=<span class="hljs-built_in">list</span>(gen)<br><span class="hljs-built_in">print</span>(lst)<br>输出结果：<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br>[]		<span class="hljs-comment"># 前面for循环已取完生成器数据，因为是向前一次性的取数，所以再使用列表去取数就会显示为空。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><ul>
<li><p>推导式简化代码。数据有规律时使用。分为三种推导式：列表推导式、字典推导式、集合推导式。</p>
</li>
<li><p>对于复杂长代码不建议用推导式，用for循环实现代码可读性更强。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 语法：</span><br>	<span class="hljs-comment">#列表推导式 [数据 for循环 if判断]  数据就是你想往列表内放的东西，并且这个东西还能通过if语句判断条件来进行处理，if判断是可选择项。</span><br>    <span class="hljs-comment">#集合推导式 {数据 for循环 if判断}</span><br>    <span class="hljs-comment">#字典推导式 {k:v  for循环 if判断}</span><br><span class="hljs-comment"># (数据 for循环 if判断) 这不是元组推导式，元组不允许修改，所以根本没有元组推导式，这种叫生成器表达式。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li><p>匿名函数又称为： lambda表达式，语法：变量=lambda 参数1,参数2,…：返回值 。实现了一句话创建了一个函数</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 一个正常的函数定义包涵：def 、函数名、(参数)如果有的话、冒号、函数体、返回结果，如下：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br><span class="hljs-comment">#调用方法：用一变量接收函数fun(),并将参数放在()中的返回值。同时函数fun中的函数体代码也已经开始运行完成。</span><br>ret=fun(参数)  <br><br><span class="hljs-comment"># 匿名函数定义省略了：def 函数名、冒号、函数体，只乘下参数、冒号和返回结果，并用lambda来标识，如下：</span><br>fn=<span class="hljs-keyword">lambda</span> 参数:返回值	<span class="hljs-comment">#最显著少了函数名和函数体。</span><br><span class="hljs-comment"># 调用方法：用一变量接收匿名函数fn(),并在()中传递参数。</span><br>ret=fn(参数)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="内置函数（下）"><a href="#内置函数（下）" class="headerlink" title="内置函数（下）"></a>内置函数（下）</h3><ul>
<li><p>sorted 排序</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">lst1=[<span class="hljs-string">'中'</span>,<span class="hljs-string">'中华人民共和国'</span>,<span class="hljs-string">'中国'</span>]  <span class="hljs-comment"># 当lst不是数字时，按key=确定排序方法的函数来进行排序</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(lst1,key=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">len</span>(x)))	<span class="hljs-comment"># 对于匿名函数只是在这里需调用的时候，直接写在这里更合理。</span><br>运行结果：<br>[<span class="hljs-string">'中'</span>, <span class="hljs-string">'中国'</span>, <span class="hljs-string">'中华人民共和国'</span>]<br><br>lst=[{<span class="hljs-string">'id'</span>:<span class="hljs-number">5</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'中'</span>},{<span class="hljs-string">'id'</span>:<span class="hljs-number">7</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'中国'</span>}]<br>s=<span class="hljs-built_in">sorted</span>(lst,key=<span class="hljs-keyword">lambda</span> d:d[<span class="hljs-string">'id'</span>],reverse=<span class="hljs-literal">True</span>)	<span class="hljs-comment"># 在sorted中，这时的lst成为列表中的每项即字典了</span><br><span class="hljs-built_in">print</span>(s)<br>运行结果：<br>[{<span class="hljs-string">'id'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'中国'</span>}, {<span class="hljs-string">'id'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'中'</span>}]<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>filter 筛选</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">lst=[<span class="hljs-string">'张三'</span>,<span class="hljs-string">'李四'</span>,<span class="hljs-string">'王五'</span>,<span class="hljs-string">'张天矣'</span>,<span class="hljs-string">'张明明'</span>]<br>f=<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-keyword">not</span> x.startswith(<span class="hljs-string">'张'</span>),lst)	<span class="hljs-comment"># 对lst中每个元素进行判断，符合条件的放入f中。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(f))<br>运行结果：<br>[<span class="hljs-string">'李四'</span>, <span class="hljs-string">'王五'</span>]<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>map 映射</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">lst=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>f=<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x**<span class="hljs-number">2</span>,lst)	<span class="hljs-comment"># 对lst每一项进行处理后放在f中，f是一个可迭代的map对象。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>(f))	<span class="hljs-comment"># 对可迭代的map对象转换成元组。</span><br>输出结果：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul>
<li>递归：函数自己调用自己</li>
<li>递归如果没有任何东西拦截的话，它默认就是一个死循环。</li>
<li>默认递归深度最大限制为1000</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="time和datetime"><a href="#time和datetime" class="headerlink" title="time和datetime"></a>time和datetime</h3><ul>
<li><p>time 通过import time导入，该模块基本上被datetime模块取代，实际使用中就只用记住二个功能：sleep()、time()</p>
</li>
<li><p>time.sleep()功能：让程序停止一会儿。</p>
</li>
<li><p>time.time()：返回一串长的数字表示的是时间戳。也叫数字类型的时间。</p>
</li>
<li><p>datetime 掌握二个功能：通过from datetime import datetime和from datetime import date。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime	<span class="hljs-comment">#datetim:年月日时分秒；date:年月日;time:时分秒</span><br><br><span class="hljs-built_in">print</span>(datetime.now())	<span class="hljs-comment"># 显示当前时间</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span> <span class="hljs-number">18</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.543848</span><br><br><span class="hljs-built_in">print</span>(datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">42</span>,<span class="hljs-number">31</span>)) <span class="hljs-comment">#格式化或创建一个时间</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span> <span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">31</span><br><br>t1=datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">42</span>,<span class="hljs-number">31</span>)<br>t2=datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">4</span>,<span class="hljs-number">19</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>)<br>diff=t2-t1<br><span class="hljs-built_in">print</span>(diff)	<span class="hljs-comment"># 显示两个时间的差，以天数，小时，分钟，秒显示。</span><br><span class="hljs-built_in">print</span>(diff.total_seconds())	<span class="hljs-comment"># 显示两个时间差，以秒显示。</span><br>输出结果：<br><span class="hljs-number">30</span> days, <span class="hljs-number">7</span>:<span class="hljs-number">29</span>:<span class="hljs-number">30</span>	<br><span class="hljs-number">2618970.0</span><br><br><span class="hljs-comment"># 格式化一个时间：</span><br>t=datetime.now()<br><span class="hljs-built_in">print</span>(t.strftime(<span class="hljs-string">"%Y年%m月%d日 %H时:%M分钟:%S秒"</span>))	<span class="hljs-comment"># 以字符串形式格式化时间。</span><br>输出结果：<br><span class="hljs-number">2025</span>年03月<span class="hljs-number">19</span>日 <span class="hljs-number">18</span>时:<span class="hljs-number">55</span>分钟:04秒<br><br><span class="hljs-comment"># 把字符串转化成时间：</span><br>s=<span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入时间(格式:yyyy-mm-dd HH:MM:SS):"</span>)	<span class="hljs-comment"># 由用户按格式输入时间</span><br>t=datetime.strptime(s, <span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>)   <span class="hljs-comment"># p:parse(转化的意思)</span><br><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date <span class="hljs-comment"># 用法与datetime相同，也能实现strftime()和strptime()等功能。</span><br><br><span class="hljs-built_in">print</span>(date.today())	<span class="hljs-comment">#date只需要掌握这个功能。</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span><br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="随机数模块"><a href="#随机数模块" class="headerlink" title="随机数模块"></a>随机数模块</h3><ul>
<li><p>random 通过import random导入，随机产生一个0到1之间的小数。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 这里导入的是radmom模块内的一个random函数，实现产生一个随机数功能。</span><br><br><span class="hljs-built_in">print</span>(random())<br>输出结果：<br><span class="hljs-number">0.5512596462326173</span><br><br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)) <span class="hljs-comment">#随机整数，能够取到边界值</span><br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)) <span class="hljs-comment">#随机浮点数，1-100之间</span><br><br>lst=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(random.choice(lst)) <span class="hljs-comment"># 从列表中随机选取一项。</span><br><br><br><span class="hljs-keyword">import</span> random<br><span class="hljs-comment">#随机生成4验证码，包含数字、大写字母、小写字母</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_int</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_upper</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(random.randint(<span class="hljs-number">65</span>,<span class="hljs-number">90</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_lower</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(random.randint(<span class="hljs-number">97</span>,<span class="hljs-number">122</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_verify_code</span>(<span class="hljs-params">n=<span class="hljs-number">4</span></span>):<br>    lst=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        switch = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">if</span> switch == <span class="hljs-number">1</span>:<br>            s=rand_int()<br>        <span class="hljs-keyword">elif</span> switch == <span class="hljs-number">2</span>:<br>            s=rand_upper()<br>        <span class="hljs-keyword">else</span>:<br>            s=rand_lower()<br>        lst.append(s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(lst)<br><br><span class="hljs-built_in">print</span>(rand_verify_code())<br><br><br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="pickle对象转字节"><a href="#pickle对象转字节" class="headerlink" title="pickle对象转字节"></a>pickle对象转字节</h3><ul>
<li><p>把python对象写入文件的一种解决方案，写入到文件的是字节bytes， 这种过程叫做序列化。</p>
</li>
<li><p>网络传输时只认字节，这种转化就很好地解决了这个问题。</p>
</li>
<li><p>python代码中的字典数据通过open()方式写入文件只能通过转换成字符串才能写入，但在反过来读取的文件的时候，数据就是字符串类型，不能还原原来的字典数据类型，这时候通过pickle转化就能解决上述问题。</p>
</li>
<li><p>把数据存储到文件中最合理的方案就是pickle，而eval存在安全隐患。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br>lst=[<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">'陈菲菲'</span>,<span class="hljs-string">'李奕妙'</span>]<br><span class="hljs-built_in">print</span>(pickle.dumps(lst))<br>输出结果：<br><span class="hljs-string">b'\x80\x04\x95)\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\t\xe6\x9d\x8e\xe7\xbb\xa7\xe6\x99\x93\x94\x8c\t\xe9\x99\x88\xe8\x8f\xb2\xe8\x8f\xb2\x94\x8c\t\xe6\x9d\x8e\xe5\xa5\x95\xe5\xa6\x99\x94e.'</span><br><br><span class="hljs-keyword">import</span> pickle<br><br>b=<span class="hljs-string">b'\x80\x04\x95)\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\t\xe6\x9d\x8e\xe7\xbb\xa7\xe6\x99\x93\x94\x8c\t\xe9\x99\x88\xe8\x8f\xb2\xe8\x8f\xb2\x94\x8c\t\xe6\x9d\x8e\xe5\xa5\x95\xe5\xa6\x99\x94e.'</span><br><span class="hljs-built_in">print</span>(pickle.loads(b))<br>输出结果：<br>[<span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'陈菲菲'</span>, <span class="hljs-string">'李奕妙'</span>]<br><br><span class="hljs-keyword">import</span> pickle<br><br>dic={<span class="hljs-string">'name'</span>:<span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>:<span class="hljs-number">50</span>}<br>b=pickle.dumps(dic)<br>pickle.dump(dic,<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.data"</span>,mode=<span class="hljs-string">"wb"</span>))	<span class="hljs-comment">#将字典转化成字节写入文件。</span><br><br><span class="hljs-keyword">import</span> pickle<br><br>dic=pickle.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.data"</span>,mode=<span class="hljs-string">"rb"</span>))	<span class="hljs-comment"># 将文件读取并还原成字典。</span><br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic))<br>输出结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">50</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt;<br><br><span class="hljs-comment"># 说明：</span><br>	<span class="hljs-comment"># 序列化：把对象转化成二进制字节；反序列化：把二进制字节转化回对象。</span><br>    <span class="hljs-comment"># 1.dumps 把对象（数据）转化成字节。</span><br>    <span class="hljs-comment"># 2.loads 把字节转化回对象（数据）</span><br>    <span class="hljs-comment"># 3.dump 把对象序列化成字节之后写入文件。</span><br>    <span class="hljs-comment"># 4.load 把文件中的字节反序列化成对象。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ul>
<li><p>json是前后端交互的枢纽，相当于编程界的普通话，json的语法格式能完美展示出一个对象，全称为js对象简谱。它是一种数据传输的数据格式。 </p>
</li>
<li><p>目前，几乎大部app后端返回的数据都是json格式，它非常方便前端处理。</p>
</li>
<li><p>通过import json来导入json包。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 浏览器前端和python程序之间只能以字符串进行传递，所以我们需要做的事是：</span><br><span class="hljs-comment"># 1.把python中的数据类型，如字典、列表、字符串，转化成json字符串，这种转换又称为序列化。</span><br><span class="hljs-keyword">import</span> json<br><br>dic={<span class="hljs-string">"name"</span>:<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">'25'</span>}<br>s=json.dumps(dic)	<span class="hljs-comment"># 在这里转化时，会默认调用到ascii函数，中文将转化成字节。</span><br><span class="hljs-built_in">print</span>(s,<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">"name"</span>: <span class="hljs-string">"\u674e\u7ee7\u6653"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-string">"25"</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br>dic={<span class="hljs-string">"name"</span>:<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">'25'</span>}<br>s=json.dumps(dic,ensure_ascii=<span class="hljs-literal">False</span>)	<span class="hljs-comment"># 这里禁止调用ascii函数转化，中文就会正常显示。</span><br><span class="hljs-built_in">print</span>(s,<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">"name"</span>: <span class="hljs-string">"李继晓"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-string">"25"</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br><span class="hljs-comment"># 2.前端返回的json字符串，想办法变成python中的数据类型，如字典、列表、字符串，这种转换又称为反序列化，反序列化的目的是让转换后的数据类型便于pthon语言方便处理。</span><br><span class="hljs-keyword">import</span> json<br><br>s=<span class="hljs-string">'{"name":"李继晓","age":"25","text":null}'</span><br>dic=json.loads(s)<br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic),<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'25'</span>,<span class="hljs-string">'text'</span>:<span class="hljs-literal">None</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br><span class="hljs-comment"># 写入文件和读取文件代码：</span><br><span class="hljs-keyword">import</span> json<br><br>dis={<span class="hljs-string">"name"</span>:<span class="hljs-string">"李继晓"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">"25"</span>,<span class="hljs-string">"test"</span>:<span class="hljs-literal">None</span>}<br>f=json.dump(dis,<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.txt"</span>,mode=<span class="hljs-string">"w"</span>,encoding=<span class="hljs-string">"utf-8"</span>),ensure_ascii=<span class="hljs-literal">False</span>)<br>dic=json.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.txt"</span>,mode=<span class="hljs-string">"r"</span>,encoding=<span class="hljs-string">"utf-8"</span>))<br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic))<br>运行结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'25'</span>, <span class="hljs-string">'test'</span>: <span class="hljs-literal">None</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt;<br><br><span class="hljs-comment"># 总结：</span><br>	<span class="hljs-comment"># 前端的json和python中的字典数据类型写法有细微差别，但用法一样：</span><br>    	<span class="hljs-comment"># python	前端</span><br>        <span class="hljs-comment"># True		ture</span><br>        <span class="hljs-comment"># None		null</span><br>	<span class="hljs-comment"># 1.dumps 可以把对象（数据）转化成json，注意后面要跟参数：ensure_ascii=False否则中文会出问题。</span><br>    <span class="hljs-comment"># 2.loads 可以把json转化回对象（数据）</span><br>    <span class="hljs-comment"># 3.dump 可以把对象（数据）以json格式写入文件，注意后面要跟参数：ensure_ascii=False</span><br>    <span class="hljs-comment"># 4.load 可以从文件中读取json格式的数据转化成对象（数据）</span><br>    <span class="hljs-comment"># 5.json来自前端。</span><br>    <span class="hljs-comment"># 6.json是一种数据交互的数据格式，它本身就是一种象字符串的格式。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h3><ul>
<li><p>MD5是一种不可逆的加密算法，由于MD5存在很久了，一些简单排列组合来计算MD5的密文被保存后，当出现相同的MD5密文后就能反推原来的数据，这种现象叫撞库。应对方法就是在使用MD5时，给函数的参数传递一个byte来进行MD5加密计算形成密文，这种方法称为哈希加盐。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br><br><span class="hljs-comment"># 创建md5对象</span><br>md5 = hashlib.md5()<br><span class="hljs-comment"># 把要加密的信息传递给md5对象</span><br>md5.update(<span class="hljs-string">'123456'</span>.encode(<span class="hljs-string">'utf-8'</span>))	<span class="hljs-comment">#参数字符串编码成字节。</span><br><span class="hljs-comment"># 获取加密后的结果  </span><br>result = md5.hexdigest()<br><span class="hljs-built_in">print</span>(result)<br>运行结果：<br>e10adc3949ba59abbe56e057f20f883e<br><br><span class="hljs-comment"># 正常的默认加密过程容易撞库，解决方法就是加盐。</span><br>md5=hashlib.md5(<span class="hljs-string">b'fdafdfadfdfdfa'</span>)	<span class="hljs-comment"># 这里参数是字节。</span><br>md5.update(<span class="hljs-string">b'123456'</span>)	<span class="hljs-comment">#这里参数也是字节。</span><br><span class="hljs-built_in">print</span>(md5.hexdigest())<br>运行结果：<br>f6f8eda769519bb05b203a15818cf736<br><br><span class="hljs-comment"># 动态加盐</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">salt,s</span>):<br>    md5=hashlib.md5(salt.encode(<span class="hljs-string">'utf-8'</span>))<br>    md5.update(s.encode(<span class="hljs-string">'utf-8'</span>))<br>    <span class="hljs-keyword">return</span>(md5.hexdigest())<br><br>username=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入用户名：'</span>)<br>password=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入密码：'</span>)<br>mi_pasword=func(username,password)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(username+<span class="hljs-string">'\n'</span>+mi_pasword)<br>------------------------------------------<br><span class="hljs-comment"># 登录验证：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">salt,s</span>):<br>    md5=hashlib.md5(salt.encode(<span class="hljs-string">'utf-8'</span>))<br>    md5.update(s.encode(<span class="hljs-string">'utf-8'</span>))<br>    <span class="hljs-keyword">return</span>(md5.hexdigest())<br>username=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入用户名：'</span>)<br>password=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入密码：'</span>)<br>password=func(username,password)	<span class="hljs-comment"># 需要将用户输入的用户名和密码进行加密后再去判断。</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">if</span> f.readline().strip() == username <span class="hljs-keyword">and</span> f.readline().strip() == password:       <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'登录成功！'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'登录失败！'</span>)<br><br><span class="hljs-comment"># 对文件进行加密：</span><br><span class="hljs-keyword">import</span> hashlib<br><br>md5=hashlib.md5(<span class="hljs-string">b'ab566daf'</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        md5.update(line)<br><span class="hljs-built_in">print</span>(md5.hexdigest())<br>运行结果：<br>f87f39c6f3744ac2d185246d18561cc4<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h3><ul>
<li><p>主要封装了文件和文件夹的相关操作，比如文件复制粘贴，文件移动，文件夹的复制，移动等。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> shutil<br><br>shutil.move(<span class="hljs-string">"test.mp4"</span>,<span class="hljs-string">'video/'</span>) <span class="hljs-comment"># 把当前目录下的test.mp4文件移动到video目录内。</span><br>shutil.copy(<span class="hljs-string">"test2.py"</span>,<span class="hljs-string">"video/test2.py"</span>) <span class="hljs-comment"># 复制文件+权限。</span><br>shutil.copy2(<span class="hljs-string">"test2.py"</span>,<span class="hljs-string">"video/test2.py"</span>) <span class="hljs-comment"># 复制文件+权限+时间。</span><br>shutil.copytree(<span class="hljs-string">"img/"</span>,<span class="hljs-string">"img_bak/"</span>) <span class="hljs-comment"># 复制文件夹，文件夹内的文件也一起会复制。</span><br>shutil.rmtree(<span class="hljs-string">"img_bak/"</span>) <span class="hljs-comment"># 删除文件夹。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><ul>
<li>logging代码模块不用记，只需要知道怎样用就行了（日志等级）。</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># filename:文件名。</span><br><span class="hljs-comment"># format:日志格式。最终在日志文件中显示的样子：时间-名称-级别-模块：错误信息。</span><br><span class="hljs-comment"># level:日志级别，有debug、info、warning、error等。</span><br><span class="hljs-comment"># datefmt:时间格式:%Y-%m-%d %H:%M:%S。</span><br>logging.basicConfig(filename=<span class="hljs-string">'test.log'</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">'%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s'</span>,<br>                    datefmt=<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>,<br>                    level=<span class="hljs-number">0</span>) <span class="hljs-comment"># 0表示最低级别，输出所有信息,当软件交付客户使用时，应调成40，只记录错误。</span><br><br>llogging.log(<span class="hljs-number">5</span>, <span class="hljs-string">'This is a log message'</span>) <span class="hljs-comment"># 0表示最低级别，输出所有信息，在这里可以自定义级别。</span><br>logging.debug(<span class="hljs-string">'This is a debug message'</span>) <span class="hljs-comment"># 10表示最低级别，输出最少的信息。</span><br>logging.info(<span class="hljs-string">'This is an info message'</span>) <span class="hljs-comment"># 20表示最低级别，输出最少的信息。</span><br>logging.warning(<span class="hljs-string">'This is a warning message'</span>) <span class="hljs-comment"># 30表示最低级别，输出最少的信息。</span><br>logging.error(<span class="hljs-string">'This is an error message'</span>) <span class="hljs-comment"># 40表示最低级别，输出最少的信息。</span><br>logging.critical(<span class="hljs-string">'This is a critical message'</span>) <span class="hljs-comment"># 50表示最高级别，输出最重要的错误信息。</span><br>输出结果：<span class="hljs-comment"># 输出在当前目录下test.log文件中。</span><br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root Level <span class="hljs-number">5</span> test4: This <span class="hljs-keyword">is</span> a log message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root DEBUG test4: This <span class="hljs-keyword">is</span> a debug message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root INFO test4: This <span class="hljs-keyword">is</span> an info message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root WARNING test4: This <span class="hljs-keyword">is</span> a warning message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root ERROR test4: This <span class="hljs-keyword">is</span> an error message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root CRITICAL test4: This <span class="hljs-keyword">is</span> a critical message<br><br><br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># 如何将日志到不同文件。</span><br><span class="hljs-comment"># 创建一个操作日志的对象logger。</span><br>file_handler = logging.FileHandler(<span class="hljs-string">"./log/test.log"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-comment"># f=open()</span><br>file_handler.setFormatter(logging.Formatter(<span class="hljs-string">"fmt=%(asctime)s - %(levelname)s - %(message)s"</span>))<br>logger1=logging.Logger(<span class="hljs-string">"test1"</span>,level=<span class="hljs-number">40</span>) <span class="hljs-comment"># 创建日志对象，级别为40。</span><br>logger1.addHandler(file_handler) <span class="hljs-comment"># 给日志设置文件信息。</span><br>logger1.error(<span class="hljs-string">"test1 message"</span>) <span class="hljs-comment"># 记录错误信息。</span><br><br>file_handler2 = logging.FileHandler(<span class="hljs-string">"./log/test2.log"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-comment"># f=open()</span><br>file_handler2.setFormatter(logging.Formatter(<span class="hljs-string">"fmt=%(asctime)s - %(levelname)s - %(message)s"</span>))<br>logger2=logging.Logger(<span class="hljs-string">"test2"</span>,level=<span class="hljs-number">40</span>) <span class="hljs-comment"># 创建日志对象，级别为40。</span><br>logger2.addHandler(file_handler2) <span class="hljs-comment"># 给日志设置文件信息。</span><br>logger2.error(<span class="hljs-string">"test2 message"</span>) <span class="hljs-comment"># 记录错误信息。</span><br>运行结果：<span class="hljs-comment"># 在log目录下会创建test和test2文件，内容如下。</span><br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">33</span>,<span class="hljs-number">881</span> - ERROR - test1 message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">33</span>,<span class="hljs-number">881</span> - ERROR - test2 message<br><br><span class="hljs-comment"># 在全用时选择以下二种方式之一会按要求来记录日志。</span><br>llogging.log(<span class="hljs-number">5</span>, <span class="hljs-string">'This is a log message'</span>) <span class="hljs-comment"># 自定义。</span><br>logger2.error(<span class="hljs-string">"test2 message"</span>) <span class="hljs-comment"># 系统默认之一。</span><br><br></code></pre></td></tr></tbody></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p>程序运行中出现错误，需要提供try…except来处理。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"程序出错了"</span>)<br>输出结果：<br>程序出错了<br><br><span class="hljs-comment"># 异常处理标准格式：</span><br><span class="hljs-keyword">try</span>:<br>    代码<br>excep 错误<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> 变量<span class="hljs-number">1</span>:<br>excep 错误<span class="hljs-number">2</span> <span class="hljs-keyword">as</span> 变量<span class="hljs-number">2</span>:<br>excep Exception <span class="hljs-keyword">as</span> e:	<span class="hljs-comment">#当以上所有异常都不符合条件时，最终会执行这条异常处理语句。万能错误接收。</span><br>    最终处理<br><span class="hljs-keyword">finally</span>:	<span class="hljs-comment">#上面的异常都没有发生也会运行下面代码收尾。不论是否出错都要执行finally</span><br>    <span class="hljs-built_in">print</span>()<br><br><span class="hljs-comment"># 程序也能主动抛出异常：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,b</span>)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(a)==<span class="hljs-built_in">int</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(b)==<span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> a+b<br>    <span class="hljs-keyword">else</span><br>    	<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"非整数类型错误。"</span>)  <span class="hljs-comment"># 抛出异常，调用的该函数，谁接收该异常。</span><br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">a,b</span>):<br>        <span class="hljs-keyword">if</span> a&gt;b:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">"a is greater than b"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"a is not greater than b"</span>)<br>    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>        main(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br>运行结果：<br>a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> greater than b<br>	<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="traceback"><a href="#traceback" class="headerlink" title="traceback"></a>traceback</h3><ul>
<li><p>当通过try…except捕获异常后，虽然能处理异常，但错误信息在哪里发生的不知道，如果想知道报错的信息和位置，就需要调用trackback这个模块。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"error"</span>)<br>    <span class="hljs-built_in">print</span>(traceback.format_exc())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"end"</span>)<br>输出结果：<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"d:\vscode\python\PisaApp\test4.py"</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br>end		<span class="hljs-comment"># 虽然程序报错了，但下面的代码依旧会继续运行。</span><br><br><span class="hljs-comment"># 与logging结合使用：</span><br><span class="hljs-comment"># 准备好记录日志的logging</span><br>logging.basicConfig(filename=<span class="hljs-string">'test.log'</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">'%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s'</span>,<br>                    datefmt=<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>,<br>                    level=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#正常写程序</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"error"</span>)<br>    logging.error(traceback.format_exc())<br>运行结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:03:<span class="hljs-number">26</span> root ERROR test4: Traceback (most recent call last):<br>  File <span class="hljs-string">"d:\vscode\python\PisaApp\test4.py"</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h3><ul>
<li><p>zipfile主要封装了和zip压缩包相关的功能。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> zipfile<br><br>f=zipfile.ZipFile(<span class="hljs-string">'log/test.zip'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-comment"># 创建压缩包。</span><br>f.write(<span class="hljs-string">'test1.py'</span>)<br>f.write(<span class="hljs-string">'test2.py'</span>)<br>f.close()<br><span class="hljs-comment">#  在log目录下生成了一个text.zip文件。</span><br><br><span class="hljs-keyword">import</span> zipfile<br><br>f=zipfile.ZipFile(<span class="hljs-string">"log/test.zip"</span>,<span class="hljs-string">"r"</span>) <span class="hljs-comment"># 打开压缩包</span><br>f.extractall(<span class="hljs-string">"log/"</span>) <span class="hljs-comment"># 解压到指定目录</span><br>f.close() <span class="hljs-comment"># 关闭压缩包</span><br><span class="hljs-comment"># 在log目录下生成test1.py和test2.py文件。</span><br><br><span class="hljs-comment"># 一个一个的解奉压缩：</span><br>f=zipfile.ZipFile(<span class="hljs-string">"log/test.zip"</span>,<span class="hljs-string">"r"</span>) <span class="hljs-comment"># 打开压缩包</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> f.namelist():<br>    f.extract(name,<span class="hljs-string">"log/see"</span>) <span class="hljs-comment"># 解压文件到指定目录</span><br>f.close() <span class="hljs-comment"># 关闭压缩包</span><br>运行结果：<span class="hljs-comment"># 将二个文件自动解压到了log目录下的see目录中，目录没有会自动创建。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><ul>
<li>完成文件夹的处理和命令的执行，常用的几个功能：</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py">os.system() <span class="hljs-comment">#运行shell命令，直接显示</span><br>os.popen().read() <span class="hljs-comment">#运行shell命令，获取执行结果</span><br>os.getcwd()	<span class="hljs-comment">#获取当前工作目录，即当前python脚本工作目录的路径</span><br>os.chdir()	<span class="hljs-comment">#改变当前脚本工作目录，相当于shell下的cd </span><br><span class="hljs-comment">#	与路径相关的os操作，都是os.path模块下的函数和方法</span><br>os.path.exists()	<span class="hljs-comment"># 判断一个路径是否存在，路径可以是文件夹和文件</span><br>os.path.isdir()		<span class="hljs-comment"># 判断文件夹是否存在，比上面命令更精细明确</span><br>os.path.isfile()	<span class="hljs-comment"># 判断文件是否存在，比上面命令更精细明确</span><br>os.path.abspath()	<span class="hljs-comment"># 返回一个文件的绝对路径</span><br>os.path.split(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)	<span class="hljs-comment"># 将文件路径切割成文件夹和文件名</span><br>运行结果：(<span class="hljs-string">'d:\\vscode\\python\\PisaApp'</span>, <span class="hljs-string">'test8.py'</span>)<br><span class="hljs-built_in">print</span>(os.path.dirname(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)) <span class="hljs-comment"># 只返回文件夹</span><br>运行结果：d:\vscode\python\PisaApp<br><span class="hljs-built_in">print</span>(os.path.basename(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)) <span class="hljs-comment">#只返回文件</span><br>运行结果：test8.py<br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">r"d:\vscode"</span>,<span class="hljs-string">"python"</span>,<span class="hljs-string">"test.py"</span>))	<span class="hljs-comment"># 拼接路径</span><br>运行结果：d:\vscode\python\test.py<br></code></pre></td></tr></tbody></table></figure>

<h3 id="SYS模块"><a href="#SYS模块" class="headerlink" title="SYS模块"></a>SYS模块</h3><ul>
<li><p>所有和python解释器相关的都在sys模块</p>
</li>
<li><pre><code class="language-py">sys.argv # 可以接收到命令行参数
import sys
print(sys.argv[0])
运行结果：d:\vscode\python\PisaApp\test8.py # 第一个参数指程序本身。

sys.exit()    #程序退出
import sys
while True:
    print("ljx")
    sys.exit(0)    #这里只是一个描述，告诉操作系统返回了0表示正常退出
    运行结果：ljx # 打印一次就退出
    
sys.version
import sys
print(sys.version)
运行结果：# 输出当前解释器的环境版本说明
3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]

sys.path  #python用来搜索模块的，又称python环境变量，import时会去这里面找
import sys
print(sys.path)
运行结果：
['d:\\vscode\\python\\PisaApp', 'D:\\Programs\\Python\\Python312\\python312.zip', 'D:\\Programs\\Python\\Python312\\DLLs', 'D:\\Programs\\Python\\Python312\\Lib', 'D:\\Programs\\Python\\Python312', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\win32', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\win32\\lib', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\Pythonwin']

sys.path.append()    # 可以附加上需要用到的模块，放到python环境变量中去

sys.platform
print(sys.platform)
输出结果：win32 # 描述不准确，知道是win系统就行
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>+ <br><br>+ <br><br><span class="hljs-meta">## socket</span><br><br>+ socket英文翻译过来是插座意思，它本身不是一个协议，是一个套接字，操作系统为了方便大家直接使用TCP协议而存在的一个抽象层，它把复杂的tcp/ip协议隐藏在接口后面。<br><br>  ```py<br>  <span class="hljs-meta"># socket服务器端</span><br>  import socket<br>  <br>  <span class="hljs-keyword">server</span>=socket.socket()<br>  <span class="hljs-meta"># 绑定地址和端口</span><br>  <span class="hljs-keyword">server</span>.bind((<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">8080</span>))<br>  <span class="hljs-keyword">server</span>.listen()<br>  <span class="hljs-meta"># 循环阻塞等待客户端连接</span><br>  <span class="hljs-keyword">while</span> True:<br>      <span class="hljs-keyword">client</span>,addr=<span class="hljs-keyword">server</span>.accept() <br>      <span class="hljs-meta">#client为客户端对象，表示与客户端建立了一个独立的通道，addr为客户端地址。 </span><br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">'客户端地址:'</span>,addr)<br>      <span class="hljs-meta"># 接收客户端数据</span><br>      data=<span class="hljs-keyword">client</span>.recv(<span class="hljs-number">1024</span>)<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">'客户端数据:'</span>,data.decode())<br>      <span class="hljs-meta"># 发送数据给客户端</span><br>      <span class="hljs-keyword">client</span>.send(b<span class="hljs-string">'hello'</span>)<br>      <span class="hljs-meta"># 关闭客户端连接</span><br>      <span class="hljs-keyword">client</span>.close()<br>  <br>  <br>  <span class="hljs-meta"># socket客户端</span><br>  import socket<br>  <br>  <span class="hljs-keyword">client</span>=socket.socket()<br>  <span class="hljs-meta"># 绑定地址和端口</span><br>  <span class="hljs-keyword">client</span>.connect((<span class="hljs-string">'127.0.0.1'</span>,<span class="hljs-number">8080</span>))<br>  <span class="hljs-meta"># 发送的数据为字节类型。有二种方法：</span><br>  <span class="hljs-meta"># client.send(b'Hello,Server!')</span><br>  <span class="hljs-keyword">client</span>.send(<span class="hljs-string">'Hello,Server!'</span>.encode(<span class="hljs-string">'utf-8'</span>))<br>  <span class="hljs-keyword">client</span>.close()<br>  <span class="hljs-meta"># 运行方法：先启动服务器，再运行客户端。</span><br>  运行结果：当客户端运行完后，服务端会显示客户端的IP地址和发送过来的数据。<br>  <span class="hljs-meta"># 注意：服务端的rece方法是阻塞的，当客户发送的数据小于1024时是不会立即显示结果，但当客户端关闭连接时会显示出结果。</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
</ul>
<h2 id="html-css-javascript关系"><a href="#html-css-javascript关系" class="headerlink" title="html/css/javascript关系"></a>html/css/javascript关系</h2><ul>
<li><p>Html是骨骼，css是皮肤，javaScript是肌肉（能动起来），三者之间的关系可以简单理解为m-v-c</p>
</li>
<li><p>Html语法规则：</p>
</li>
<li><ul>
<li>各种标签：<ol>
<li>h系列标签：h1~h6</li>
<li>a超链接标签：用于负责引入网页跳转链接。内面包含有href属性，后接值为链接地址；有target属性，用于链接展示的方式，值__blank是在新窗口展示，值_self在当前窗口展示。</li>
<li>img图片标签：用于负责引入图片，内包含src属性，值为图片路径的链接地址。还有height等属性。</li>
<li>video视频标签：用于引入视频。内含src属性，值为视频链接地址。</li>
<li>table表标签，内有tr行标签，行标签内有td标签，存放单元格。数据抓取的时候，要注意Elements和页面源代码有区别。会渲染多出一个tbody标签。</li>
<li>form表单标签，内有action属性，是服务的地址，最终提交表单的地方。默认是get提交，它的特点是在url上能够看到请求的所有参数，如果不希望看到，可通过method=”post”的属性和值来更换成post提交。</li>
<li>input输入标签，出现在form表单内，接收用户输入。有type、name等属性。</li>
<li>div和span标签，这二个标签又称为素标签，与上面标签会实现一定功能不同，这二个标签没有任何功能，可塑性强，必须搭配css来使用，能修改成任意的样式，也是用得最多的地方，其中div是块级标签默认独占一行能换行，span是行级标签默认不独占一行，不能换行。随着h5的发展，又衍生出更详细的section、article、footer等素标签。</li>
<li>在html中想要换行的话，有二个方案：<ol>
<li>可以选择一些自己独占的标签</li>
<li>单纯的使用&lt;br/&gt;换行标签或专用于换行的段落标签&lt;p&gt;&lt;/p&gt;</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>CSS又称为层叠样式表，能让页面好看，语法规则：属性：值；属性：值1 值2 值3；</p>
</li>
<li><ul>
<li><p>作用CSS有三种方式</p>
<ol>
<li><p>可以直接在标签上给出style，在style中给出样式内容，这时候这个style就是这个标签的属性。</p>
</li>
<li><p>可以在html中使用&lt;style&gt;标签，可以写在head标签内面或外面，通过选择器去选择你页面上某个标签，给某个标签添加样式。如果标签内有class的类属性，可以直接使用class类属性值来添加样式。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">css选择器：<br>	标签选择器：<br>    	<span class="hljs-comment"># 选择标签</span><br>    	标签{<br>            <br>        }<br>    类选择器<br>        <span class="hljs-comment"># 选择页面中class="xxx"的标签</span><br>        .xxx{<br>            <br>        }<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>网页里面 使用的编程语言是 <code>JavaScript</code> ，简称 <code>js</code>，目前主流浏览器已经基本支持ES6版本</p>
</li>
<li><p>js代码可以包含在网页中，发明 js 的目的，就是放在网页中，让网页 <code>动</code> 起来，称为一个交互式的应用程序，而不仅仅式展示文章类的信息</p>
</li>
<li><p>js 是解释性的编程语言，由js解释器解释执行</p>
</li>
<li><p>现代的浏览器 包括 Chrome、火狐、Edge、Safri 都内置了js解释器，解释执行 js 代码</p>
</li>
<li><p>js 语言不仅仅只在浏览器中使用做前端开发，js语言已经走出了浏览器，用于其他领域，比如：后端服务开发、实时通讯、移动App开发（React Native）、桌面应用程序开发（Electron）等等</p>
<p>比如 <code>Node.js</code> 就是一个独立的js解释器（就像Python解释器一样），可以运行任何用js代码编写的应用程序</p>
</li>
<li><p>js 为什么能让网页实现动态的功能？因为 浏览器给了网页中的js 几个重要的能力：</p>
</li>
<li><ul>
<li>获取网页的内容</li>
<li>更改网页的内容</li>
<li>当某个事件发生时得到通知</li>
<li>和服务端进行通讯</li>
</ul>
</li>
<li><p>我们常见的包含js执行引擎的软件： 一个是 <code>浏览器</code> 、另外一个是 <code>node.js</code></p>
<ol>
<li><p>浏览器：</p>
<p>打开浏览器，按F12，打开 <code>开发者工具栏（英文叫 DevTools）</code> 界面，然后点击 <code>控制台（Console）</code></p>
<p>这 Console 就是一个 js的 交互式代码输入界面。我们编写网页的时候，要执行功能的js代码，不可能让用户手动敲，而是放到网页里面。这包含两种方式： <code>HTML内嵌js代码</code> 和 <code>HTML引用外部js代码文件</code>网页内嵌的js代码 应该放在标签 <code>script</code> 中，成为一个 <code>script</code> 元素。包含js代码的 script元素， 通常可以放在html的 <code>head</code> 或者 <code>body</code> 元素里面。</p>
<p>我们知道 CSS 可以嵌入 html，也可以独立在html外面，同样，我们还可以把js内容放到另外一个文件，比如 my.js ，然后html里面声明引用它</p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//数据类型</span><br>数字类型：整数和小数，在<span class="hljs-variable constant_">JS</span>解释器内部都是存储为“双精度浮点数”，在 <span class="hljs-title class_">JavaScript</span> 解释器看来，整数 和 小数 都是一样的，都是 数字类型，这和很多其他编程语言（<span class="hljs-title class_">Java</span>、<span class="hljs-title class_">Python</span>、C 等等）不同。<br><span class="hljs-comment">//表达式</span><br>带 加减乘除 运算符的，能够产生出一个结果数据的一段代码，术语叫做表达式。我们可以用 <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> 将表达式的结果输出到界面上。<br><span class="hljs-comment">//js语句结尾可以加分号也可以不加</span><br>因为即使你不加分号，js引擎执行时会自动加上分号<br><span class="hljs-comment">//变量和注释</span><br>我们把 js 语言中数据的名字, 称之为 变量名 ， 有时也简称 变量。所以 js 中的变量，就是 数据的名字。<br>定义变量使用 关键字 <span class="hljs-keyword">let</span> 或者 <span class="hljs-keyword">var</span> ，变量名 和 数据 之间 用 等号 连接。注意：在js 中 变量名是大小写敏感的。js 定义变量时 可以不指定初始值。<br>变量的值发生变化有两种情况：一是变量名 对应新的数据，这种情况也被称之为 变量重新赋值；二是变量数据 本身发生了变化，表现在js中 数组 和 <span class="hljs-title class_">Objects</span> 是可变数据类型，当变量对应的数据是可变数据类型，可以通过变量名改变其内容。<br>js 的注释有 单行注释 和 多行注释 <span class="hljs-number">2</span>种：<br>单行注释 以 <span class="hljs-comment">// 开头，后面的内容都是注释</span><br>多行注释 以 <span class="hljs-comment">/* 注释内容 */</span><br><span class="hljs-comment">//字符串数据</span><br>js中， 一个字符串数据的类型是 字符串（<span class="hljs-title class_">String</span>）<br>字符串定义前后的引号，只是告诉解释器，引号内部 的内容就是一个字符串对象的内容。而引号本身并不是字符串的内容。<br>字符串还可以 用 单引号 、双引号 、 反引号，其中反引号(backticks)引起来的称之为 模板字符串 ， 可以 直接写内容有多行 的字符串。如果不使用反引号定义字符串， 通常只能在字符串中 使用 \n 转义符表示换行。<br>字符串拼接：js引擎发现 字符串和其它类型的数据用+号连接，就会先把 其它类型的数据先转化为 对应的字符串，然后再拼接。<br>字符串就是由一个个 元素 - 字符 组成的。像这种由一个个 元素依次组成的字符串， js 语言里面，把这种特性的数据称之为 sequence，翻译成中文就是序列。字符串就是一种序列。<br>序列里面的元素都是有索引的。 所谓索引就是元素的下标，字符串元素的索引是从 <span class="hljs-number">0</span> 开始，而不是从<span class="hljs-number">1</span> 开始。<br>获取字符串长度：字符串对象有个属性 length 可以用来获取字符串的长度，也就是获取字符串中字符的个数。<br><span class="hljs-comment">//定义函数</span><br>定义一个名字 对应多个语句操作， 称之为定义函数，所以：定义函数 就好像是给 一段代码 起了个名字。<br><span class="hljs-keyword">function</span> 是关键字 表示定义一个函数，后面是函数的名字，紧接着后面需要一个括号 ，这个括号中间，根据需要还可以有 参数，最后函数里面要执行的所有代码 放在一个花括号中，表示这个函数名字代表的具体动作是什么，称之为函数体。<br><span class="hljs-comment">//调用函数</span><br>调用函数的时候，如果 传如的参数值个数 比定义参数的个数少，有的参数没有传值，js引擎会自动传入一个 <span class="hljs-literal">undefined</span> 值。调用函数的时候，如果 传如的参数值个数 比定义参数的个数多，多余的参数会在执行函数时被丢弃。<br><span class="hljs-comment">//参数缺省值</span><br>没有特别指定的情况下, 函数的参数的缺省值就是 <span class="hljs-literal">undefined</span> ，如果你调用的时候没有给某个参数传值，其值就是 <span class="hljs-literal">undefined</span><br><span class="hljs-comment">//变量的有效范围</span><br>变量的有效范围有<span class="hljs-number">3</span>种：全局 <span class="hljs-title class_">Global</span> scope；函数内部 <span class="hljs-title class_">Function</span> scope；代码块 <span class="hljs-title class_">Block</span> scope<br>定义在所有函数外部的变量，称之为 全局变量 。全局变量的有效范围是整个代码文件。函数内部代码 可以访问 全局变量的。<br>定义在某个函数内部的变量，称之为 局部变量 。函数的 参数变量 也是 局部变量，局部变量有效范围只能是该函数内部。<br>在 <span class="hljs-title class_">ES6</span>（<span class="hljs-number">2015</span>）之前，<span class="hljs-title class_">JavaScript</span> 只有 <span class="hljs-title class_">Global</span> <span class="hljs-title class_">Scope</span> 和 <span class="hljs-title class_">Function</span> <span class="hljs-title class_">Scope</span>。<span class="hljs-title class_">ES6</span> 引入了两个重要的新 <span class="hljs-title class_">JavaScript</span> 关键字： <span class="hljs-keyword">let</span> 和 <span class="hljs-keyword">const</span><br>这两个关键字在 <span class="hljs-title class_">JavaScript</span> 中提供了 代码块作用域 。{ } 花括号代码块内声明的变量不能从块外访问，如果要在代码块外访问只能通过<span class="hljs-keyword">return</span>返回的值来使用。<br><span class="hljs-comment">//var vs let</span><br><span class="hljs-keyword">var</span> 和 <span class="hljs-keyword">let</span> 都可以定义一个变量.<span class="hljs-property">let</span> 定义的变量如果在块内, 有效范围只能在本代码块内.<br>而 <span class="hljs-keyword">var</span> 定义的变量如果在块内, 其有效范围却可以是整个函数<br><span class="hljs-comment">//一些内置函数</span><br>输入框 - prompt 函数，以让浏览器弹出一个对话框，提示让用户输入单行文本信息<br>提示框 - alert 函数，可以让浏览器弹出一个对话框，提示用户一段信息<br>确认框 - confirm 函数，可以让浏览器弹出一个对话框，让用户确认一段信息，并选择是或者否<br><span class="hljs-built_in">parseInt</span>、<span class="hljs-built_in">parseFloat</span>，可以使用 <span class="hljs-built_in">parseInt</span> 函数，把字符串表示的数字转化为 整数，<br>可以使用 <span class="hljs-built_in">parseFloat</span> 函数，把字符串表示的数字转化为 数字（整数或小数）<br><span class="hljs-comment">//判断语句</span><br>布尔数据只有两种取值： <span class="hljs-literal">true</span> 和 <span class="hljs-literal">false</span><br>运算结果是布尔值的表达式 ，就是 布尔表达式。<br>是否相等：用 === <span class="hljs-number">3</span>个等号连接两个比较对象，== <span class="hljs-number">2</span>个等号连接两个比较对象，判断是否相等<br>这种 <span class="hljs-number">2</span>个等号比较 叫 松散相等比较（<span class="hljs-title class_">Loose</span> <span class="hljs-title class_">Equality</span> <span class="hljs-title class_">Comparison</span>） ，<br>而 <span class="hljs-number">3</span>等号比较 称之为 严格相等比较（<span class="hljs-title class_">Strict</span> <span class="hljs-title class_">Equality</span> <span class="hljs-title class_">Comparison</span>）<br>是否不相等：!== 和 !=<br>!== 的比较 称之为 严格不相等比较（ <span class="hljs-title class_">Strict</span> inequality <span class="hljs-title class_">Comparison</span>）<br>!= 的比较 称之为 松散不相等比较（ <span class="hljs-title class_">Loose</span> inequality <span class="hljs-title class_">Comparison</span>）<br>表达式逻辑操作：布尔表达式 主要有<span class="hljs-number">3</span> 种逻辑操作 ：<br>且（and） 、 或（or） 、 非（not） ， 分别对应 &amp;&amp; 、 || 、 ! <span class="hljs-number">3</span>种逻辑操作符<br>如果 ! 、 &amp;&amp; 和 || 一起使用， 优先级是 ! &gt; &amp;&amp; &gt; ||，就是先计算 ! ， 再计算 &amp;&amp; 部分， 最后再计算 ||<br>以上布尔表达式操作的结果<span class="hljs-literal">true</span>和<span class="hljs-literal">false</span>主要是用在判断语句中<br>判断语句是以 <span class="hljs-keyword">if</span> 关键字开头,<span class="hljs-keyword">if</span>后面的逻辑表达式一定要用括号括起来,<span class="hljs-keyword">if</span> 对应的后续执行代码如果只有一行，可以省略花括号<br><span class="hljs-keyword">else</span> 表示在 <span class="hljs-keyword">if</span> 后面的条件不成立时，要做一些事。<br><span class="hljs-keyword">if</span> ... <span class="hljs-keyword">else</span> 构成了一种 非此即彼 的判断关系。<br>有的时候，情况更加复杂，还需要更多的判断，js中可以 使用更多的 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 。<br>注意 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 和 <span class="hljs-keyword">else</span> 的区别是 ：<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 后面会有一个 条件表达式， 而 <span class="hljs-keyword">else</span> 没有<br><span class="hljs-keyword">if</span> 语句后面也可以没有<span class="hljs-keyword">else</span> 或者 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><br><span class="hljs-comment">//条件赋值:</span><br><span class="hljs-keyword">var</span> fee = miles &gt; <span class="hljs-number">3</span> ? miles*<span class="hljs-number">15</span> : miles*<span class="hljs-number">20</span><br>如果条件评估为真，则冒号左侧的值将分配给变量。 如果条件评估为假，则冒号右侧的条件将分配给变量。<br><span class="hljs-comment">//对象和属性</span><br>js中 对象（<span class="hljs-title class_">Object</span>） 可以和现实世界中的对象 概念对应<br>就是包含了一组 属性（<span class="hljs-title class_">Property</span>） 的数据， 属性可以是包含其它属性的对象。<br><span class="hljs-number">1.</span>创建对象： 使用字面标记,创建一个 <span class="hljs-title class_">Object</span> 类型的数据 有多种方法，最常见的就是直接 js语言 字面标记（literal notation） 构建<br><span class="hljs-keyword">var</span> myCar = {<br>    <span class="hljs-string">'brand'</span>   : <span class="hljs-string">'奔驰'</span>,<br>    <span class="hljs-string">'country'</span> : <span class="hljs-string">'德国'</span>,<br>    <span class="hljs-string">'price'</span>   : <span class="hljs-number">300000</span><br>}<br>这里面的 brand/country/price 都是对象的 属性（英文叫 properties ）。<br>属性之间用逗号隔开，最后一个属性后面可以不用加逗号。<br>有时，我们也把 属性名 称之为 对象的 key（键）<br>访问对象的属性，语法是 对象.属性,或者 对象[<span class="hljs-string">'属性名'</span>],这种写法常用于属性名在写代码时不确定，是变量的情况<br>动态更改属性:添加属性,myCar.<span class="hljs-property">year</span> = <span class="hljs-string">'2021-3-3'</span> 或者 myCar[<span class="hljs-string">'year'</span>] =  <span class="hljs-string">'2021-3-3'</span><br>修改属性：如果赋值语句前面的的属性名已经存在，会覆盖原来的属性值<br>删除属性：如果你要删除对象中一个属性，可以使用 操作符 <span class="hljs-keyword">delete</span><br>比如：<span class="hljs-keyword">delete</span> myCar.<span class="hljs-property">year</span> 或者 <span class="hljs-keyword">delete</span> myCar[<span class="hljs-string">'year'</span>]<br>函数作为对象属性：对象的属性也可以是函数，比如<br><span class="hljs-keyword">var</span> myCar = {<br>    brand   : <span class="hljs-string">'奔驰'</span>,<br>    country : <span class="hljs-string">'德国'</span>,<br>    price   : <span class="hljs-number">300000</span>,<br>    showInfo : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">country</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span>)<br>    }<br>}<br>对象的函数属性，通常也被叫做对象的 方法（英文叫 method ），对象 的方法其实可以看成是对象所拥有的函数。<br>调用对象的方法，语法是 所属对象.属性()<br>在 <span class="hljs-title class_">JavaScript</span> 中， <span class="hljs-variable language_">this</span> 关键字 代表了 当前执行环境，术语是<span class="hljs-title class_">Context</span>，上下文的意思。<br>就是指 调用这个方法 所通过的那个对象 ，也就是 . 前面的对象<br>通过 myCar.<span class="hljs-title function_">showInfo</span>() 这行代码调用的showInfo，里面的 <span class="hljs-variable language_">this</span>就是 myCar 对象<br><span class="hljs-number">2.</span>创建对象：使用构造函数<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand, country, price</span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">country</span> = country<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>}<br><span class="hljs-keyword">var</span> myCar1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'凯美瑞2020'</span>, <span class="hljs-string">'日本'</span>, <span class="hljs-number">200000</span>);<br><span class="hljs-keyword">var</span> myCar2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'特斯拉Model 3'</span>, <span class="hljs-string">'美国'</span>, <span class="hljs-number">300000</span>);<br>这里的 <span class="hljs-title class_">Car</span> 就是一个构造函数。<br>构造函数其实本质上就是一个函数。任何函数都可以当作构造函数来使用。<br>只是，用来构造的函数里面，通常会 为将来所要构造对象 设置一些属性。<br>函数里面的 <span class="hljs-variable language_">this</span> 就代表了要构建的对象，<br>使用 <span class="hljs-keyword">new</span> 操作符 后面调用构造函数，并传入参数，这样构建的对象就会拥有这些属性<br>通常，我们可以说，myCar1、myCar2 就是一个 <span class="hljs-title class_">Car</span> 类型的 对象 ， 或者 对象实例<br>原型 和 原型链：<br>内置构造函数 <span class="hljs-title class_">Object</span>，js 有个内置的构造函数 <span class="hljs-title class_">Object</span>，<span class="hljs-title class_">Object</span> 翻译成中文，也叫 对象，为方便区分，我直接用 英文 <span class="hljs-title class_">Object</span> 称呼它，不给他起中文名<br>直接 字面标记语法<br><span class="hljs-keyword">var</span> myCar = {<br>    brand   : <span class="hljs-string">'奔驰'</span>,<br>    country : <span class="hljs-string">'德国'</span><br>}<br>实质上是js引擎对这样的写法会自动调用<span class="hljs-title class_">Object</span>构造函数<br><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>myCar.<span class="hljs-property">brand</span> = <span class="hljs-string">'奔驰'</span><br>myCar.<span class="hljs-property">country</span> = <span class="hljs-string">'德国'</span><br>所以，所有 用 字面标记 创建的对象 都是 <span class="hljs-title class_">Object</span> 类型的 对象实例。<br>函数本身也是对象，也可以为其动态的添加属性<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>){<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'in func1'</span>)<br>}<br>func1.<span class="hljs-property">name</span> = <span class="hljs-string">'func1'</span><br>func1.<span class="hljs-property">desc</span> = <span class="hljs-string">'func1 函数的作用是...'</span><br>使用原型创建对象：内置函数 <span class="hljs-title class_">Object</span> 有个 create 方法（函数对象也可以有自己的方法属性）可以用它直接创建对象。<br>对象会 继承（inherit） 原型链 对象 里面的属性。如果对象自身属性和 原型链上的属性 同名，使用哪个，按原型链次序，首先会优先使用自身属性<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>，原型链最后一环，其实：js中所有的对象 的原型链 最后都是终结于 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>，所以，js 所有的对象都可以访问 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 里面的属性<br>myCar1.<span class="hljs-title function_">toString</span>()<br>myCar1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'owner'</span>)<br>myCar1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'type'</span>)<br>toString 和 hasOwnProperty 都是 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 里面的属性<br>toString 是把对象转化为字符串表示的，对象可以自己添加该属性方法，重新实现该方法。在打印结果和字符串格式化拼接时有用。<br>hasOwnProperty 是用来判断参数 是否是 对象自身的属性<br>对象常见操作：<br>检查对象是否有某个属性，可以使用 hasOwnProperty<br>得到对象所有属性，<span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span> 方法可以返回 对象的 所有属性名 一个数组<br>得到对象所有属性和值，<span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span> 方法可以返回 对象的 所有属性和值 到一个数组，方便我们遍历<br><span class="hljs-comment">//数组</span><br>数组的概念：js 有内置的构造函数 <span class="hljs-title class_">Array</span> 。构造出的对象被称为 数组对象 ，或者直接简称 数组，里面存储的数据，通常被称之为数组的 元素<br>索引：可以用元素 索引 的方式取出里面的元素<br>切片 slice：js 中的 字符串 和 数组 ，都有 slice 方法可以进行切片<br>改变数组内容：和我们前面学过的其它数据类型不同，数组对象有个特点，它的内容是 可以变化的<br>末尾添加 push，push方法就会改变数组的内容，在后面添加一个元素。<br>末尾取出元素 pop，如果我们要从数组 末尾取出元素 一个元素，就可以使用 pop 方法。pop 方法的返回值 是 取出来的元素<br>开头取出元素 shift<br>如果我们要从数组 开头取出元素 一个元素，就可以使用 shift 方法。shift 方法的返回值 是 取出来的元素，注意，取出后，该元素就从数组中删除了。<br>指定位置删除 splice，splice 方法可以 删除 数组的一段内容<br>指定位置替换 splice，splice 方法也可以 替换 数组的一段内容。替换就是 删除后再插入内容， splice从第<span class="hljs-number">3</span>个开始，以后的参数都是要插入的元素。这种写法称之为 切片赋值<br>指定位置插入 splice，如果我们 不是要在后面 添加一个元素， 而是在 指定位置插入一个元素怎么办？还是可以使用 splice 方法，第<span class="hljs-number">2</span>个参数 删除个数 设置为 <span class="hljs-number">0</span><br>数组元素倒过来 reverse：reverse方法将数组元素倒过来<br>获取元素索引 indexOf，indexOf 方法返回 参数对象 在数组 中的位置，也就是索引<br>检查是否包含 includes：数组的 includes 方法 返回数组中是否包含参数指定的数据，返回值为 <span class="hljs-literal">true</span> 表示存在，<span class="hljs-literal">false</span> 表示不存在<br>清空数组<br>方法<span class="hljs-number">1</span> ：变量赋值<br>如果我们是想让某个变量对应的数组为空，可以这样：<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1 = [];<br>方法<span class="hljs-number">2</span> ：设置数组长度<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>设置数组长度为<span class="hljs-number">0</span>，这样一个数组里面的内容就会被清空<br>方法<span class="hljs-number">3</span> ：使用splice<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, arr1.<span class="hljs-property">length</span>)<br>拼接字符串 join：join 就是用参数里面的字符串连接数组里面的元素，返回值就是拼接后的字符串<br>多个变量同时赋值<br>我们可以像下面这样把 数组 中的元素直接赋值给变量<br><span class="hljs-keyword">var</span> x1, x2, x3, x4<br>[x1, x2, x3, x4] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x1, x2, x3, x4)<br>这种方式的术语叫： 解构赋值（<span class="hljs-title class_">Destructuring</span> assignment ）解构赋值时，如果变量的个数 多于 等号右边的 值个数，有的变量值就是 <span class="hljs-literal">undefined</span>。<br><span class="hljs-keyword">const</span> 定义变量：<span class="hljs-keyword">const</span> 定义的变量，必须在定义时就赋值，后续不能重新赋值，也就是说： <span class="hljs-keyword">const</span> 变量指向的对象 定义后就不能改变，但是<span class="hljs-keyword">const</span>定义的变量 指向的对象内容变化是可以的<br>map方法：对数组中的每个元素进行同样的处理，产生另外一个数组，参数是一个函数对象，就是对每个元素的处理函数<br><span class="hljs-comment">//字符串、数字对象</span><br>实际上，几乎所有的js数据类型，原型链最终都是 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ，所以几乎所有的js数据类型的实例，都可以说是一个 对象，它们都可以使用 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 的属性方法，和自身原型的属性方法。<br>而下面的定义：<br><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">356</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">'您好'</span><br>它们是 primitive （ 原语 ）数据， 不是对象数据，primitive 数据 没有 属性，底层实现 往往就是 直接对应 存储在内存的 数据，所以非常高效。<br>primitive数据是不能改变的。<br>字符串对象，字符串对象 <span class="hljs-title class_">String</span> 有如下常用的属性方法<br>length，返回字符串对象的长度<br>indexOf<br>字符串的 indexOf 方法 和 数组的 indexOf 方法类似，它用来在字符串中查找 参数字符串，并返回该 参数字符串 在其中 第一个 出现的位置索引，如果字符串对象里面 没有 要查找的参数字符串，就会返回 -<span class="hljs-number">1</span>，indexOf 方法 的第二个参数，用来指定 查找起始位置 <br>切片 slice<br>split：split 方法以参数字符串为分割符 ，将字符串 切割为多个 字符串，作为元素存入一个数组，并返回这个数组。分隔符本身在切割后，会被丢弃掉，所以切割后的字符串中不会有分隔符。<br>trim、trimStart、trimEnd<br>trim 方法可以 删除 字符串前面和后面的空白字符，比如空格、tab符， 以及行终结符， 比如回车、换行等等<br>trimStart 方法 将 字符串前面 (左边) 的空格删除，但是不会删除字符串中间和右边的空格<br>trimEnd 方法 将 字符串后面 (右边) 的空格删除，但是不会删除字符串中间和左边的空格<br>replace 也是常用的方法，用来 替换 字符串里面 第一个 指定的 子字符串 为另一个 字符串<br>新版本的浏览器 支持 replaceAll 方法。replaceAll 方法，用来 替换 字符串里面 所有指定的 子字符串 为另一个 字符串<br>startsWith 和 endsWith<br>startsWith 方法检查字符串是否以参数指定的字符串 开头，如果是，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>endsWith 方法检查字符串是否以指定的字符串 结尾，如果是，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>字符串模板:就是在字符串使用 反引号 ，然后占位符使用 ${} ,里面直接放入对应的数据对象。<br>转义符:\n 就是一个转义字符，表示一个换行字符,用 \t 表示tab字符,用 \x41 表示 <span class="hljs-variable constant_">ASCII</span>编码为<span class="hljs-number">0x41</span>的字符（也就是字符 A），用 \u767d 表示 unicode编码为<span class="hljs-number">0x768d</span>的字符（也就是汉字 白）<br>也可以 使用反引号 ，在字符前面加上一个 <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span> ，表示字符串内容是raw string， 无需转义，像这样<br>path = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`c:\windows\temp`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path)<br>数字对象<br>数字对象<span class="hljs-title class_">Number</span> 有如下常用的属性方法<br><span class="hljs-built_in">parseInt</span>、<span class="hljs-built_in">parseFloat</span><br>可以使用 <span class="hljs-title class_">Number</span> 的 <span class="hljs-built_in">parseInt</span> 方法，把字符串表示的数字转化为 整数，<br>可以使用 <span class="hljs-title class_">Number</span> 的 <span class="hljs-built_in">parseFloat</span> 方法，把字符串表示的数字转化为 数字（整数或小数）<br>toString<br>可以使用 <span class="hljs-title class_">Number</span> 的 toString 方法，把字符串表示的数字转化为 整数<br><span class="hljs-comment">//循环</span><br>js 中有<span class="hljs-number">3</span>种类型的循环: <span class="hljs-keyword">while</span>循环 、 <span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>循环 和 <span class="hljs-keyword">for</span> 循环<br><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> 循环 肯定要先执行一次循环体内代码， 然后再判断是否继续循环的条件。<br>而 <span class="hljs-keyword">while</span> 循环 是 一开始就要先判断循环条件是否成立， 成立后再执行循环体代码。<br><span class="hljs-keyword">for</span> 循环更适合 循环执行某段代码 指定次数<br><span class="hljs-keyword">for</span> 循环的 后面那个括号里面有<span class="hljs-number">3</span>个语句组成<br><span class="hljs-keyword">for</span> (循环前执行代码; 循环继续与否判定表达式; 单次循环后执行代码) {<br>  <span class="hljs-comment">// 循环体代码</span><br>}<br>循环前执行代码：是 整个 <span class="hljs-keyword">for</span>循环前 要执行的代码，只执行<span class="hljs-number">1</span>次。<br>循环继续与否判定表达式：是每次循环前用来判定是否继续执行本次循环的表达式。<br>单次循环后执行代码：是每次循环后 要执行的一次语句，常用来执行 循环次数标记变量 的值变化<br>遍历数组<br>可以这样遍历数组，使用 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">of</span> 写法：这种写法适合遍历可遍历对象，比如 字符串<span class="hljs-title class_">String</span>、数组<span class="hljs-title class_">Array</span>、<span class="hljs-title class_">TypedArray</span>, <span class="hljs-title class_">Map</span>, <span class="hljs-title class_">Set</span> 等等。每次循环，都会依次，取出 <span class="hljs-keyword">of</span> 后面的数组里面的对象，赋值给 <span class="hljs-keyword">of</span> 前面定义的变量，执行循环体里面的代码<br>遍历对象<br>如果我们需要遍历一个对象里面的所有属性和值，怎么办？<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span> 方法可以返回 对象的属性和值 到一个数组，方便我们遍历，然后使用 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">of</span> 遍历数组<br><span class="hljs-keyword">break</span> 终止循环<br>解释器执行到 循环内的 <span class="hljs-keyword">break</span> 语句，就会从循环退出。<br><span class="hljs-keyword">continue</span>：只结束当前这一轮循环，后面还要继续循环的执行。<br><br><span class="hljs-comment">//类和继承</span><br>类型是 具有共同特征（属性、行为）的对象 的 特性 的定义。是特征的集合<br>js中对象种类的共同特性 的提取定义， 是 通过 原型对象（包括构造函数） 实现的。<br>定义类使用关键字 <span class="hljs-keyword">class</span> 后面加 类的名称。紧跟类名 后面的花括号里面的所有内容就是 类定义，是该类的所有 属性（方法）的定义。<br>从定义的类来 创建对象 也是使用 <span class="hljs-keyword">new</span> 操作符，后面加上类名和括号，括号里面的参数是传递给 类定义里面 名为 constructor 的方法的 。constructor 被称之为构造函数， 作用类似前面讲的独立构造函数。<br>这个方法在 使用 <span class="hljs-keyword">new</span> 创建这个类 对应的 对象时，会被解释器自动调用 ，并且传入<span class="hljs-keyword">new</span> 语句里面的参数。<br>类里面定义的函数（包括constructor） 可以叫类的方法， 都是 不需要 <span class="hljs-keyword">function</span> 关键字 声明的<br>前面，我们说过 构造函数 也可以看作类型， 构造产生的对象 ，就是 这个构造函数类型的实例。<br>类的继承关系<br>通常我们把被继承的类称之为 父类 或者 基类 或者 超类<br>把继承类称之为 子类 或者 派生类。<br>类的继承关系可以通过关键字 extend<br>子类会自动拥有父类的一切属性和方法，子类和父类不同的地方，可以重新定义<br>子类 实例化时，如果构造函数里面行为 和 父类不完全一样，这时候，就需要 重定义 constructor 函数 。<br>可以直接使用关键字 <span class="hljs-variable language_">super</span> 直接调用父类的constructor代码<br>注意 <span class="hljs-variable language_">super</span>不仅仅可以代表调用父类的构造函数方法，也可以调用父类的其他方法<br><span class="hljs-comment">//错误对象</span><br>js 还有其他的错误类型， 都是继承自 <span class="hljs-title class_">Error</span> 类型，代表各种不同类型的错误。<br>抛出错误<br>抛出错误, 使用关键字 <span class="hljs-keyword">throw</span> ，后面加一个错误对象，这里是新构建一个对象，直接使用 <span class="hljs-title class_">Error</span> 构造函数创建。<br>执行完 <span class="hljs-keyword">throw</span> 抛出异常的代码后， 后续的代码不会再执行<br>捕获错误<br>使用 <span class="hljs-keyword">try</span>... <span class="hljs-keyword">catch</span> ... 这样的语法来捕获和处理错误。<br><span class="hljs-keyword">try</span> 下面缩进的花括号里面的代码可以看成是 监控区 中的代码。<br><span class="hljs-keyword">catch</span> 引导的代码段 就是对 错误 的一种处理。<br><span class="hljs-keyword">try</span> ... <span class="hljs-keyword">catch</span> 后面还可以跟一个 <span class="hljs-keyword">finally</span> 代码块。<br><span class="hljs-keyword">finally</span> 代码块的代码， 不管<span class="hljs-keyword">try</span> 里面有无错误抛出，都要执行的。<br><span class="hljs-comment">//剩余参数</span><br>函数参数的 个数是不确定的，前面加 <span class="hljs-number">3</span>个点 的参数，称之为 剩余参数（rest parameters） 。<br>展开语法：在调用函数时，对于剩余参数时的传递，可以使用三个点操作符 ...，这就是 展开语法(<span class="hljs-title class_">Spread</span> syntax) <br><span class="hljs-comment">//回调、匿名函数、this</span><br><span class="hljs-comment">// 注册事件回调函数</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#go'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, salaryStats );<br>所以 salaryStats 这种 先定义，后面在某个时候被调用的函数，叫 回调函数<br>和 <span class="hljs-title class_">Python</span>、<span class="hljs-title class_">Java</span> 等语言不同，js 的执行引擎设计是 异步架构<br>这里的 异步 是什么意思呢？<br>就是 碰到阻塞性的调用，比如 定时等待、网络操作、磁盘<span class="hljs-variable constant_">IO</span>等等， js引擎都不会停止后面代码的执行来 等 这些操作完成。<br>这种异步的架构设计，设计模式里面 叫做 reactor 模式<br>系统底层实现基本都是一个 主循环处理各种事件，比如 网络socket收到数据、文件读取数据返回、定时器超时 等等。然后调用相应的 用户代码进行处理。碰到阻塞性的操作，不会等，而是记录好操作完成的回调代码，继续执行后面的用户代码。用户代码都执行完了，就返回主循环，处理下一个需要处理的事件。这种架构， 特别适合 <span class="hljs-variable constant_">IO</span> bound（也就是 高<span class="hljs-variable constant_">IO</span>，低<span class="hljs-variable constant_">CPU</span>） 的软件系统，典型的就是网站服务系统。因为它能高效的利用<span class="hljs-variable constant_">CPU</span>。<br>这个好像 操作系统多线程 调度的概念。操作系统可以让处于执行阻塞操作（读文件，等待网络消息）的线程让出<span class="hljs-variable constant_">CPU</span>执行权，让其它线程占据<span class="hljs-variable constant_">CPU</span>执行代码。这样大大减少了<span class="hljs-variable constant_">CPU</span>闲置 ，这是 操作系统 对 多个线程 的 调度<br>而异步的软件架构，是程序自身（比如js引擎）实现的 单线程 自身的内部代码 整理和调度。<br>相比 操作系统多线程方式，它的效率更高，因为，多线程调度涉及到 操作系统调用，导致 <span class="hljs-variable constant_">CPU</span>的执行模式切换，是要额外耗费资源的。而且，没有多线程操作共享资源的同步问题。因为实际上，这是单线程<br>匿名函数：使用 匿名函数 避免这种起名字的麻烦<br>匿名函数如果 单独定义在非参数位置，并且不赋值给变量，需要加上括号<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>){<br>  <span class="hljs-keyword">return</span> a + <span class="hljs-number">100</span>;<br>})<br>箭头函数<br><span class="hljs-title class_">ES6</span> 引入了 箭头函数 这种新的定义匿名函数的语法，更加精简<br>a =&gt; { <br>  <span class="hljs-keyword">return</span> a + <span class="hljs-number">100</span>;<br>}<br>如果 箭头函数 体内 只有一行代码，并且是返回一个值，可以省略 <span class="hljs-keyword">return</span> 和 花括号<br>a =&gt; a + <span class="hljs-number">100</span><br>回调函数中的<span class="hljs-variable language_">this</span>：<br>通过哪个对象调用了这个函数，函数里面的 <span class="hljs-variable language_">this</span> 对应的是就是这个对象<br>箭头函数中的<span class="hljs-variable language_">this</span>：箭头函数中的<span class="hljs-variable language_">this</span>比较特殊，它对应的 是 包含该箭头函数 的函数的执行环境<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="JS前端"><a href="#JS前端" class="headerlink" title="JS前端"></a>JS前端</h2><ul>
<li><p>怎么用 js 语言实现 <code>浏览器相关</code> 的 操作呢？浏览器运行环境 提供了 丰富了 js语言编程接口 ， 称之为 <code>Web API</code> 接口。</p>
</li>
<li><p>浏览器内置window对象：</p>
<ul>
<li><p>对应的是一个 <code>Window</code> 类型的对象，它代表了 js 运行的这个浏览器窗口环境。由于它代表的就是整个浏览器js运行环境，所以这个对象的属性方法可以直接在js代码中使用，不需要加上 <code>window.</code> 作为前缀，比如，我们前面学过的 <code>prompt、alert、confirm</code> 其实就是 window的方法</p>
</li>
<li><p>history、location：<code>history</code> 对应 就是 当前浏览器的 浏览历史对象</p>
</li>
<li><pre><code class="language-js">// 返回上次浏览地址，等于点击浏览器的返回按钮
history.back();
// 也是 返回上次浏览地址
history.go(-1);
// 前进到返回前面的地址，等于点击浏览器的前进按钮
history.forward();
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><br>+ `<span class="hljs-keyword">location</span>` 对应 就是 当前浏览器的 地址对象<br><br>  ```js<br>  <span class="hljs-comment">// 设置当前浏览地址</span><br>  <span class="hljs-keyword">location</span>.href = '/main.html'<br>  <span class="hljs-comment">// 重新加载网页，等于刷新网页</span><br>  <span class="hljs-keyword">location</span>.reload()<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p><code>localStorage</code> 可以看作一个 本地键值对数据库，它是当前网站的 前端存储，关闭浏览器窗口后也不会丢失数据</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存入/修改 数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myCat'</span>, <span class="hljs-string">'Tom'</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">const</span> cat = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myCat'</span>);<br><br><span class="hljs-comment">// 清除localStorage 数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>sessionStorage</code> 也是一个 本地键值对数据库，它也是当前网站的 前端存储，和 <code>localStorage</code> 的差别是， 它的数据是和session相关的。关闭浏览器窗口后，数据就会丢掉。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 清除 sessionStorage 数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-comment">// 存入/修改 数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myCat'</span>, <span class="hljs-string">'Tom'</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">const</span> cat = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myCat'</span>);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>close()</code> 方法可以 关闭当前窗口</p>
</li>
<li><p><code>open()</code> 方法可以 打开一个新的窗口</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 打开新空窗口</span><br><span class="hljs-title function_">open</span>()<br><br><span class="hljs-comment">// 打开新窗口，访问指定url</span><br><span class="hljs-title function_">open</span>(<span class="hljs-string">'https://www.byhy.net'</span>)<br><br><span class="hljs-comment">// 直接本窗口打开访问指定url</span><br><span class="hljs-title function_">open</span>(<span class="hljs-string">'https://www.byhy.net'</span>, <span class="hljs-string">'_self'</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>DOM 文档对象模型:</p>
<ul>
<li><p>浏览器加载网页（根据html文档和一些代码） 后， 会在浏览器内部（内存中）创建一个文档对象模型 (document object model) 简称 <code>DOM</code> 对象 ， 对应 树状的 文档结构。每个html元素以及每段字符串，都会对应DOM对象的一个 <code>节点（node）</code>,它们的上下层关系和html文档对应。</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tex">有如下一些DOM 相关的术语：<br><br>这个树状文档的 根节点（root node） 是 HTML节点<br><br>每个html元素 都对应一个 元素节点（Element node）<br><br>有的元素节点，有其 子节点（Child node） ，相对而言，它就是其子节点的 父节点（Parent node）<br><br>某个元素节点 分支下面所有的子节点、子节点的子节点，等等， 都是它的 后代节点（Descendant node）<br><br>相同父节点的节点 之间是 兄弟节点（Sibling nodes） 的关系<br><br>只包含一段文本字符串的节点是 文本节点（Text node）<br>特别要注意的是名词 元素（Element） 和 节点（Node） 的区别<br><br>任何 DOM对象都是一个 节点 ， 包括 元素节点、 注释节点、 文本节点、属性节点<br>节点类型	节点值<br>ELEMENT<span class="hljs-built_in">_</span>NODE	1<br>ATTRIBUTE<span class="hljs-built_in">_</span>NODE	2<br>TEXT<span class="hljs-built_in">_</span>NODE	3<br>CDATA<span class="hljs-built_in">_</span>SECTION<span class="hljs-built_in">_</span>NODE	4<br>PROCESSING<span class="hljs-built_in">_</span>INSTRUCTION<span class="hljs-built_in">_</span>NODE	7<br>COMMENT<span class="hljs-built_in">_</span>NODE	8<br>DOCUMENT<span class="hljs-built_in">_</span>NODE	9<br>DOCUMENT<span class="hljs-built_in">_</span>TYPE<span class="hljs-built_in">_</span>NODE	10<br>DOCUMENT<span class="hljs-built_in">_</span>FRAGMENT<span class="hljs-built_in">_</span>NODE	11<br><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>元素（也叫元素节点） 只是其中一种 节点，它们是对应一个html元素的， 比如 body、p、span、div 这些节点。</p>
</li>
<li><p>其它的，比如注释节点、文本节点 就不是 元素节点</p>
</li>
<li><p>整个DOM对象， 可以通过 js引擎内置对象 <code>window.document</code> 或者直接 <code>document</code> 访问到。</p>
</li>
<li><p>DOM对象中每个节点对象 都是可以通过 document对象 的一些内置方法获取到。</p>
</li>
</ul>
</li>
<li><p>网页程序示例</p>
<ul>
<li><p>现代的网站不仅仅只是富文本信息的呈现，可以 网页聊天、邮件交互、甚至可以在网页上打游戏</p>
<p>所以现在很多网页，其实 就是一个真正的 <code>应用程序</code> ，而不是传统意义上的 <code>网页</code> 了。</p>
</li>
<li><p>网页成为应用程序 的关键 就是 js 语言对网页内容的操作能力，主要就是： 得知网页事件、获取网页内容，改变网页内容</p>
</li>
<li><p>获取元素对象：网页应用程序，要管理界面，其实就是管理界面的一个个元素对应 的 DOM 对象。而要控制这些对象（获取信息、修改信息）， 首先得能在代码中 <code>获取这些DOM对象</code> ，然后才能调用它们的方法对其进行控制。选择对象，最灵活的方法就是使用 <code>querySelector</code> 、 <code>querySelectorAll</code> 方法，参数是 CSS 选择表达式</p>
</li>
<li><p><code>querySelector</code> 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 <code>querySelectorAll</code> 方法</p>
</li>
<li><p>事件和处理：什么时候网页 应该 执行我们写的代码？通常是某个事件发生的时候，比如用户输入数据后，按回车、 点击某个按钮、鼠标移动到某个元素上、等等。那么怎么告知浏览器，当某个事件发生，回调我们的代码呢？使用 DOM 对象的 <code>addEventListener</code> 方法。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;    <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">salaryStats</span>(<span class="hljs-params">event</span>){<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'执行salaryStats'</span>) <br>  }<br><br>  <span class="hljs-comment">// 注册事件回调函数</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#go'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, salaryStats );<br>  &lt;/script&gt;<br>其中 注册事件回调函数的代码 ，在 id 为 go 的元素上，使用 addEventListener 方法，注册了点击的事件， 当这种事件发生的时候，就回调执行函数 salaryStats 来处理这个事件。<br>salaryStats定义的时候，知道，浏览器回调自己的时候，会传入一个 <span class="hljs-title class_">MouseEvent</span>（鼠标事件）类型的对象。<br>事件类型 除了鼠标事件外，还有 键盘事件，滚轮事件、拖拽事件、剪贴板事件 等等。<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>获取网页内容：主要就是要通过DOM 对象的 <strong>属性</strong>。不同类型的html元素，对应的DOM 对象的类型是不同的</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> 对应的DOM对象类型是 HTMLAnchorElement<br><span class="hljs-selector-tag">p</span> 对应的DOM对象类型是 HTMLParagraphElement<br><span class="hljs-selector-tag">textarea</span> 对应的DOM对象类型是 HTMLTextAreaElement<br><span class="hljs-selector-tag">button</span> 对应的DOM对象类型是 HTMLButtonElement<br><br>document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">'#salary'</span>)<span class="hljs-selector-class">.value</span><br>从HTMLTextAreaElement的属性表得知，textarea文本框里面的内容 对应的是属性 value<br></code></pre></td></tr></tbody></table></figure>

<p>等等</p>
</li>
<li><p>改变网页的内容：和获取网页内容一样，要改变网页内容，首先要获取 对应的 DOM对象，然后通过对象的属性方法，改变其内容。通常有如下几类</p>
<ul>
<li><p>添加元素：可以给某个节点添加新节点，比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>)<br>  .<span class="hljs-title function_">insertAdjacentHTML</span>(<span class="hljs-string">"beforeend"</span>, <span class="hljs-string">"&lt;p id='test1'&gt;薪资20K以上的有：xxx、yyy&lt;/p&gt;"</span>)<br>insertAdjacentHTML 方法就是在<span class="hljs-variable constant_">DOM</span> 对象的某个位置插入新的html节点。<br>第<span class="hljs-number">2</span>个参数 就是要插入的节点对应的<span class="hljs-variable constant_">HTML</span> 内容<br>第<span class="hljs-number">1</span>个参数 指定插入节点的位置，这里 beforeend 就是 指 插入节点作为 当前节点的 最后一个子节点<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>删除元素：要删除元素，可以 先获取该元素，然后调用remove方法</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"test1"</span>).<span class="hljs-title function_">remove</span>()<br>还可以这样删除：<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myDiv"</span>).<span class="hljs-property">outerHTML</span>=<span class="hljs-string">""</span>;<br>支持这种方式的浏览器更广泛，包括<span class="hljs-variable constant_">IE</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>改变元素内容和属性：改变元素内容和属性 ， 同样也是通过DOM对象的方法</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置 id 为 salary的textarea 里面的内容 </span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">value</span> = <span class="hljs-string">`</span><br><span class="hljs-string">薛蟠     4560 25</span><br><span class="hljs-string">薛蝌     4460 25</span><br><span class="hljs-string">`</span><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">value</span> = <span class="hljs-string">''</span><br><br><span class="hljs-comment">// 改变 id为result元素的内部文本</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#result'</span>).<span class="hljs-property">innerText</span> = <span class="hljs-string">'薪资20K以上的有：xxx、yyy'</span><br><br><span class="hljs-comment">// 改变id为result元素的文本颜色为红色</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#result'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span><br><br><span class="hljs-comment">// 改变button按钮文本</span><br><span class="hljs-keyword">let</span> addOneBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'button'</span>)<br>addOneBtn.<span class="hljs-property">innerText</span> = addOneBtn.<span class="hljs-property">innerText</span> === <span class="hljs-string">'隐藏'</span> ? <span class="hljs-string">'添加'</span> : <span class="hljs-string">'隐藏'</span>;<br><br>那么到底一个元素对应的<span class="hljs-variable constant_">DOM</span>对象有哪些属性方法呢？<br>还是要看<span class="hljs-variable constant_">DOM</span>对象的 类型<br>不同类型的<span class="hljs-variable constant_">HTML</span>元素对应的 <span class="hljs-title class_">HTMLElement</span> 对象不同， 属性也会有差异<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>控制元素是否显示：</p>
</li>
<li><p>控制元素是否显示，可以根据元素的CSS样式里面的 <code>display</code> 属性 ，当 <code>display</code> 的值为 <code>none</code> ，元素不显示</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pnEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.paginator'</span>)<br><span class="hljs-keyword">if</span>(pd.<span class="hljs-property">pagecount</span> === <span class="hljs-number">0</span>){<br>  pnEle.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">'none'</span><br>  <span class="hljs-keyword">return</span><br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>其它能力：浏览器 Web API编程接口还提供了其它能力，比如：和服务器通信能力包括HTTP/WebSocket等，浏览器端存储能力包括Local Storage, Session Storage, Cookie, IndexedDB等等，本地文件访问能力，定位能力等等，完整的编程接口，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API">点击参考这里</a>，这些js编程接口的API 提供了底层能力，我们运用好它们，就可以开发各种功能的网页应用程序</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>元素通用属性</p>
<ul>
<li><p>继承关系：要用js代码改变界面元素展示的内容、样式， 需要先获取该元素对应的 DOM 对象， 然后再通过调用对象的属性或者方法。不同类型的HTML元素对应的 DOM 对象类型不同， 属性、方法 也会有差异。但是所有的 HTML元素对象 都有相同的继承关系：</p>
<figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">EventTarget &lt;- Node &lt;- Element &lt;- HTMLElement <br></code></pre></td></tr></tbody></table></figure>

<p>我们知道，js对象可以使用其祖先类型的属性/方法，所以所有的HTML元素，不管是 p、div、span、button ， 他们对应的对象，都可以使用 EventTarget、Node、Element、HTMLElement 这些祖先类型的属性和方法，也就是页面元素DOM对象 <strong>通用</strong> 的属性和方法。</p>
</li>
</ul>
</li>
<li><p>EventTarget：<a target="_blank" rel="noopener" href="https://developer.mozilla.org//en-US/docs/Web/API/EventTarget">EventTarget</a>类型提供了如下方法：</p>
<ul>
<li><p>addEventListener()：用来注册处理 该对象的事件 的处理函数。</p>
</li>
<li><p>removeEventListener()：这是 类型 EventTarget 的方法，用来取消 注册处理 该对象的事件 的处理函数。</p>
</li>
</ul>
</li>
<li><p>Node：<a target="_blank" rel="noopener" href="https://developer.mozilla.org//en-US/docs/Web/API/Node">Node</a>类型提供了如下属性和方法：</p>
<ul>
<li><p>获取所有子节点：<code>childNodes</code>属性可以 获取元素的所有子节点对象，获取的子节点是所有的DOM子节点， 包括 html元素、文本、注释。返回的NodeList 类型，类似数组，可以使用for of 遍历， 里面的对象就是各自节点对应的类型</p>
</li>
<li><p>textContent：用来 获取 元素内部所有的文本内容，包括不可见的部分。这个属性也可以用来 设置 元素内部 文本内容</p>
</li>
<li><p>获取父元素节点：该属性返回这个Node的父HTML元素</p>
</li>
</ul>
</li>
<li><p>内置对象document：内置对象 <code>document</code> 的类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Document">Document</a> ， 继承关系如下，所以 <code>EventTarget</code> 和 <code>Node</code> 的属性方法，比如 <code>addEventListener()</code> , <code>childNodes</code> 等等 ， 对 document都是适用的。</p>
<figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">EventTarget &lt;- Node &lt;- Document<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>产生元素对象：<code>createElement</code> 方法可以产生元素对象。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target'</span>&gt;</span>原来的元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#target'</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> new1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span><br><span class="language-javascript">  new1.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素1'</span>;</span><br><span class="language-javascript">  p.<span class="hljs-title function_">after</span>(new1);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>寻找内部元素：寻找内部元素，最灵活的方法就是通过 document对象的 <code>querySelector</code> 、 <code>querySelectorAll</code> 方法，参数是 CSS 选择表达式，来选择元素。如果，没有找到符合条件的元素，返回 <code>null</code>，<code>querySelector</code> 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 <code>querySelectorAll</code> 方法，返回的是一个类似数组的对象<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a>，里面存放了所有符合条件的 DOM 对象。通过 document 调用 querySelector/querySelectorAll 是在整个DOM 里面选择元素。如果要在某个 DOM 元素 的 内部范围内选择，就可以调用这个 元素 DOM 对象的 querySelector/querySelectorAll 方法。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>).<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'span'</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>除了css表达式选择元素，还可以直接根据元素的 <code>id</code> 、 <code>name属性</code> 、 <code>标签名</code> 、 <code>class属性</code> 选择元素</p>
<p>比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据id选择，返回单个元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myDiv"</span>)<br><br><span class="hljs-comment">// 根据name属性选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">"btn"</span>)<br><br><span class="hljs-comment">// 根据标签名选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">"input"</span>)<br><br><span class="hljs-comment">// 根据class属性选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">"btn"</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>注意返回的一组对象时，是放在一个类似 数组的 对象 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection">HTMLCollection</a> 中，就像数组一样，可以直接通过索引访问对应的元素</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">"input"</span>)[<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>Element：我们常用的属性和方法大都是来自 <a target="_blank" rel="noopener" href="https://developer.mozilla.org//en-US/docs/Web/API/Element">Element</a> 类型的。</p>
</li>
<li><p>id：<code>id</code> 属性可以获取/设置 该元素的id属性。</p>
</li>
<li><p>children 只读：可以获取该元素的所有子元素，返回的是对象是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection">HTMLCollection</a> 类型，这个类型 功能类似 数组，里面存放的是 html元素对象，可以使用 <code>for of</code> 遍历， 也可以使用索引获取其中的元素。</p>
</li>
<li><p>innerHTML、outerHTML：<code>innerHTML</code> 可以用来获取一个元素对象 <code>内部</code> HTML文本；<code>outerHTML</code> 可以用来获取一个元素对象 <code>全部</code> HTML文本。</p>
</li>
<li><p>获取内部元素：如果我们只要在某个元素的内部获取元素，通用的针对某个元素调用这些方法即可。同样，如果没有找到符合条件的元素，querySelector 返回 <code>null</code>。</p>
</li>
<li><p>获取上级元素：<code>closest()</code> 方法获取符合条件的 <code>最接近</code> 的上级元素，参数是一个css选择表达式。如果自身也匹配，则返回本元素自身，因为自身更接近自身。如果没有匹配的元素，则返回null</p>
</li>
<li><p>添加元素：Element方法中，有好几个用来添加节点。after() / before() / append()，<code>after</code> 是给当前元素节点，添加一些 <code>后续弟弟节点</code> ，参数可以是1个或者 多个节点对象，参数可以是 元素对象 （添加后成为html元素） 或者 字符串（添加后成为文本节点）</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target'</span>&gt;</span>原来的元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/body&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'target'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> new1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  new1.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素1'</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> new2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  new2.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素2'</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  p.<span class="hljs-title function_">after</span>(new1,new2,<span class="hljs-string">'abc'</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>

<p>相反，<code>before</code> 是给当前元素节点，添加一些 <code>前置哥哥节点</code>,<code>append</code> 是给当前元素节点，添加一些 <code>子节点</code> ，</p>
<ul>
<li><p>insertAdjacentHTML()：使用 after() / before() / append()，必须先使用 <code>document.createElement()</code> 创建一个元素对象然后再调用新对象的方法，创建内容。写起来比较麻烦。可以使用 insertAdjacentHTML` 方法直接写元素对应的html文本内容。比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p&gt;薪资统计&lt;/p&gt;<br><br>&lt;script&gt;<br>  let pEle = `<br>      &lt;br&gt;&lt;br&gt;<br>      &lt;p&gt;小张: &lt;mark&gt;15000&lt;/mark&gt;&lt;/p&gt;<br>      &lt;p&gt;小李: &lt;mark&gt;18000&lt;/mark&gt;&lt;/p&gt;<br>`<br>  document.querySelector('p')<br>  .insertAdjacentHTML("beforeend", pEle)<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>

<p><code>insertAdjacentHTML</code> 方法就是在DOM 对象的 <code>某个位置</code> 插入新的html节点。</p>
<ul>
<li><p>第2个参数 就是要插入的节点对应的HTML文本</p>
</li>
<li><p>第1个参数 指定插入节点的位置</p>
</li>
<li><p><code>afterbegin</code></p>
<p>插入内容 作为 当前节点的 <code>第一个子节点</code></p>
</li>
<li><p><code>beforeend</code></p>
<p>插入内容 作为 当前节点的 <code>最后一个子节点</code></p>
</li>
<li><p><code>beforebegin</code></p>
<p>插入内容 作为 当前节点的 <code>前一个哥哥节点</code></p>
</li>
<li><p><code>afterend</code></p>
<p>插入内容 作为 当前节点的 <code>下一个弟弟节点</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除元素:<code>remove()</code> 方法用来删除元素自身。</p>
</li>
<li><p>替换元素：可以使用 <code>outerHTML</code> 、 <code>innerHTML</code> 属性替换元素。也可以使用 <code>replaceWith</code> 方法替换元素</p>
</li>
<li><p>获取元素属性：<code>getAttribute()</code> 可以用来获取元素的属性， <code>getAttribute()</code> 返回值都是字符串的形式，有的属性，也可以直接通过 <code>元素对象.属性</code> 的方式获取元素的属性，但是这种方式只能获取元素的标准属性， 不能获取自定义非标准属性的值，而且有的属性获取的结果和 <code>getAttribute()</code> 不一样，返回值不一定是字符串，比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">style</span> <span class="hljs-comment">// 得到的值 类似 Object类型</span><br>a.<span class="hljs-property">href</span>  <span class="hljs-comment">// 得到的值是全路径</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置元素属性：<code>setAttribute()</code> 可以用来设置元素的属性，参数 都是字符串的形式，也可以直接通过 <code>元素对象.属性</code> 的方式设置元素的属性，而且有的设置方式和 setAttribute()不一样，因为 <code>元素对象.属性</code> 的方式值不都是字符串，比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'green'</span><br></code></pre></td></tr></tbody></table></figure>

<p>style 属性其实不是 <code>Element</code> 类型里面的，是 <code>HtmlElement</code> 类型里面的</p>
</li>
<li><p>删除元素属性：<code>removeAttribute()</code> 用来删除元素的属性</p>
</li>
<li><p>class属性：class属性操作， 除了前面讲的通用方法，还可以这样操作：className<code>className</code> 可以用来，获取和设置元素的class属性，之所以不直接用 <code>class</code> 作为属性名，是为了避免和 js 的关键字 class 冲突,<code>className</code> 是对元素 <code>class属性整体</code> 当作一个字符串操作的。如果想单独操作某个class ，不改变其它class属性，推荐使用 <code>classList</code> 属性，<code>classList</code> 属性对应一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList">DOMTokenList</a> 类型， 有一些方便操作属性值的方法，比较常用的是：<code>contains</code> 方法、<code>remove</code> 方法、<code>add</code> 方法。</p>
</li>
<li><p>HtmlElement：有如下常用属性方法</p>
</li>
<li><p>innerText、outerText：HtmlElement 的 <code>innerText</code> 和 Node 的 <code>textContent</code> 属性都可以 <code>获取/设置</code> 元素内部的文本内容区别是：innerText 展示的是该元素对应的可以呈现在界面上的文本内容；textContent 展示的是元素内部所有的文本内容，包括不可见的部分</p>
</li>
<li><p>style：style属性的值是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration">CSSStyleDeclaration</a> 类型， 类似 Object类型， 可以通过这个对象的属性来 获取、设置 元素的样式</p>
</li>
<li><p>focus()：focus方法可以让该元素获取输入焦点，前提是这种元素可以获取输入焦点</p>
</li>
<li><p>click()：click 方法 模拟鼠标点击该元素</p>
</li>
<li><p>元素自身属性：前面学习了HTML元素通用的属性和方法，不同类型的HTML元素对应的 DOM 对象类型不同，属性也会有差异。这里我们学习一些常用HTML元素对象 <strong>自身</strong> 的属性方法，注意：下面介绍的元素属性，如果没有特别标记为 <code>只读</code> ， 就是 <code>既可读、也可写</code></p>
<ul>
<li><p><code>a</code>： 对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement">HTMLAnchorElement</a>。常用属性有： hash host hostname href origin port protocol search</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">'https://www.byhy.net:80/py/lang/basic/09?name=byhy&amp;pagenum=23#pop'</span> <br>   target=<span class="hljs-string">'_blank'</span>&gt;<br>  测试连接<br>&lt;/a&gt;<br><br>&lt;br&gt;&lt;br&gt;<br>脚本运行结果如下<br>&lt;pre style=<span class="hljs-string">'font-size:1rem'</span>&gt;&lt;/pre&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> pre = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'pre'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  pre.<span class="hljs-property">innerText</span> = <span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.hash     = <span class="hljs-subst">${a.hash}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.host     = <span class="hljs-subst">${a.host}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.hostname = <span class="hljs-subst">${a.hostname}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.href     = <span class="hljs-subst">${a.href}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.origin   = <span class="hljs-subst">${a.origin }</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.port     = <span class="hljs-subst">${a.port}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.protocol = <span class="hljs-subst">${a.protocol}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.search   = <span class="hljs-subst">${a.search}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">`</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>button：对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement">HTMLButtonElement</a>，常用属性有：disabled，是个bool值，表示该按钮是否被禁用，禁用为true，可用为false</p>
</li>
<li><p>img：对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement</a>，常用属性有：alt，对应 img 元素的 alt属性， 当图片显示失败时（比如url错误），在图片位置显示的文本内容；height，对应 img 元素的 高度，数字为单位，表示像素；width，对应 img 元素的 宽度，数字为单位，表示像素；src，对应 img 元素的 的url地址</p>
</li>
<li><p>input：对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement">HTMLInputElement</a>，常用的通用属性和方法有：value属性对应输入框里面的文本；name属性；type属性；disabled是个bool值，表示该按钮是否被禁用，禁用为true，可用为false</p>
</li>
<li><p>input - text，email，password，number：类型是 text，email，password，number 等这些输入框input，有如下属性：maxLength/minLength，最多和最少输入的字符数量；placeholder；readOnly；size；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，</p>
<p>参数 replacement 指定用来替换的字符串，参数 start, end 是可选参数，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。</p>
</li>
<li><p>input - number：类型是 number 的数字输入框, 除了上述属性外，还有下面的属性，max、min，max指定了 输入框 可输入数字最大值，超过该值时会有错误提示，min指定了 输入框 可输入数字最小值，小于该值时会有错误提示，点击增加箭头，不会超过该数值；step一个数字，表示输入框数字的增减单位。</p>
</li>
<li><p>input - radio，checkbox：checked，该属性值为bool类型，表示是否选中；defaultChecked，该属性值为bool类型，表示缺省（页面刚加载完成时）是否选中；</p>
</li>
<li><p>textarea<code>：对应的DOM对象类型是 对应的DOM对象类型是 [HTMLTextAreaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement)，常用属性有：value，返回/设置 文本框内的输入内容；rows/cols，</code>rows<code>、</code>cols<code>属性分别指定 输入框的行数和列数；disabled，返回/设置 是否禁用文本框，被禁用后，就不能输入内容了；maxLength/minLength，也就是最多和最少输入的字符数量；placeholder；wrap，返回/设置 一行文字超过文本框宽度时 如何显示，取值为off，一行文字超过文本框宽度时，不换行， textarea元素出现水平滚动条，soft，一行文字超过文本框宽度时，剩余内容 折到下一行显示，这是缺省值，hard，设置该值时，必须同时指定</code>cols` 属性这样，一行文字超过文本框宽度时，浏览器自动插入换行符 (CR+LF)，剩余内容 折到下一行显示；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，参数 replacement 指定用来替换的字符串，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。</p>
</li>
<li><p>select 和 option：<code>select</code> 对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement">HTMLSelectElement</a>，<code>option</code> 对应的DOM对象类型是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement">HTMLOptionElement</a>，<code>HTMLSelectElement</code> 常用属性、方法有：options 只读，返回 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionsCollection">HTMLOptionsCollection</a> 对象， 里面存放了所有的option对应的 HTMLOptionElement 对象；value，返回/设置 第一个选定 option 元素的value属性，值为 空字符串 表示未选择任何元素；selectedIndex，返回/设置 第一个选定 option 元素的索引数字，值为 -1 表示未选择任何元素；disabled，返回/设置 是否禁用选择框，被禁用后，就不能选择了；type 只读，返回 表示支持多选与否的字符串。 当该select有multiple属性时，返回“select-multiple”， 否则，返回“select-one”；add(item, before)，添加选项，有两个参数，item，新增 HTMLOptionElement 对象 或者 HTMLOptGroupElement 对象，before，表示在哪个索引对应的选项前插入，值为数字，插入到index对应的位置上，该参数可选，如果没有传入值，或者为一个不存在的index，则新选项会插入到最末尾；remove(index)，删除选项，参数index表示要删除选项的位置索引，值为数字；<code>HTMLOptionElement</code> 常用属性、方法有：value，返回/设置 该 option 元素的value属性；text，返回/设置 该 option 元素的 选项文本内容，selected，返回/设置 该 option 元素是否被选择，是为 true，否为 false；index 只读，返回 该 option 元素的索引值。</p>
</li>
</ul>
</li>
<li><p>事件处理：addEventListener，可以告知浏览器，当某个事件发生时，执行哪个函数进行处理。除了使用 <code>addEventListener</code> 指定 事件处理函数，还可以使用 元素对应 DOM 对象的事件属性 指定 事件处理函数，事件属性名是 <code>on</code>开头，后面加事件名称，比如： <code>onkeydown</code> 、 <code>onclick</code> 等等。还可以直接在 <code>元素属性中设置事件处理</code>这叫html 内联定义 - 不推荐，这样破坏了html界面和js代码的分离，不方便维护</p>
</li>
<li><p>事件针对的元素：针对哪个元素dom对象调用 addEventListener 方法， 就是在这个元素的范围内注册事件处理函数。非这个元素内发生的 注册事件 ，不会触发调用。</p>
</li>
<li><p>代码在html中的位置：很多人喜欢把js内嵌的代码都集中放在head里面，在head中的js代码在网页内容（也就是body中的内容）渲染前，会被先执行。这样 DOM 里面内容还没有创建， 还没有body节点，所以会报错。为解决这个问题，可以定义load事件，因为页面资源完成全部加载，包括页面HTML所有DOM对象产生，界面渲染完成，引用的外部js、css、图片加载完成 等等，会发出load事件：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>});<br><span class="hljs-comment">//参数event 就是 load事件对象,如果不需要处理该对象，可以忽略，像这样:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>});<br><span class="hljs-comment">//也可以使用 window对象的onload属性:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>};<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>事件对象和类型：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">onkeydown</span> = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>{<br>  <span class="hljs-comment">// 处理代码</span><br>}<br><span class="hljs-comment">//这个里面的 event 参数对应的就是，事件发生时，浏览器传入回调我们的函数时，传入的 事件对象,不同的用户操作触发的事件对应的事件对象的类型不同,比如我们上面的是键盘事件，对应的就是 键盘事件（KeyboardEvent） 对象类型如果是鼠标按钮点击操作，对应的就是 鼠标事件（MouseEvent） 对象类型。不同类型的对象，其属性、方法 不同比如 上例中，我们是 键盘事件，传入的是键盘事件对象，它有属性：</span><br>ctrlKey<br>如果事件发生时，ctrl键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br>altKey<br>如果事件发生时，alt键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br><span class="hljs-title class_">Shift</span><br>如果事件发生时，shift键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br>key<br>返回 事件发生时，按下按键的字符串表示，比如<br><br><span class="hljs-title class_">Enter</span> 对应回车键<br><br><span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 对应数字键 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span><br><br>a、b、c、d 对应字母键 a、b、c、d<br><br>A、B、C、D 对应字母键 A、B、C、D<br><br>等等，大家可以通过 在代码中加上<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">key</span>)<br>查看你的按键对应的到底是什么key属性的值<br>事件对象类型 有很多，除了 键盘事件、鼠标按钮事件 外，还有 滚轮事件（<span class="hljs-title class_">WheelEvent</span>）、拖拽事件（<span class="hljs-title class_">DragEvent</span>）、游戏触控板事件（<span class="hljs-title class_">GamepadEvent</span>） 等等。<br><br><span class="hljs-comment">//还有的事件不是用户操作触发的，比如 页面加载完成事件、网址hash更改事件（HashChangeEvent）、websocket网络消息事件、 存储事件 等等</span><br></code></pre></td></tr></tbody></table></figure>


</li>
<li><p>事件处理顺序：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">浏览器创建一个 click 事件对象,这个事件对象会先从 浏览器<span class="hljs-variable constant_">DOM</span> 顶层的 <span class="hljs-variable language_">window</span> 对象一直 传递下去，直到 触发事件的对象的父对象 ，这个过程称之为 capture <span class="hljs-title class_">Phase</span>（捕获阶段）。这个路径上，如果有任何<span class="hljs-variable constant_">DOM</span>对象注册了点击处理事件，就会按照从上到下的先后顺序，依次被调用。<br>然后，这个事件对象 到达触发事件的td对象，这个过程称之为 target phase（目标阶段）<br>然后，这个事件对象 再从触发事件的td对象，一直传递到顶层的<span class="hljs-variable language_">window</span>对象，这个过程称之为 bubbling <span class="hljs-title class_">Phase</span>（冒泡阶段）<br>注意， click 事件是会 冒泡传播 的， 但是也有些类型的事件（比如，blur、focus）是不会冒泡的，到target 位置就结束了。要声明注册的处理函数是在 捕获阶段 触发执行 ，应该这样<br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码}, <span class="hljs-literal">true</span>)<br>第<span class="hljs-number">3</span>个参数如果是boolean 并且设置为<span class="hljs-literal">true</span> ，就表示是 <span class="hljs-title class_">Capture</span> <span class="hljs-title class_">Phase</span>触发行。要声明注册的处理函数是在 非捕获阶段（target phase 和 bubbling <span class="hljs-title class_">Phase</span>）触发执行 ，应该没有第<span class="hljs-number">3</span>个参数，或者第<span class="hljs-number">3</span>个参数为<span class="hljs-literal">false</span>，如下：<br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码})<br><span class="hljs-comment">// 或者这样</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码}, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>事件对象 target属性 / this：当我们实现事件处理函数的时候，传入的参数对象就是 触发的事件对象，这里我们用变量名 <code>e</code> 指代它，这个事件对象的属性中 有两个要注意的：<code>e.target</code> 指代了 真正触发事件的那个DOM对象，而<code>e.currentTarget</code> 指代了当前 正在处理事件的DOM对象， 也就是当前处理函数 注册对应那个对象。在处理函数中，也可以使用 <code>this</code> ，等价于 <code>event.currentTarget</code></p>
</li>
</ul>
<h3 id="jQuter"><a href="#jQuter" class="headerlink" title="jQuter"></a>jQuter</h3><ul>
<li><p><code>jQuery</code> 是一个非常流行的 js库，方便我们进行 web 前端开发。主要的用途有： 操作DOM对象、事件处理 、和服务端通信、常用功能库、动画效果。特别是早期前端开发，当时 js语言 和 浏览器 Web API 功能比较少，使用jQuery提供的库，可以大大提高开发人员的效率，几乎是web前端开发必不可少的库。后来 js语言本身 和 浏览器 Web API 不断完善 ，现在通常可以不需要 jQuery，但是仍有大量的第三方库 和 现有项目的代码 依赖 jQuery，所以还是有必要学习的。</p>
</li>
<li><p>jQuery的安装：开发环境下，要使用 jQuery 库，可以在本地服务创建一个库目录，然后把 jQuery 库 从 <a target="_blank" rel="noopener" href="https://jquery.com/download/">官网下载地址</a>下载本地库目录中。还可以直接使用 <code>靠谱的</code> js库 公共cdn推荐如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">jsdelivr<br><span class="hljs-number">3.6</span><span class="hljs-number">.0</span> 版本的jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js</span><br><br>由于目前 <span class="hljs-number">3.6</span><span class="hljs-number">.0</span> 就是最新版，可以简化写为<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js</span><br><br>cdnjs<br>jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js</span><br><br>字节跳动公共库cdn<br>jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js</span><br>大家可以把 jQuery 库的url地址 添加到你的网页head中，比如<br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="hljs-comment">//注意：公共cdn有时会突然宕机，所以正式产品部署时，还是下载部署到自己的网站上，或者自己购买的CDN云服务上（比如 阿里云CDN+OSS）</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>选择元素和事件处理：html中 引入jQuery 库链接后，就可以使用该库了，先看一下jQuery 如何选择元素并进行事件处理。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'b1'</span>&gt;</span>测试按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'b2'</span>&gt;</span>测试按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;body&gt;<br><span class="hljs-comment">//其中 jQuery 本身就是一个构造函数， 里面的参数是css 选择器,jQuery('button') 返回的就是一个 jQuery 对象。这个对象类似js的数组，里面包含了所有参数 css 选择器 选中的DOM对象。jQuery 对象的 on 方法，用来定义事件处理,第一个参数就是事件名称，第二个参数是回调函数,还有一种简便写法，如下</span><br><span class="hljs-title function_">jQuery</span>(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">click</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })<br><span class="hljs-comment">//如果返回的对象选择到了多个元素对象， 不需要循环定义每个元素对象的事件处理，而是可以一起定义。</span><br><span class="hljs-comment">//jQuery 还有一个简化的别名就是一个字符 $ 所以上面的代码也可以简写为</span><br>$(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })<br><span class="hljs-comment">//当然也可以注册处理其他类型事件，比如</span><br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>按ctrl+回车 试试<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  $(<span class="hljs-string">'textarea'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'keydown'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) { </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">ctrlKey</span> &amp;&amp; e.<span class="hljs-property">key</span>===<span class="hljs-string">'Enter'</span>)    </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按下了ctrl+回车'</span>) </span></span><br><span class="language-javascript"><span class="language-xml">  })</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;body&gt;<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>元素操作：</p>
<ul>
<li><p>添加元素</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'content1'</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target1'</span>&gt;</span>原来的元素1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'content2'</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target2'</span>&gt;</span>原来的元素2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="hljs-comment">//然后打开控制台，分别执行如下代码，看看html内容的变化,下面是添加子元素的示例</span><br><span class="hljs-comment">// 这样创建一个html元素对象 </span><br><span class="hljs-keyword">var</span> ele1 = $( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> );<br><br><span class="hljs-comment">// 添加到 div#content1 ，作为最后一个子元素</span><br>ele1.<span class="hljs-title function_">appendTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 当然也可以这样写</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> ).<span class="hljs-title function_">appendTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 添加到 #content1 ，作为第一个子元素</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素2&lt;/p&gt;"</span> ).<span class="hljs-title function_">prependTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 插入到 #target2 前面，作为哥哥节点</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素3&lt;/p&gt;"</span> ).<span class="hljs-title function_">insertBefore</span>( <span class="hljs-string">"#target2"</span> );<br><br><span class="hljs-comment">// 插入到 #target2 后面，作为弟弟节点</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素4&lt;/p&gt;"</span> ).<span class="hljs-title function_">insertAfter</span>( <span class="hljs-string">"#target2"</span> );<br><span class="hljs-comment">//还可以这样</span><br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">append</span>( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">prepend</span>( <span class="hljs-string">"&lt;p&gt;新元素2&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">before</span>( <span class="hljs-string">"&lt;p&gt;新元素3&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">after</span>( <span class="hljs-string">"&lt;p&gt;新元素4&lt;/p&gt;"</span> );<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>删除元素</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//删除元素方法很简单，先选中，然后调用 remove 方法，比如：</span><br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">remove</span>()<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>替换元素内容</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//先选中，然后调用 html 方法，更新元素内部的html，比如：</span><br>$( <span class="hljs-string">"#content2"</span> ).<span class="hljs-title function_">html</span>(<span class="hljs-string">`&lt;p id='target3'&gt;新元素2222&lt;/p&gt;`</span>)<br><span class="hljs-comment">//类似 浏览器内置的 元素对象的 innerHTML 方法</span><br><br><span class="hljs-comment">//调用 text 方法，更新元素内部的文本内容，比如：</span><br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">text</span>(<span class="hljs-string">`新元素22222`</span>)<br><span class="hljs-comment">//类似 浏览器内置的 元素对象的 innerText 方法</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>元素值操作</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//调用 val() 方法，可以获取或者设置一些元素的值，比如 input、select、textarea类似 HtmlElement 的 value 属性的作用,比如:</span><br><span class="hljs-comment">// 获取 id 为 username 的元素的值</span><br><span class="hljs-keyword">let</span> username = $(<span class="hljs-string">'#username'</span>).<span class="hljs-title function_">val</span>()<br><br><span class="hljs-comment">// 设置 id 为 username 的元素的值</span><br>$(<span class="hljs-string">'#username'</span>).<span class="hljs-title function_">val</span>(<span class="hljs-string">'byhy'</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>元素属性操作：</p>
<ul>
<li><p>获取元素属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//attr() 可以用来获取元素的属性，类似浏览器内置的 元素对象的getAttribute() 方法,返回值都是字符串的形式,如下：</span><br>&lt;a id=<span class="hljs-string">"hey"</span> <br>  style=<span class="hljs-string">'color:green;font-size: 2rem;'</span>  <br>  href=<span class="hljs-string">"/"</span> <br>  <span class="hljs-keyword">class</span>=<span class="hljs-string">'nav nav-item'</span><br>  attr1=<span class="hljs-string">'自定义属性'</span>&gt;<br>  一个链接<br>&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> a = $(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'id'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'style'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'href'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'class'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'attr1'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置元素属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//attr() 如果提供第2个参数，就是用来设置元素的属性，类似浏览器内置的 元素对象的setAttribute() 方法,比如</span><br>&lt;a id=<span class="hljs-string">"hey"</span> style=<span class="hljs-string">'color:green'</span>  href=<span class="hljs-string">"/"</span> attr1=<span class="hljs-string">'自定义属性'</span>&gt;一个链接&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> a = $(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'id'</span>, <span class="hljs-string">'new-hey'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'style'</span> , <span class="hljs-string">'color:blue'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'href'</span>, <span class="hljs-string">'https://www.byhy.net'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'attr1'</span>, <span class="hljs-string">'自定义属性2'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>删除元素属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//removeAttr()方法 用来删除元素的属性,类似浏览器内置的 元素对象的removeAttribute() 方法,比如</span><br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'id'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'style'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'href'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'attr1'</span>)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>style设置</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//css()方法 用来设置元素的style里面的某个样式属性,比如</span><br>a.<span class="hljs-title function_">css</span>(<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>)<br><br><span class="hljs-comment">//如果是点击某个元素，就设置这个被点击元素的style属性，可以这样写</span><br>&lt;a id=<span class="hljs-string">"hey"</span> <br>  style=<span class="hljs-string">'color:green;font-size: 2rem;'</span>  <br>  href=<span class="hljs-string">"#"</span>&gt;<br>  一个链接<br>&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  $(<span class="hljs-string">'a'</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  });</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// $(this) 代表了 触发这个点击事件的 对象，并且封装为一个JQuery对象，这样可以方便的使用JQuery对象更便捷方法。否则，如果我们只用 this，就得这样写</span><br>$(<span class="hljs-string">'.a'</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">"red"</span><br>});<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>和服务端通讯：</p>
<ul>
<li><p>XHR/AJAX：用户访问网页，包括网页里面内嵌的 CSS/js/图片 等等资源，通常是浏览器直接获取的，这种获取请求的HTTP被称之为 <strong>同步请求</strong>；而浏览器执行网页包含的js代码的过程，有时js代码还要到服务端 提交、获取数据， 这样的请求被称之为 <strong>异步请求</strong>，异步请求，典型的出现在前后端分离的web系统中。浏览器的js环境内置了一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 类型，简称 `XHR，可以这样创建一个 XHR 对象</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">//XHR 对象 有属性方法，支持 浏览器页面代码 和 服务端之间的通信。这种使用 XMLHttpRequest 对象 和 服务端之间的 通信技术，是一种异步的通信方式。而且开始的那几年，这种方式传输数据，使用的序列化方法主要是 XML， 所以又被称之为 AJAX (Asynchronous JavaScript And XML) 方式。使用 浏览器原生的 XMLHttpRequest 对象收发消息，可以点击这里了解。缺点是：写起来比较麻烦，所以目前并不推荐使用。现在比较多的用法是： 使用 jQuery库 ，或者 ES6引入的 fetch API,这里介绍 使用 jQuery库 和服务端通信</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>前后端API接口：当我们的js代码要服务端异步通信时，HTTP请求访问的服务端要获取的 不是像 HTML/CSS/JS 这样的静态文件资源，往往是要求服务端程序进行数据库操作后，再进行代码处理，返回的数据。这样的异步请求，往往被称为 <code>API请求</code>提供这种服务的后端，被称为 <code>API 服务端</code>这种服务接口，被称为 <code>API 接口</code> 。 该接口由系统设计者设计定义，通常会提供接口说明文档，针对该接口测试服务端实现、客户端实现，就是 大家经常听说的 <code>API接口测试</code>。</p>
<p>后端实现对 静态文件的访问服务 和 动态API请求服务，往往不是一个程序。</p>
<p>比如，静态文件是 nginx 提供的服务，API则是单独开发的业务服务程序</p>
<p>系统设计者在设计 API 接口消息时， 规定的 API 消息的 URL 路径会有明显的特征，比如都是以 <code>/api</code> 开头这样，后端可以配置哪些url访问请求是针对API接口的，转发为API服务。live Server有代理配置项，可以设置转发规则如下配置</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"liveServer.settings.proxy"</span>: {<br>  <span class="hljs-string">"enable"</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">"baseUri"</span>: <span class="hljs-string">"/api"</span>,<br>  <span class="hljs-string">"proxyUri"</span>: <span class="hljs-string">"http://127.0.0.1:80/api"</span><br>}<br><span class="hljs-comment">//其中 baseUri 就是配置什么样的请求是要转发给API服务的,这里 /api ， 就是把 /api 开头的 http请求 都转给 bysms系统处理，因为 bysms系统服务的IP和端口 是 127.0.0.1:80 ，所以 proxyUri 的值为 http://127.0.0.1:80/api ，也可以写成 http://127.0.0.1/api,注意： http://127.0.0.1:80/api 后面的部分 /api 不能少，否则如果是 http://127.0.0.1:80 ， 发送的url /api/customer ，到了 服务后端 就变成了 /customer</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>jQuery构建请求消息：可以使用jQuery库里面的 <a target="_blank" rel="noopener" href="https://api.jquery.com/jquery.ajax/#jQuery-ajax-settings">ajax()方法</a> 和服务端进行HTTP消息的收放。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//请求方法：典型的ajax()方法，接收一个settings参数，该参数是一个PlainObject类型， 可以把它当作 Object 来用，可以在里面设定 XHR（AJAX）请求的数据 ， 包括 请求方法、url、消息头和消息体，比如，要发送 get 请求，可以使用这样的代码</span><br>$.<span class="hljs-title function_">ajax</span>({  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>,        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>,  <br>})<br><span class="hljs-comment">//这里settings参数包含了两个键值对数据：type 是 HTTP方法，比如 GET,POST,PUT,DELETE,HEAD 等等url 是 请求的url地址，比如这里就是 /api/mgr/signin ，注意：这里url没有前面的 http://IP:端口 这部分，表示前面的这部分和当前网页前面的这部分相同。下面是是POST请求的一个代码示例</span><br>$.<span class="hljs-title function_">ajax</span>({  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>, <br>  <span class="hljs-attr">data</span>: {<br>    <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>,<br>  }<br>})<br><span class="hljs-comment">//这里 data 是请求消息体，如果请求的方法是get、post，还有简便写法，如下</span><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/mgr/signin'</span>)<br><br>$.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/mgr/signin'</span>,<br>      {<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span><br>      }<br>)<br><br><span class="hljs-comment">// 或者</span><br>$.<span class="hljs-title function_">get</span>({        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>,  <br>})<br><br>$.<span class="hljs-title function_">post</span>({     <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>, <br>  <span class="hljs-attr">data</span>: {<br>    <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>,<br>  }<br>})<br><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>url 和 url参数：可以使用浏览器内置的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams">URLSearchParams</a> 类型。URLSearchParams对象的方法 <code>toString</code> ,可以将对象序列化为 urlencoded 格式，比如：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> queryStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>({<span class="hljs-attr">code</span>:<span class="hljs-string">'6000001'</span>, <span class="hljs-attr">time</span>:<span class="hljs-string">'2022-02-23'</span> }).<span class="hljs-title function_">toString</span>()<br><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">`http://localhost/api/stock?<span class="hljs-subst">${queryStr}</span>`</span>)<br><br><span class="hljs-comment">//也可以使用 jQuery 的 param 方法</span><br><span class="hljs-keyword">var</span> queryStr = $.<span class="hljs-title function_">param</span>({<span class="hljs-attr">code</span>:<span class="hljs-string">'6000001'</span>, <span class="hljs-attr">time</span>:<span class="hljs-string">'2022-02-23'</span> })<br><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">`http://localhost/api/stock?<span class="hljs-subst">${queryStr}</span>`</span>)<br><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>消息头：jQuery 发送http请求要定制一些消息头，可以通过ajax方法的settings参数里面的 <code>headers</code> 属性设置，如下</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({  <br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/something'</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>, <br>  <span class="hljs-attr">headers</span>: {<span class="hljs-string">"X-Test-Header"</span>: <span class="hljs-string">"test-value"</span>}<br>})<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><h4 id="contentType"><a href="#contentType" class="headerlink" title="contentType"></a>contentType</h4><p>ajax方法的参数对象 contentType 设置消息头 contentType 的值</p>
<p>缺省为： <code>application/x-www-form-urlencoded; charset=UTF-8</code></p>
<p>可以改为其它的，比如</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,       <br>  contentType : <span class="hljs-string">'application/json'</span>, <br>  <span class="hljs-attr">data</span>: JSON.<span class="hljs-title function_ invoke__">stringify</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>}),<br>})<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>jQuery的请求消息体都是参数对象 settings的 <code>data</code> 属性中设置的，该属性的值可以是一个 Object 或者 字符串，urlencode 格式，消息体也可以是 urlencode 格式，同样可以使用 URLSearchParams 或者 jQuery的 param 方法。其实，如果使用jQuery发送请求， data参数如果是 Object，缺省行为就是转化为 urlencode格式，所以可以直接传对象，如下</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-comment">// 提交的网址</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://localhost/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,        <br>  <span class="hljs-attr">data</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'88888888'</span> }<br>})<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><h4 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h4><p>现在的API接口消息体 很多是JSON格式的字符串。</p>
<p>可以使用浏览器js内置对象 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a></p>
<p>JSON 的方法 <code>stringify</code> 可以序列化 js对象 为 JSON格式的字符串</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,       <br>  contentType : <span class="hljs-string">'application/json'</span>, <br>  <span class="hljs-attr">data</span>: JSON.<span class="hljs-title function_ invoke__">stringify</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'88888888'</span>}),<br>})<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>jQuery 解析响应消息：解析响应消息的前提是能正确获取到响应消息，如果使用的是jQuery， settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，可以在回调函数的第3个参数 <a target="_blank" rel="noopener" href="https://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a> 对象获取响应消息的信息，这个jqXHR 类型 是 XMLHTTPRequest 的扩展类型，封装了一些便捷方法。</p>
</li>
<li><p>消息头</p>
</li>
</ul>
<pre><code class="hljs"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-comment">// 获取状态码</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textStatus);<br>    <span class="hljs-comment">// 获取所有消息头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getAllResponseHeaders</span>());<br>    <span class="hljs-comment">// 获取某个消息头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">"content-length"</span>));<br>  },<br><br>  <span class="hljs-comment">// 错误  </span><br>  <span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">xhr, textStatus, errorThrown </span>){<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">${xhr.status}</span> \n<span class="hljs-subst">${textStatus}</span> \n<span class="hljs-subst">${errorThrown }</span>`</span>)<br>  }<br>})<br><span class="hljs-comment">//success 请求响应成功后的回调函数,所谓成功就是返回响应消息，回调函数被传入3个参数：</span><br>data 从服务端返回的数据<br>textStatus 返回的状态文本描述<br>xhr 这是 <span class="hljs-title class_">XMLHttpRequest</span>的扩展类型jqXHR的对象<br>error 请求响应失败后的回调函数<br><span class="hljs-comment">//回调函数被传入3个参数：</span><br>xhr 这是 <span class="hljs-title class_">XMLHttpRequest</span>的扩展类型jqXHR的对象<br>textStatus 返回的错误状态文本描述<br>比如：<span class="hljs-string">"timeout"</span>, <span class="hljs-string">"error"</span>, <span class="hljs-string">"abort"</span>, 等等 <span class="hljs-string">"parsererror"</span><br>errorThrown 异常对象文本<br>比如：<span class="hljs-string">"Not Found"</span> 或者 <span class="hljs-string">"Internal Server Error."</span><br><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
<ul>
<li><p>消息体解析：如果使用的是jQuery，ajax 参数 settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，回调函数的第1个参数 data 包含了响应的消息体数据。jQuery 会根据响应消息信息（比如 content-type 消息头）猜测对应的数据类型，从而进行相应的处理。比如下面的示例</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//登录成功后， 服务端返回的响应的 消息头 content-type : application/json 指明了 响应的消息体是json格式，jQuery 会自动反序列化为 js中对应的数据对象， 传递给 data参数。</span><br><span class="hljs-comment">//如果明确知道响应消息体数据格式， 应该设置 ajax 参数 settings 的 dataType 属性说明这个data的类型,比如 设置为 json，</span><br>$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 响应消息格式 预设为 json, </span><br>  <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>, <br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//dataType 属性值还可以是,</span><br>xml<br>返回 <span class="hljs-variable constant_">XML</span> 对象<br><br>html<br>返回 <span class="hljs-variable constant_">HTML</span> 字符串<br><br>text<br>返回消息体字符串<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>SESSION机制：采用session机制的系统设计，通常session号是认证成功后， 服务端是通过 HTTP的响应头 <code>Set-Cookie</code> 把产生的 sessionid 告诉客户端的。<code>Set-Cookie</code> 是设定服务端要存放在客户端的Cooked数据，这些数据，浏览器会自动保存。后续访问该网站的其它请求，浏览器会自动在HTTP的请求头 <code>Cookie</code> 中携带保存的所有cookie数据。所以，只要已经调用登录接口，获取了sessionid，后续的请求代码，不需要我们自己的代码里面设置。比如</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/customers?action=list_customer&amp;pagesize=5&amp;pagenum=1'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>, <br><br>  <span class="hljs-comment">// 响应消息格式 预设为 json, </span><br>  <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>, <br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//如果我们没有登录成功，就执行上面的代码，服务端就会要求认证了。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="Web请求过程剖析"><a href="#Web请求过程剖析" class="headerlink" title="Web请求过程剖析"></a>Web请求过程剖析</h2><ul>
<li><ul>
<li>服务器渲染：在服务器那边直接把数据和html整合在一起，统一返回给浏览器，在页面源代码中能看到数据。</li>
<li>客户端渲染：第一次请求只要一个html骨架。第二次请求拿到数据，进行数据展示，在页面源代码中，看不到的数据。</li>
</ul>
</li>
</ul>
<h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><ul>
<li><ul>
<li>分为两块：<ol>
<li>请求<ol>
<li>请求行：有请求方式、请求url地址、协议。</li>
<li>请求头：放一些服务器要使用的附加信息。</li>
<li>请求体：一般放一些请求参数。</li>
</ol>
</li>
<li>响应<ol>
<li>状态行：有协议、状态码（200成功，302和307临时转移至新url，404找不到该页面，500服务器内部错误，503服务器不可用，一般是被反爬）。</li>
<li>响应头：放一些客户端要使用的附加信息。</li>
<li>响应体：服务器返回的真正客户端要用到的内容（HTML、json）等。</li>
</ol>
</li>
</ol>
</li>
<li>请求头中最常见的一些重要内容（爬虫需要）<ol>
<li>User-Agent：请求载体的身份标识（用啥发送的请求）</li>
<li>Referer：防盗链（这次请求是从哪个页面来的?反爬会用到）</li>
<li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li>
</ol>
</li>
<li>响应头中一些重要内容<ol>
<li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li>
<li>各种神奇的莫名其妙的字符串（这个需要经验，一般都是token字样，防止各种攻击和反爬）</li>
</ol>
</li>
<li>请求方式<ol>
<li>GET：链接地址信息内面直接在？后面带上参数，多个参数用&amp;隔开。如果要将参数进行封装，可以放在一个字典中，通过请求的params参数进行传递。</li>
<li>POST：链接地址信息内面不带参数。参数传递有二种方式：一是表单参数，form-data，它是字典形式，使用requests.post(url,data=字典参数)发送请求；二是json参数，也是字典形式，使用requests.post(url,json=字典参数)发送请求。</li>
</ol>
</li>
<li>模拟登录的二种方式<ol>
<li>cookie+session鉴权机制<ol>
<li>cookie是由web服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户访问到服务器，都会带上该服务器的cookie信息。一般cookie都是有有效期的，只在浏览器上保存一段规定的时间，一旦超过规定的时间，该cookie就会被系统清除。</li>
<li>session将数据存储在服务器中，服务器会为每个用户创建一条session，用户访问服务器的时候需要拿着sessionid去表明自己的身份。</li>
<li>一般常见于项目没有做前后端分离，通过参数是否是表单形式或者第一次请求地址域名和第二登录请求发送的地址域名是一样的来判断分析。</li>
<li>返回的时候，在响应头的set-cookie字段中。</li>
</ol>
</li>
<li>基于Token的鉴权机制：当客户端使用用户和密码登录认证后，如果服器鉴权成功，就会生成token返回给客户端，客户端后续发送请求时需要携带token，服务器判断token有效性后才会返回数据。一般常见于前后端分离的项目（通过是否是json参数或者第一次请求时的地址域名和第二次登录请求的地址域名不一样来判断分析）。返回的时候，在响应体中。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="requests入门"><a href="#requests入门" class="headerlink" title="requests入门"></a>requests入门</h2><p>python系统自带有from url.request import urlopen模块，能实现网页请求，但使用第三方库requests模块使得网页请求更加简化，特别是在处理一些请求头上面特别简单。</p>
<p>用pip下载requests模块：pip install requests，实现urllib.request模块的功能，用requests模块发送请求，获取数据</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">"https://www.baidu.com"</span><br>headers = {<br>    <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"</span><br>}  <span class="hljs-comment"># 一般网站都有防爬机制，需要加上User-Agent键，伪装成浏览器发送请求。</span><br>resp = requests.get(url, headers=headers)<br>resp = requests.get(url)	<span class="hljs-comment"># 返回一个Response对象和响应码</span><br><span class="hljs-built_in">print</span>(resp)<br>resp.close()<br>运行结果：<br>&lt;Response [<span class="hljs-number">200</span>]&gt;<br><span class="hljs-comment"># resp作为Response的对象，有很多属性和方法，其中属性content获取网页的字节流，text获取网页的字符串。json方法返回json格式的数据并转换成python的一种类型的数据。</span><br><span class="hljs-comment"># json是一种轻量级的数据交换格式,可以用来传输数据。爬回来的数据使用json格式会使可读性更好。</span><br><span class="hljs-comment"># 爬完记得用close()方法关闭response对象,防止资源泄露,当再次爬取时也会出现报错异常现象。</span><br><span class="hljs-comment"># request.get(url,verify=False) 忽略SSL证书验证,防止报错，Flase表示去掉安全验证。</span><br><span class="hljs-comment"># 响应头中的Referrer Policy: 防止跨站请求伪造(Cross-Site Request Forgery,CSRF)攻击,也就是网页的防爬机制,这时可以考虑在请求头中加入浏览器的User-Agent字段。</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>构建请求url参数：url参数的格式，有个术语叫 <code>urlencoded</code> 格式。使用Requests发送HTTP请求，url里面的参数，通常可以直接写在url里面，但是有的时候，我们的url参数里面有些特殊字符，比如 参数的值就包含了 &amp; 这个符号，那么我们可以把这些参数放到一个字典里面，然后把字典对象传递给 Requests请求方法的 params 参数。</p>
</li>
<li><p>构建请求头消息：每个消息头也就是一种 键值对的格式存放数据，Requests发送这样的数据，只需要将这些键值对的数据填入一个字典。然后使用post或get方法的时候，指定参数 headers 的值为这个字典就可以了。</p>
</li>
<li><p>构建请求体消息：http 的 消息体就是一串字节，里面包含了一些信息。这些信息可能是文本，比如html网页作为消息体，也可能是视频、音频等信息。最常见的消息体格式当然是 表示网页内容的 HTML。Web API接口中，消息体基本都是文本，文本的格式主要是这3种： urlencoded ，json ， XML。注意：消息体采用什么格式，是由 开发人员设计的决定的。Requests库的post方法，参数data指明了，消息体中的数据是什么。如果传入的是字符串类型，Requests 会使用缺省编码 <code>latin-1</code> 编码为字节串放到http消息体中，发送出去。编程语言都有现成的库处理解析 XML、json 这样的数据格式，我们直接拿来使用，而自己定义的格式就难以表达这样复杂的数据格式，而且还要自己写代码在发送前进行格式转化，接收后进行格式解析，非常麻烦。urlencoded 格式消息体就是一种 键值对的格式存放数据，Requests发送这样的数据，当然可以直接把这种格式的字符串传入到data参数里面。json 格式消息体：json 格式 当前被 Web API 接口广泛采用。json 是一种表示数据的语法格式。 它和Python 表示数据的语法非常像。它的优点是：比xml更加简洁、清晰， 所以程序处理起来效率也更高。可以使用json库的dumps方法，构建一个json 格式的字符串，如下</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests,json<br><br>payload = {<br>    <span class="hljs-string">"Overall"</span>:<span class="hljs-string">"良好"</span>,<br>    <span class="hljs-string">"Progress"</span>:<span class="hljs-string">"30%"</span>,<br>    <span class="hljs-string">"Problems"</span>:[<br>        {<br>            <span class="hljs-string">"No"</span> : <span class="hljs-number">1</span>,<br>            <span class="hljs-string">"desc"</span>: <span class="hljs-string">"问题1...."</span><br>        },<br>        {<br>            <span class="hljs-string">"No"</span> : <span class="hljs-number">2</span>,<br>            <span class="hljs-string">"desc"</span>: <span class="hljs-string">"问题2...."</span><br>        },<br>    ]<br>}<br><br>r = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data=json.dumps(payload))<br><span class="hljs-comment"># 这里是将python数据类型对象转换成json字符串格式，叫序列化。</span><br><span class="hljs-comment"># 也可以将 数据对象 直接 传递给post方法的 json参数，如下</span><br>r = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, json=payload)<br><span class="hljs-comment"># 这里是由json参数实际上是由request模块调用了json类进行了json序列化处理。</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>检查http响应</p>
<ul>
<li><p>检查 HTTP 响应 的状态码，直接 通过 reponse对象的 <code>status_code</code> 属性获取</p>
</li>
<li><p>要检查 HTTP 响应 的消息头，直接 通过 reponse对象的 <code>headers</code> 属性获取，response.headers 对象的类型 是 继承自 Dict 字典 类型的一个 类。我们也可以像操作字典一样操作它，比如取出一个元素的值</p>
</li>
<li><p>检查响应消息体，要获取响应的消息体的文本内容，直接通过response对象 的 <code>text</code> 属性即可获取，那么，requests是 以什么编码格式 把HTTP响应消息体中的 字节串 解码 为 字符串的呢？requests 会根据响应消息头（比如 Content-Type）对编码格式做推测。但是有时候，服务端并不一定会在消息头中指定编码格式，这时， requests的推测可能有误，需要我们指定编码格式。可以通过这样的方式指定：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>response = requests.get(<span class="hljs-string">'http://mirrors.sohu.com/'</span>)<br>response.encoding=<span class="hljs-string">'utf8'</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></tbody></table></figure>

<p>如果我们要直接获取消息体中的字节串内容，可以使用 <code>content</code> 属性，比如：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>response = requests.get(<span class="hljs-string">'http://mirrors.sohu.com/'</span>)<br><span class="hljs-built_in">print</span>(response.content)<br><span class="hljs-comment"># 返回的内容既可以是字符串格式:text，也可以是字节串格式:content,两者之间通过encode和decode进行转换，decode默认以UTF-8的编码形式进行转码，也可以手动指定解码所采用的编码形式来进行解码。</span><br></code></pre></td></tr></tbody></table></figure>

<p>当然，如果可以直接对 获取的字节串 bytes对象进行解码，如：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">'utf8'</span>))<br></code></pre></td></tr></tbody></table></figure>

<p>API 响应的消息体格式，通常以json居多。为了 <code>方便处理 响应消息中json 格式的数据</code> ，我们通常应该把 json 格式的字符串 转化为 python 中的数据对象。怎么转化？ 前面我们学习过 json库，可以直接使用 json库里面的 <code>loads</code> 函数， 把 json 格式的字符串 转化为 数据对象</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests,json<br>response = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data={<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>})<br><br>obj = json.loads(response.content.decode(<span class="hljs-string">'utf8'</span>))<br><span class="hljs-built_in">print</span>(obj)<br><span class="hljs-comment"># 这种方式称为反序列化。</span><br></code></pre></td></tr></tbody></table></figure>

<hr>
<p>requests库为我们提供了更方便的方法，可以使用 Response对象的 json方法，如下：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">response = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data={<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>})<br>obj = response.json()<br><span class="hljs-built_in">print</span>(obj)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>HTTP 协议规定了， 网站服务端放HTTP响应中 消息头 <code>Set-Cookie</code> 里面的数据， 叫做 cookie 数据， 浏览器客户端 必须保存下来。而且后续访问该网站，必须在 HTTP的请求头 <code>Cookie</code> 中携带保存的所有cookie数据。</p>
<p>我们在Python代码中如果接收到服务端HTTP响应， 就能构建请求头，完全可以自己处理cookie。但requests库给我们提供一个 <code>Session</code> 类 。通过这个类，无需我们操心， requests库自动帮我们保存服务端返回的 cookie数据， HTTP请求自动在消息头中放入 cookie 数据。如下示例：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 打印HTTP响应消息的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printResponse</span>(<span class="hljs-params">response</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'\n\n-------- HTTP response * begin -------'</span>)<br>    <span class="hljs-built_in">print</span>(response.status_code)<br><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> response.headers.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'<span class="hljs-subst">{k}</span>: <span class="hljs-subst">{v}</span>'</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">''</span>)<br><br>    <span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">'utf8'</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'-------- HTTP response * end -------\n\n'</span>)<br><br><br><span class="hljs-comment"># 创建 Session 对象</span><br>s = requests.Session()<br><br><span class="hljs-comment"># 通过 Session 对象 发送请求</span><br>response = s.post(<span class="hljs-string">"http://127.0.0.1/api/mgr/signin"</span>,<br>       data={<br>           <span class="hljs-string">'username'</span>: <span class="hljs-string">'byhy'</span>,<br>           <span class="hljs-string">'password'</span>: <span class="hljs-string">'88888888'</span><br>       })<br><br>printResponse(response)<br><br><span class="hljs-comment"># 通过 Session 对象 发送请求</span><br>response = s.get(<span class="hljs-string">"http://127.0.0.1/api/mgr/customers"</span>,<br>      params={<br>          <span class="hljs-string">'action'</span>    :  <span class="hljs-string">'list_customer'</span>,<br>          <span class="hljs-string">'pagesize'</span>  :  <span class="hljs-number">10</span>,<br>          <span class="hljs-string">'pagenum'</span>   :  <span class="hljs-number">1</span>,<br>          <span class="hljs-string">'keywords'</span>  :  <span class="hljs-string">''</span>,<br>      })<br><br>printResponse(response)<br></code></pre></td></tr></tbody></table></figure>

<p>如果Session对象所有的请求都通过设置的代理进行，可以这样使用：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br>proxies = {<span class="hljs-string">'http'</span>: <span class="hljs-string">'http://127.0.0.1:8888'</span>}<br><br>s = requests.session()<br><br>s.proxies.update(proxies)<br><br>s.get(<span class="hljs-string">"http://www.example.com"</span>)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>三种解析方式：1、re解析；2、bs4解析、3、xpath解析。其中re解析最快，xpath现在最流行，bs4解析最方便，但性能最低。三种方式可以混用，完全以结果做导向，只要能拿到结果，用哪种方案并不重要。</p>
<ul>
<li><p>正则表达式：优点：速度快，效率高，准确性高。缺点：上手有点难度。</p>
</li>
<li><p>正则表达式的语法：使用元字符进行排列组合用来匹配字符串。</p>
</li>
<li><p>元字符：具有固定含义的特殊符号，常用元字符：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1</span>	.	匹配除换行符以外的任意字符<br><span class="hljs-number">2</span>	\w	匹配字母或数字或下划线<br><span class="hljs-number">3</span>	\s	匹配任意的空白符<br><span class="hljs-number">4.</span>	\d	匹配数字<br><span class="hljs-number">5.</span>	\n	匹配一个换行符<br><span class="hljs-number">6.</span>	\t	匹配一个制表符<br><span class="hljs-number">7.</span><br><span class="hljs-number">8.</span>	^	匹配字符串的开始<br><span class="hljs-number">9.</span>	$	匹配字符串的结束<br><span class="hljs-number">10.</span><br><span class="hljs-number">11.</span>	\W	匹配非字母或数字或下划线<br><span class="hljs-number">12.</span>	\S	匹配非空白符<br><span class="hljs-number">13.</span>	\D	匹配非数字<br><span class="hljs-number">14.</span>	a|b	匹配a或者b<br><span class="hljs-number">15.</span>	()	匹配括号内的表达式，也表示一个组<br><span class="hljs-number">16.</span>	[]	匹配字符组中的字符<br><span class="hljs-number">17.</span>	[^]	匹配除了字符组中字符的所有字符<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>量词，控制前面的元字符出现的次数</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span>	*	重复零次或更多次<br><span class="hljs-number">2.</span>	+	重复一次或更多次<br><span class="hljs-number">3.</span>	?	重复零次或一次<br><span class="hljs-number">4.</span>	{n}	重复n次<br><span class="hljs-number">5.</span>	{n,}	重复n次或更多次<br><span class="hljs-number">6.</span>	{n,m}	重复n到m次<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>贪婪配置和惰性匹配，这是爬虫用得最多的就是这个惰性匹配</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span>	.*	贪婪匹配<br><span class="hljs-number">2.</span>	.*?	惰性匹配<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>re模块，python内置的模块。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># findall，匹配字符串中所有符合正则的内容，返回的是列表。</span><br><span class="hljs-keyword">import</span> re<br>lst=re.findall(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)	<span class="hljs-comment"># 建议第一个参数前加上r</span><br><span class="hljs-built_in">print</span>(lst)<br>运行结果：<br>[<span class="hljs-string">'13574048'</span>, <span class="hljs-string">'668'</span>, <span class="hljs-string">'10086'</span>]<br><br><span class="hljs-comment"># finditer，匹配字符串中所有符合正则的内容，反回的是迭代器，从迭代器中拿到内容要.group()</span><br><span class="hljs-keyword">import</span> re<br>lst=re.finditer(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><span class="hljs-number">668</span><br><span class="hljs-number">10086</span><br><span class="hljs-comment"># 使用返回迭代器的效率要比使用列表高得多。</span><br><br><span class="hljs-comment"># 使用search，找到一个结果就返回，返回的是match对象，拿数据用.group()</span><br><span class="hljs-keyword">import</span> re<br>lst=re.search(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)<br><span class="hljs-built_in">print</span>(lst.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><br><span class="hljs-comment">#match,从头开始匹配，第一个不符合就会报错，找到第一个就会返回。</span><br><span class="hljs-keyword">import</span> re<br>lst=re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'13574048sina668，电话是10086'</span>)<br><span class="hljs-built_in">print</span>(lst.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><br><span class="hljs-comment"># 预加载正则表达式，方便多次调用。</span><br><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br>obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r"&lt;div class='.*?&gt;&lt;span id='.*?'&gt;.*?&lt;/span&gt;&lt;/div&gt;"</span>,re.S)<br>ret=obj.findall(s)<br><span class="hljs-built_in">print</span>(ret)<br>运行结果：<br>[<span class="hljs-string">"&lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;"</span>, <span class="hljs-string">"&lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;"</span>]<br><br><span class="hljs-comment"># (?P&lt;分组名字&gt;正则)	可以单独从正则匹配的内容中进一步提取内容。</span><br><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br>obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r"&lt;div class='.*?&gt;&lt;span id='(?P&lt;id&gt;.*?)'&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;"</span>,re.S)<br><span class="hljs-comment"># re.S中，S是一个标志符，让.能匹配换行符。使用?P&lt;id&gt;的目的是使迭代器循环调用时通过.group(分组名)输出结果。</span><br>ret=obj.findall(s)<br><span class="hljs-built_in">print</span>(ret)  <br>运行结果：<br>[(<span class="hljs-string">'1'</span>, <span class="hljs-string">'李继晓'</span>), (<span class="hljs-string">'2'</span>, <span class="hljs-string">'小李飞刀'</span>)]<br><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>bs4解析：通过标签和属性去定位页面上的内容。</p>
</li>
<li><p>用法：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># pip install bs4</span><br><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> requests<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br><span class="hljs-comment"># 1.将页面源代码交给Beautifulsoup进行处理，生成bs对象。</span><br>soup=BeautifulSoup(s,<span class="hljs-string">"html.parser"</span>)	<span class="hljs-comment"># 指定html解析器，明确指出将返回结果转换成html格式，不加这个参数也不会报错，但会出现警告，并将返回结果转换成html来处理。</span><br><span class="hljs-comment"># 2.从bs对象中查找数据,find_all(标签，属性=值)。</span><br>resule=soup.find_all(<span class="hljs-string">'div'</span>,class_=<span class="hljs-string">'jay'</span>)<br><span class="hljs-built_in">print</span>(resule)	<span class="hljs-comment"># 返回的是列表，但列表的内容格式是html格式，可继续使用fina_all(标签，属性=值)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(result[<span class="hljs-number">0</span>]))	<span class="hljs-comment"># 注意列表的元素类型为&lt;class 'bs4.element.Tag'&gt;</span><br>result1=result[<span class="hljs-number">0</span>].find_all(<span class="hljs-string">'span'</span>) <br><span class="hljs-built_in">print</span>(result1)<br>result2=result1[<span class="hljs-number">0</span>].text <span class="hljs-comment"># 通过text最后取标签的结果。</span><br>result3=result1[<span class="hljs-number">0</span>].get(<span class="hljs-string">"id"</span>) <span class="hljs-comment"># 通过get能取到标签内的指定属性的值</span><br><span class="hljs-built_in">print</span>(result2)<br><span class="hljs-built_in">print</span>(result3)<br>运行结果：<br>[&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"jay"</span>&gt;&lt;span <span class="hljs-built_in">id</span>=<span class="hljs-string">"1"</span>&gt;李继晓&lt;/span&gt;&lt;/div&gt;]<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'bs4.element.Tag'</span>&gt;<br>[&lt;span <span class="hljs-built_in">id</span>=<span class="hljs-string">"1"</span>&gt;李继晓&lt;/span&gt;]<br>李继晓<br><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>xpath：是在xml文档中搜索内容的一门语言</p>
</li>
<li><p>html是xml的一个子集，xpath将标签当作一个结点处理，标签内的标签称为子结点，标签外的标签称为父结点。</p>
</li>
<li><p>使用xpath需要安装lxml模块：pip install lxml</p>
</li>
<li><p>使用方法：</p>
<p>选取节点：使用路径表达式来选择XML文档中的节点或者节点集。这些路径表达式和我们在常规的电脑系统中看到的表达式非常相似</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nodename</td>
<td>选取此节点的所有子节点</td>
</tr>
<tr>
<td>/</td>
<td>从根节点选择</td>
</tr>
<tr>
<td>//</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td>
</tr>
<tr>
<td>.</td>
<td>选择当前节点</td>
</tr>
<tr>
<td>..</td>
<td>选择当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td>选择属性</td>
</tr>
</tbody></table>
<p>条件过滤：查找某个特定的的节点或包含某个指定的值的节点，被嵌在方括号中</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>/ul/li[1]</td>
<td>选择属于ul子元素的第一个li元素</td>
</tr>
<tr>
<td>/ul/li[last()]</td>
<td>选择属于ul子元素的最后一个li元素</td>
</tr>
<tr>
<td>/ul/li[last()-1]</td>
<td>选择属于ul子元素的倒数第二个li元素</td>
</tr>
<tr>
<td>/ul/li[position()&lt;3]</td>
<td>选取最前面的两个属于ul元素的子元素的li元素</td>
</tr>
<tr>
<td>//div[@attr]</td>
<td>选取所有拥有名为attr属性的div元素</td>
</tr>
<tr>
<td>//div[@attr=‘leng’]</td>
<td>选取所有div元素，且这些元素拥有值为leng的attr属性</td>
</tr>
</tbody></table>
<p>选择未知节点：通配符可用来选取未知的XML元素</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述/结果</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任何元素节点</td>
</tr>
<tr>
<td>@*</td>
<td>匹配任何属性节点</td>
</tr>
<tr>
<td>/div/*</td>
<td>选取div元素的所有子元素</td>
</tr>
<tr>
<td>//*</td>
<td>选取文档中的所有元素</td>
</tr>
<tr>
<td>html/node()/a/@*</td>
<td>选择html下面任意节点下的a节点的所有属性</td>
</tr>
<tr>
<td>//div[@*]</td>
<td>选取所有带有属性的div元素</td>
</tr>
<tr>
<td>//li[contains(@attr,100)]</td>
<td>选取属性为attr，并且值为100的所有元素。contains属于模糊匹配</td>
</tr>
<tr>
<td>//*[contains(text(),’当’)]</td>
<td>选择所有元素中文本中包含有“当”字符的元素</td>
</tr>
</tbody></table>
<p>获取数据：1、获取文本数据，选取节点后要获取节点中的文本内容，使用text()方法；2、获取属性值，@属性</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/div/ul/li/span/text()</td>
<td>获取span标签中的文本内容</td>
</tr>
<tr>
<td>/div//li/a/@herf</td>
<td>获取a标签中的herf属性</td>
</tr>
</tbody></table>
<p>以上就是xpath的语法内容，在运用到Python抓取时要先转换为XML，如下示例</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># from lxml import etree  导入etree模块，lxml库是专门用来解析XML文档的库</span><br><span class="hljs-comment"># tree=etree.XML()	创建etree对象</span><br><span class="hljs-comment"># tree.xpath()	调用xpath方法</span><br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>s=<span class="hljs-string">"""</span><br><span class="hljs-string">&lt;root&gt;</span><br><span class="hljs-string">    &lt;book&gt;</span><br><span class="hljs-string">        &lt;title&gt;Python&lt;/title&gt;</span><br><span class="hljs-string">        &lt;author&gt;Guido van Rossum&lt;/author&gt;</span><br><span class="hljs-string">        &lt;year&gt;1991&lt;/year&gt;</span><br><span class="hljs-string">    &lt;/book&gt;</span><br><span class="hljs-string">    &lt;book&gt;</span><br><span class="hljs-string">        &lt;title&gt;Java&lt;/title&gt;</span><br><span class="hljs-string">        &lt;author&gt;James Gosling&lt;/author&gt;</span><br><span class="hljs-string">        &lt;year&gt;</span><br><span class="hljs-string">        	&lt;a href="https://www.java.com"&gt;2000&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="https://www.oracle.com"&gt;2005&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="https://www.openjdk.java.net"&gt;2011&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="maodian"&gt;锚点&lt;/a&gt;</span><br><span class="hljs-string">            &lt;title&gt;Python&lt;/title&gt;</span><br><span class="hljs-string">        &lt;/year&gt;</span><br><span class="hljs-string">    &lt;/book&gt;</span><br><span class="hljs-string">&lt;/root&gt;</span><br><span class="hljs-string">"""</span><br>tree=etree.XML(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(tree))<br>result=tree.xpath(<span class="hljs-string">'/root'</span>)	<span class="hljs-comment"># /表示层级关系，第一个/是根节点，返回一个结点的迭代器</span><br>result1=tree.xpath(<span class="hljs-string">'/root/book/title/text()'</span>)	<span class="hljs-comment">#text()返回结点内容。</span><br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(result1)<br>result2=tree.xpath(<span class="hljs-string">"//title/text()"</span>)	<span class="hljs-comment"># //后代结点。</span><br><span class="hljs-built_in">print</span>(result2)<br>result3=tree.xpath(<span class="hljs-string">"/root/book/*/title/text()"</span>)	<span class="hljs-comment"># 任意的节点，通配符。</span><br><span class="hljs-built_in">print</span>(result3)<br>result4=tree.xpath(<span class="hljs-string">"/root/book/year/a[1]/text()"</span>)	<span class="hljs-comment"># 通过索引拿到第一个内容。</span><br><span class="hljs-built_in">print</span>(result4)<br>result5=tree.xpath(<span class="hljs-string">"/root/book/year/a[@href='maodian']/text()"</span>) <span class="hljs-comment"># 通过[@取属性=值]来取到内容</span><br><span class="hljs-built_in">print</span>(result5)<br>result6=tree.xpath(<span class="hljs-string">"/root/book/year/a[1]/@href"</span>)	<span class="hljs-comment"># 通过@属性，取到标签内的属性值。</span><br><span class="hljs-built_in">print</span>(result6)<br>输出结果：<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'lxml.etree._Element'</span>&gt;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'lxml.etree._Element'</span>&gt;<br>[&lt;Element root at <span class="hljs-number">0x1bf98c6a8c0</span>&gt;]<br>[<span class="hljs-string">'Python'</span>, <span class="hljs-string">'Java'</span>]<br>[<span class="hljs-string">'Python'</span>, <span class="hljs-string">'Java'</span>, <span class="hljs-string">'Python'</span>]<br>[<span class="hljs-string">'Python'</span>]<br>[<span class="hljs-string">'2000'</span>]<br>[<span class="hljs-string">'锚点'</span>]<br>[<span class="hljs-string">'https://www.java.com'</span>]<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="requests进阶"><a href="#requests进阶" class="headerlink" title="requests进阶"></a>requests进阶</h2><ul>
<li><p>当网站需要用户名和密码进行登录时：</p>
</li>
<li><p>登录后会得到cookie，当再次请求网站其它url时，就会带着cookie去请求，不需要再次输入登录名有密码，这时候写代码就得把登录和cookie这两操作连起来，这时候就可以使用session。</p>
</li>
<li><p>session意思是会话，可以认为是一连串的请求，在这个过程中cookie不会丢失。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br>session=requests.session()	<span class="hljs-comment">#可获取session对象</span><br>data={<br>    <span class="hljs-string">"loginName"</span>:<span class="hljs-string">"13574048668"</span>,<br>    <span class="hljs-string">"passwrod"</span>:<span class="hljs-string">"741209"</span><br>}<br><span class="hljs-comment"># 1.登录</span><br>url=<span class="hljs-string">"http://zhcxapp.hnrcc.bank/hnhccp/"</span><br>resp=session.post(url,data=data)	<span class="hljs-comment"># 通过session对象进行数据提交。</span><br><span class="hljs-built_in">print</span>(resp.text)	<span class="hljs-comment"># 显示返回数据</span><br><span class="hljs-built_in">print</span>(resp.cookies)	<span class="hljs-comment"># 显示cokkies内容</span><br><span class="hljs-comment"># 2.拿登录进去后的其它url链接数据</span><br><span class="hljs-comment"># 刚才哪个session中是有cookie的，不要使用requests.get()请求，否则拿不到数据。</span><br>resp1=session.get(<span class="hljs-string">"http://zhcxapp.hnrcc.bank/hnhccp/file?id=123"</span>)<br><span class="hljs-built_in">print</span>(resp1.json())	<span class="hljs-comment"># 这里返回的数据一般是json格式的，不使用test而使用json会显示得更友好些。</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>代理是通过第三方的一个机器去发送请求，用法：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs py">  <span class="hljs-keyword">import</span> requests<br>  <span class="hljs-comment"># 从https://www.zdaye.com/free/站点找哪些透明或者普匿的ip地址:端口，放在一个字典中。</span><br>  proxies={<br>    <span class="hljs-string">'http'</span>: <span class="hljs-string">'111.1.61.47:3128'</span>,<br>    <span class="hljs-string">'https'</span>: <span class="hljs-string">'119.3.113.151:9094'</span><br>  }<br>  url=<span class="hljs-string">"http://www.baidu.com"</span><br>  resp=requests.get(url,proxies=proxies)	<span class="hljs-comment"># 调用代理参数</span><br>  <span class="hljs-built_in">print</span>(resp)<br>  运行结果：<br>&lt;Response [<span class="hljs-number">200</span>]&gt;<br><br><span class="hljs-comment">## 多线程</span><br><br>+ 操作系统每次运行一个程序的时侯，都会给这个程序准备一块内存，存放程序执行过程中的变量，这个内存区域可以称为进程。在进程内面有一个或多个线程，来帮助我们工作。所在进程与线程的关系是：<br><br>+ 进程是资源单位，线程是执行单位。程序运行的时候必须创建线程去执行。好比一个公司，公司是资源单位，而公司运转的话必须要有员工，员工就是线程，公司的一个项目需要多个人去完成的时候，多个人就是多线程。如果线程没有了，进程也就没用了。<br><br>+ 每一个进程至少需要一个线程，CPU在工作的时候，调度的是一个线程。启动每一个程序，默认都会有一个主线程。<br><br>+ 实现多线程的二种方法：<br><br>  ```py<br>  <span class="hljs-number">1.</span> 第一种方法，创建线程实例对象方式运行：<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread	<span class="hljs-comment"># 线程类</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>():<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f"my_func"</span>,i)<br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t1 = Thread(target=my_func) <span class="hljs-comment"># 创建一个线程对象，并给线程安排任务</span><br>      t1.start()	<span class="hljs-comment"># 开始执行该线程，实质是给多线程对象加了一个可以开始工作状态，具体执行时间由CPU决定</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">f"main!"</span>,i)<br>  运行结果描述：主线程运行到t.start()后，就会有二条线程同时在运行，my_func函数和主入口函数main交互输出结果。<br>  <br>  <span class="hljs-number">2.</span>	自己定义一个类，继承线程类，重写线程类的run()方法：<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):	<span class="hljs-comment"># 当线程被执行的时候，被执行的就是run()</span><br>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>              <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程"</span>,i)<br>  <br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t=MyThread()<br>      <span class="hljs-comment"># t.run()	这里调用的是函数的run()方法，实际运行时还是单线程</span><br>      t.start()	<span class="hljs-comment"># 这样调用同上面一样，是给多线程添加了可以开始工作的状态，实现了多线程运行</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主线程!"</span>,i)<br>          <br>  <span class="hljs-comment"># 注意：线程传的参数必须是元组</span><br>  <span class="hljs-number">1.</span>创建实例对象方法<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread	<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">name</span>):<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f"my_func"</span>,i,name)<br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t1 = Thread(target=my_func,args=(<span class="hljs-string">"李继晓"</span>,)) <span class="hljs-comment"># 参数是元组，只有一个参数时要用,区分</span><br>      t1.start()	<br>      t1 = Thread(target=my_func,args=(<span class="hljs-string">"小李飞刀"</span>,)) <br>      t1.start()<br>  <span class="hljs-number">2.</span>定义一个类，继续父类方法<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):	<span class="hljs-comment"># 在构造函数中传递参数</span><br>          <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 需要调用父类 Thread 的初始化方法，不调用的话某些情况下会出现问题</span><br>          <span class="hljs-variable language_">self</span>.name = name<br>  <br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>              <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程 <span class="hljs-subst">{self.name}</span>"</span>, i)<br>  <br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t = MyThread(<span class="hljs-string">"李继晓"</span>)<br>      t.start()<br>      t1 = MyThread(<span class="hljs-string">"小李飞刀"</span>)<br>      t1.start()<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul>
<li><p>相对于线程，多进程使用较少，因为开辟进程所消耗的内存资源要比线程大得多。</p>
</li>
<li><p>创建方法与创建子线程的二种方法相似:</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span> 第一种方法，创建进程实例对象方式运行：<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子进程"</span>,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    p=Process(target=my_func)<br>    p.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主进程!"</span>,i)<br>        <br><span class="hljs-number">2.</span>	自己定义一个类，继承线程类，重写线程类的run()方法：<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcess</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):	<span class="hljs-comment"># 当线程被执行的时候，被执行的就是run()</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子进程"</span>,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    p=MyThread()<br>    <span class="hljs-comment"># p.run()	这里调用的是函数的run()方法，实际运行时还是单进程</span><br>    p.start()	<span class="hljs-comment"># 这样调用同上面一样，是给多进程添加了可以开始工作的状态，实现了多进程运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主进程!"</span>,i)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="线程池和进程池"><a href="#线程池和进程池" class="headerlink" title="线程池和进程池"></a>线程池和进程池</h2><ul>
<li><p>线程池：一次性开辟一些线程，我们用户直接给线程池子提交任务，线程任务的调度交给线程池来完成。</p>
</li>
<li><p>方法：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor <span class="hljs-comment">#创建线程池</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor <span class="hljs-comment">#创建进程池</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(name,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 创建线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">50</span>) <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-comment"># 向线程池提交任务</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):	<span class="hljs-comment"># 制定任务完成的次数</span><br>            executor.submit(fun, <span class="hljs-string">f"在运行线程<span class="hljs-subst">{i}</span>"</span>)<br>            <span class="hljs-comment"># 等待线程池中的任务全部执行完毕，才继续执行（守护）</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"线程池执行完毕"</span>)<br><span class="hljs-comment"># 该段代码会运行100个线程对象（任务的次数），每个线程都运行fun函数，统一交给线程池来调度运行，而线程池由50个线程来分配运行，一直到运行完成后才会打印出执行完毕的结果。</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li><p>一般情况下，sleep(3)方法、input()方法、网络请求返回数据之前、程序处于IO操作的时候，线程会处于阻塞状态，阻塞状态下，CPU是不为我工作的。为解决这种问题，引入了协程。</p>
</li>
<li><p>协程：当程序遇见了阻塞操作的时候，可以选择性地切换到其它任务上，让CPU继续为我工作，实现充分地将CPU绑定在我的程序上面。</p>
</li>
<li><p>在微观上，协程是一个任务一个任务的进行切换，切换条件就是会产生阻塞的操作；在宏观上，我们看到的其实是多个任务一起在执行，所以协程就是多任务异步操作。都是在单线程条件下发生。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> asyncio	<span class="hljs-comment"># 导入异步模块</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():	<span class="hljs-comment"># 加上async后，这个函数变成了异步函数，需要用异步模块的run()方法调用</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world!"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    asyncio.run(test()) <span class="hljs-comment"># run()运行事件循环，test()将在事件循环中并发执行</span><br>    --------------------------------------------------------------------------<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world1!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world2!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world3!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    tasks = [asyncio.create_task(test1()), asyncio.create_task(test2()), asyncio.create_task(test3())]<br>    <span class="hljs-keyword">await</span> asyncio.wait(tasks)	<span class="hljs-comment"># 等待所有任务完成</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># asyncio.create_task() 函数会将协程包装成任务对象，并安排它们在事件循环中并发执行。</span><br>    asyncio.run(main()) <span class="hljs-comment"># asyncio.run() 会运行事件循环，直到 asyncio.wait(main()) 完成</span><br>运行结果：<br>Hello, world1!<br>Hello, world2!<br>Hello, world3!<br>[Done] exited <span class="hljs-keyword">with</span> code=<span class="hljs-number">0</span> <span class="hljs-keyword">in</span> <span class="hljs-number">4.334</span> seconds<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>await的含义：是Python异步编程中的核心关键字，主要含义和作用如下：</p>
<ol>
<li><p><strong>执行权让出机制</strong></p>
<ol>
<li><p>表示”等待这个异步操作完成”</p>
</li>
<li><p>会让出当前协程的执行权，使事件循环可以执行其他任务</p>
</li>
<li><p>不会阻塞整个线程，仅暂停当前协程</p>
</li>
</ol>
</li>
<li><p>使用限制</p>
<ol>
<li><p>必须用在<code>async def</code>定义的异步函数内面使用</p>
</li>
<li><p>后面必须跟一个”可等待对象”（Awaitable），如：</p>
<ol>
<li>协程（coroutine）</li>
<li>任务（Task）</li>
<li>Future对象</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>典型应用场景</strong></p>
<ol>
<li>网络请求（HTTP/TCP）</li>
<li>文件IO操作</li>
<li>数据库查询</li>
<li>睡眠延迟（<code>await asyncio.sleep(1)</code>）</li>
</ol>
</li>
<li><p><strong>注意事项</strong></p>
<ol>
<li>忘记写<code>await</code>会导致协程不执行（常见错误）</li>
<li>在错误位置使用会报错：<code>SyntaxError: 'await' outside async function</code></li>
<li>合理使用可以大幅提升I/O密集型程序的并发性能</li>
</ol>
</li>
</ol>
</li>
<li><p>异步http请求aiohttp模块</p>
</li>
<li><ul>
<li><p>requests.get()是同步的代码，异步操作要改成aiohttp。安装方法：pip install aiohttp。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_webpage</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:	<span class="hljs-comment"># 相当于是同步的requests，前面加async是语法规定</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(session))	<span class="hljs-comment"># 返回的是异步对象</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">'http://www.baidu.com/'</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response))	<span class="hljs-comment"># 返回的是异步的对象的结果</span><br>            <span class="hljs-comment"># with open('test.txt', 'w', encoding='utf-8') as f:</span><br>            <span class="hljs-comment">#     f.write(await response.text())  注意异步是text()，同步是text,细微差别，写取内容是异步的，要加上await挂起。</span><br>            运行结果：<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'aiohttp.client.ClientSession'</span>&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'aiohttp.client_reqrep.ClientResponse'</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>在链接非常多的情况下，多任务异步比同步下载要快得多，实践过程中，抓取4000多个小说的链接内容，同步花了26分钟左右，而同步仅用时56秒就完成了。</p>
</li>
</ul>
<h2 id="m3u8解析"><a href="#m3u8解析" class="headerlink" title="m3u8解析"></a>m3u8解析</h2><ul>
<li>m3u8是一个文本文件，本身并不是媒体文件，里面是以<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=441131229&amp;content_type=Answer&amp;match_order=1&amp;q=UTF-8&amp;zhida_source=entity">UTF-8</a>格式记录的音频视频资源，以及这些资源的播放地址。m3u8相当于视频音频资源的种子文件。</li>
<li>M3U8 文件是一个UTF-8编码的文本文件，所以用任何文本工具都能打开，但是如果用文本打开，你会发现里面记录的都是视频或者音频资源的访问路径。基于M3U8文件格式播放，你需要专门支持流媒体播放的播放器。可能有人发现.M3U文件也是这样的，是的，.M3U和 .M3U8文件的唯一区别就是一个是UTF8编码过的。</li>
<li>视频播放过程：现在的视频网站采用的是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B5%81%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&amp;zhida_source=entity">流媒体传输协议</a>，就是将一段视频切成无数个小段，这几个小段就是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=ts&amp;zhida_source=entity">ts</a>格式的视频文件，一段一段的网站上播放。一个视频播放的全过程如下：<ol>
<li>服务器采集编码传输视频到切片器</li>
<li>切片器对视频创建**<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6&amp;zhida_source=entity">索引文件</a>，<strong>并且</strong>切割<strong>成</strong>n个ts文件**</li>
<li>这2个文件传输到http服务器上</li>
<li>网站/客户端根据<strong>索引文件</strong>查找http服务器上的<strong>ts文件</strong>，连续播放这n个ts文件，就可以了。</li>
</ol>
</li>
<li>索引文件非常重要，索引文件里面存储着ts文件的网络url链接，网站需要拿到索引文件，去按照url链接下载在http服务器中的ts文件。</li>
<li>索引文件就是m3u8文件。现在大部分视频网站传输都是采用这种方法，所以，也就是说，如果你在观看网页视频的时候，能够弄到加载该视频的m3u8文件，那么再配合一些工具，就能下载该视频了。</li>
<li>爬虫下载过程：<ol>
<li>拿到页面源代码</li>
<li>从源代码中提取到m3u8的url</li>
<li>下载m3u8</li>
<li>读取m3u8，获取ts下载链接，下载视频</li>
<li>合并视频</li>
</ol>
</li>
</ul>
<h2 id="初始化搜狗浏览器"><a href="#初始化搜狗浏览器" class="headerlink" title="初始化搜狗浏览器"></a>初始化搜狗浏览器</h2><ul>
<li>搜狗浏览器使用的是chromed内核，确定搜狗使用的是哪种版本后去下载对应版本的webdriver驱动，然后使用下面的代码：</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service<br><br><span class="hljs-comment"># 设置搜狗浏览器的路径</span><br>sogou_browser_path = <span class="hljs-string">r"D:\SogouExplorer\SogouExplorer.exe"</span><br>options = webdriver.ChromeOptions()<br>options.binary_location = sogou_browser_path<br><span class="hljs-comment"># 初始化浏览器驱动</span><br>driver = webdriver.Chrome(options=options,service=Service(<span class="hljs-string">r"D:\vscode\chromedriver.exe"</span>))<br><span class="hljs-comment"># 调用WebDriver 对象的get方法 可以让浏览器打开指定网址</span><br>driver.get(<span class="hljs-string">'http://zhcxapp.hnrcc.bank/hnhccp/'</span>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>浏览器内核版本查看地址：<a target="_blank" rel="noopener" href="https://liulanmi.com/labs/core.html">https://liulanmi.com/labs/core.html</a></p>
</li>
<li><p>谷歌浏览器驱动版本下载地址：</p>
</li>
<li><ul>
<li>老版本地址：<a target="_blank" rel="noopener" href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a></li>
</ul>
</li>
<li><ul>
<li>新版本地址：<a target="_blank" rel="noopener" href="https://registry.npmmirror.com/binary.html?path=chrome-for-testing/">https://registry.npmmirror.com/binary.html?path=chrome-for-testing/</a></li>
</ul>
</li>
<li><ul>
<li>统一浏览器内核版本：108.0.5359.95</li>
</ul>
</li>
<li><ul>
<li>人行Pisa能正常运行的内核版本：80.0.3987.87</li>
</ul>
</li>
<li><ul>
<li>Edge浏览器目前内核版本：134.0.0.0</li>
</ul>
</li>
<li><ul>
<li>谷歌浏览器目前内核版本：135.0.0.0</li>
</ul>
</li>
</ul>
<h2 id="selenium自动化"><a href="#selenium自动化" class="headerlink" title="selenium自动化"></a>selenium自动化</h2><ul>
<li>关于验证码：<ol>
<li>直接把浏览器内面的cookie拿出来直接用</li>
<li>手动编写验证码识别的功能（深度学习）</li>
<li>第三方打码平台（收费），超级鹰、图鉴</li>
</ol>
</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 学习参考资料</span><br><span class="hljs-number">1.</span> 下载谷歌浏览器驱动<br>查看谷歌浏览器的版本 设置--&gt;帮助--&gt;关于Chrome<br><br>进入网站下载 https://npmmirror.com 选择 Selenium 镜像: https://npmmirror.com/mirrors/selenium/ 对应我们浏览器的版本下载Selenium版本<br>新建python工程 将下载解压后的exe文件拖入根目录下<br>案例 百度查询⬇<br><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>​<br><span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br>​<br>driver = webdriver.Chrome(<span class="hljs-string">"./chromedriver.exe"</span>)<br><span class="hljs-comment"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>html = driver.page_source  获取整个页面源代码数据<br>​<br>kw = driver.find_element(By.ID,<span class="hljs-string">"kw"</span>)<br>kw.send_keys(<span class="hljs-string">"丢丢"</span>)<br>​<br><span class="hljs-comment"># driver.find_element(By.CSS_SELECTOR,"#su").click()</span><br>su = driver.find_element(By.ID,<span class="hljs-string">"su"</span>).click()<br>su.click()<br><br><span class="hljs-comment"># driver对象的相关属性：</span><br><span class="hljs-number">1.</span>current_url：当前url地址<br><span class="hljs-number">2.</span>title：页面标题<br><span class="hljs-number">3.</span>page_source：页面html代码（渲染以后的）<br><span class="hljs-number">4.</span>window_handler：获取浏览器上所有的窗口句柄<br><span class="hljs-number">5.</span>current_window_handler：获取当前窗口句柄<br><span class="hljs-comment">#一.元素定位</span><br><span class="hljs-number">1.</span> 获取单个元素<br>driver.find_element(By.ID，<span class="hljs-string">"inputorigina”）</span><br><span class="hljs-string">driver.find_element(By.CSS_SELECTOR，"</span><span class="hljs-comment">#inputoriginal"）</span><br>driver.find_element(By.TAG_NAME，<span class="hljs-string">"div"</span>）<br>driver.find_element（By.NAME，<span class="hljs-string">"username"</span>)<br>driver.find_element(By.LINK_TEXT,“下一页”）<br>driver.find_element(By.XPATH,<span class="hljs-string">"//*[@id='kw']"</span>)  <span class="hljs-comment">#会以上一种就可以了，现在主流是xpath定位               </span><br><span class="hljs-number">2.</span> 如果找不到相应的元素会报错<br>selenium.common.exceptions.NosuchElementException: Message:no such element:Unable to 7ocate element:XX<br><span class="hljs-number">3.</span> 获取多个元素<br>driver.find_elements(By.ID，<span class="hljs-string">"inputoriginal”）</span><br><span class="hljs-string">driver.findelements(By.CSS_SELECTOR，“inputoriginal”）</span><br><span class="hljs-string">driver.find_elements(By.TAG_NAME,“div"</span>)<br>driver.findelements(By.NAME，“username”)<br>driver.find_elements(By.LINK_TEXT，<span class="hljs-string">"下一页”）</span><br><span class="hljs-string">4. 内容获取与操作</span><br><span class="hljs-string">    1. size 返回元素大小</span><br><span class="hljs-string">    2. text 获取元素的文本 &lt;div&gt;hello&lt;/div&gt;</span><br><span class="hljs-string">    3. title 获取页面的title</span><br><span class="hljs-string">    4. current_url 获取当前页面URL</span><br><span class="hljs-string">    5. get_attribute() 获取属性值&lt;a href="</span>www.baidu.com<span class="hljs-string">"&gt;&lt;/a&gt;</span><br><span class="hljs-string">    6. is_display() 判断元素是否可见</span><br><span class="hljs-string">    7. is_enabled() 判断元素是否可用</span><br><span class="hljs-string">    8. driver.page_source  获取整个页面数据</span><br><span class="hljs-string">    9. tagname 获取标签名</span><br><span class="hljs-string">	10. parent 获取父级标签   </span><br><span class="hljs-string">	11. click() 点击元素</span><br><span class="hljs-string">	12. clear() 清空表单</span><br><span class="hljs-string">	13. send_keys() 输入内容</span><br><span class="hljs-string">	# 示例</span><br><span class="hljs-string">		   from datetime import time</span><br><span class="hljs-string">            from selenium import webdriver</span><br><span class="hljs-string">            from selenium.webdriver.common.by import By</span><br><span class="hljs-string">            driver = webdriver.Chrome()</span><br><span class="hljs-string">            driver.get('http://www.baidu.com')         </span><br><span class="hljs-string">            time.sleep(10)</span><br><span class="hljs-string">            li_list=driver.find_elements(By.XPATH,'//ul[@class="</span>replylist<span class="hljs-string">"]/li')  </span><br><span class="hljs-string">            for item in li_list</span><br><span class="hljs-string">                 title=item.find_element(By.XPATH,'./div/[@class="</span>title<span class="hljs-string">"]/h1').text #通过xpath方式							找到的元素对象，可以继续使用xpath语法在元素中继续搜索目标，最后显示出文本。</span><br><span class="hljs-string">             driver.quit()        </span><br><span class="hljs-string">5. 窗口操作</span><br><span class="hljs-string">    1. maximize_window() 窗口最大化</span><br><span class="hljs-string">    2. set_window_size(100,100) 浏览器大小 设置浏览器的宽高(像素点)</span><br><span class="hljs-string">    3. set_window_position(300,200) 浏览器位置 设置浏览器位置</span><br><span class="hljs-string">    4. back() 后退</span><br><span class="hljs-string">    5. forward() 前进</span><br><span class="hljs-string">    6. refresh() 刷新</span><br><span class="hljs-string">    7. close() 关闭浏览器按钮(关闭单个窗口)</span><br><span class="hljs-string">    8. quit() 关闭webDriver启动的窗口</span><br><span class="hljs-string">6. 访问有道翻译网站，输入单词，并获取翻译后的内容</span><br><span class="hljs-string">#encoding:utf-8</span><br><span class="hljs-string">from datetime import time</span><br><span class="hljs-string">​</span><br><span class="hljs-string">from selenium import webdriver</span><br><span class="hljs-string"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-string">from selenium.webdriver.common.by import By</span><br><span class="hljs-string">​</span><br><span class="hljs-string">driver = webdriver.Chrome("</span>./chromedriver.exe<span class="hljs-string">")</span><br><span class="hljs-string"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br><span class="hljs-string">driver.get("</span>https://fanyi.youdao.com/<span class="hljs-string">")</span><br><span class="hljs-string">time.sleep(4)</span><br><span class="hljs-string"># 获取输入框</span><br><span class="hljs-string">input = driver.find_element(By.ID,"</span>inputOriginal<span class="hljs-string">")</span><br><span class="hljs-string"># 输入内容</span><br><span class="hljs-string">input.send_keys("</span>hello<span class="hljs-string">")</span><br><span class="hljs-string"># 获取翻译按钮</span><br><span class="hljs-string">tbtn = driver.find_element(By.ID,"</span>transMachine<span class="hljs-string">")</span><br><span class="hljs-string"># 先获取遮挡的广告条 点击关闭按钮</span><br><span class="hljs-string">close_btn = driver.find_element(By.CSS_SELECTOR,"</span>.guide-con .guide-close<span class="hljs-string">")</span><br><span class="hljs-string">close_btn.click()</span><br><span class="hljs-string"># 点击翻译</span><br><span class="hljs-string">tbtn.click()</span><br><span class="hljs-string"># 获取翻译后的内容</span><br><span class="hljs-string">transTarget = driver.find_element(By.ID,"</span>transTarget<span class="hljs-string">")</span><br><span class="hljs-string">print(transTarget.text)</span><br><span class="hljs-string">7. 爬当当网书籍的数据</span><br><span class="hljs-string">#encoding:utf-8</span><br><span class="hljs-string">from datetime import time</span><br><span class="hljs-string">​</span><br><span class="hljs-string">from selenium import webdriver</span><br><span class="hljs-string"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-string">from selenium.webdriver.common.by import By</span><br><span class="hljs-string">​</span><br><span class="hljs-string">driver = webdriver.Chrome("</span>./chromedriver.exe<span class="hljs-string">")</span><br><span class="hljs-string">driver.implicitly_wait(30)  # 隐式等待30秒，针对webdriver元素对象的所有查询，全局有效。</span><br><span class="hljs-string"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br><span class="hljs-string">driver.get("</span>https://www.dangdang.com/<span class="hljs-string">")</span><br><span class="hljs-string">driver.maximize_window()</span><br><span class="hljs-string"># 获取输入框</span><br><span class="hljs-string">key = driver.find_element(By.ID,"</span>key_S<span class="hljs-string">")</span><br><span class="hljs-string">key.send_keys("</span>科幻<span class="hljs-string">")</span><br><span class="hljs-string"># 获取搜索框 点击搜索</span><br><span class="hljs-string">search = driver.find_element(By.CSS_SELECTOR,"</span><span class="hljs-comment">#form_search_new .button")</span><br>search.click()<br><span class="hljs-comment"># 获取商品标题及价格</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>  shoplist = driver.find_elements(By.CSS_SELECTOR,<span class="hljs-string">".shoplist li"</span>)<br>  <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> shoplist:<br>    <span class="hljs-built_in">print</span>(li.find_element(By.CSS_SELECTOR,<span class="hljs-string">"a"</span>).get_attribute(<span class="hljs-string">"title"</span>))<br>    <span class="hljs-built_in">print</span>(li.find_element(By.CSS_SELECTOR,<span class="hljs-string">".search_now_price"</span>).text)<br>​<br>  <span class="hljs-comment"># 获取下一页的按钮</span><br>  <span class="hljs-built_in">next</span> = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"下一页"</span>)<br>  <span class="hljs-built_in">next</span>.click()<br><span class="hljs-number">8.</span> 显式等待：显式等待某些情况下找不到时使用<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverwait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-comment">#程序每0.5秒检查，是否满足：标题包含“百度一下”这个条件，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常</span><br>WebDriverwait（driver，<span class="hljs-number">15</span>).until（Ec.title_contains（“百度一下”）<br><span class="hljs-comment">#程序每0.5秒检查，是否满足：某定位的元素出现，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常</span><br>WebDriverwait(driver，<span class="hljs-number">15</span>）.until（Ec.visibility_of_element_located(By.CSS_SELECTOR，“XX”））<br><span class="hljs-number">9.</span> 隐式等待<br>implicitly_wait(time_to_wait)<br>设置时间单位为秒 例如<span class="hljs-number">30</span>秒 implicitly_wait(<span class="hljs-number">30</span>) 意思是超过<span class="hljs-number">30</span>秒没有定位到一个元素 程序就回抛出异常,期间会一直轮询查找定位元素<br><br>二. 鼠标及键盘操作:使用ActionChains类，导入：<span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-number">1.</span> 鼠标操作<br>    <span class="hljs-number">1.</span> context_click() 右击<br>    <span class="hljs-number">2.</span> double_click() 双击<br>    <span class="hljs-number">3.</span> drag_and_drop() 拖动，在一个位置按下鼠标，到另一个位置释放<br>    <span class="hljs-number">4.</span> move_to_element() 悬停，鼠标移动到某个节点<br>    <span class="hljs-number">5.</span> perform()    执行动作<br>	<span class="hljs-number">6.</span>click()  鼠标左击    <br>	<span class="hljs-number">7.</span>click_and_hold	鼠标左键按下鼠标                                                               <span class="hljs-number">8.</span>move_by_offse		鼠标相对当前位置进行移动<br>	<span class="hljs-number">9.</span>release()		释放鼠标<br>                                                               driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>more = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"更多"</span>)<br><span class="hljs-comment"># 将鼠标移动到更多按钮</span><br>ActionChains(driver).move_to_element(more).perform()<br>案例 打开百度鼠标移动到更多位置<br><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br>driver = webdriver.Chrome(<span class="hljs-string">"./chromedriver.exe"</span>)<br><span class="hljs-comment"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br>driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>more = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"更多"</span>)<br><span class="hljs-comment"># 将鼠标移动到更多按钮</span><br>ActionChains(driver).move_to_element(more).perform()<br><span class="hljs-number">2.</span> 键盘操作<br>    <span class="hljs-number">1.</span> send_keys（Keys,BACK_SPACE）删除键（Backspace）<br>    <span class="hljs-number">2.</span> send_keys（Keys.SPACE）空格键（Space）<br>    <span class="hljs-number">3.</span> send_keys（Keys.TAB）制表键（Tab）<br>    <span class="hljs-number">4.</span> send_keys（Keys·ESCAPE）回退键（ESC）<br>    <span class="hljs-number">5.</span> send_keys（Keys·ENTER）回车键（Enter）<br>    <span class="hljs-number">6.</span> send_keys（Keys.CONTROL，<span class="hljs-string">'a'</span>）全选（Ctrl+A）<br>    <span class="hljs-number">7.</span> send_keys（Keys.CONTROL，<span class="hljs-string">'c'</span>）复制（Ctr1+C）<br><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<br>driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>element = driver.find_element(By.ID,<span class="hljs-string">"kw"</span>)<br><span class="hljs-comment">#输入用户名</span><br>element.send_keys(<span class="hljs-string">"admin1"</span>)<br><span class="hljs-comment">#删除1</span><br>element.send_keys(Keys.BACK_SPACE)<br><span class="hljs-comment">#全选</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'a'</span>)<br><span class="hljs-comment">#复制</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'c'</span>)<br><span class="hljs-comment">#粘贴</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'v'</span>)<br>                                                                <br>三. 窗口滚动条<br>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载<br><span class="hljs-comment">#1.设置]avascritp脚本控制滚动条，（0:左边距；1000：上边距；单位像素）</span><br>js=<span class="hljs-string">"window.scro11To(0,1000)"</span><br>js=<span class="hljs-string">"window.scro11By(0,1000)"</span>    <span class="hljs-comment"># 向下滚动1000像素                                         </span><br>driver.execute_script(js）	<span class="hljs-comment"># WebDriver调用js脚本方法</span><br>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>		time.sleep(random.random()) <span class="hljs-comment"># 等待0-1秒</span><br>		js=<span class="hljs-string">"window.scro11By(0,{})"</span>.<span class="hljs-built_in">format</span>(random.randint(<span class="hljs-number">100</span>,<span class="hljs-number">300</span>))  <span class="hljs-comment">#向下滚动100到300像素                 	  driver.execute_script(js)</span><br><span class="hljs-comment">#2. 使用selenium的滚动元素可见属性,定位到 【查看更多】 的元素</span><br>	ele=driver.find_element(By.PATH,<span class="hljs-string">'//*[@class="mostlist"]'</span>) <br>	time.sleep(<span class="hljs-number">2</span>)                      <br>	res=ele.location_once_scrolled_into_view                      <br>    <span class="hljs-built_in">print</span>(res)	<span class="hljs-comment"># 查看滚动之后的座标</span><br>	ele.click()	<span class="hljs-comment"># 点击滚动按钮                      </span><br>四. 窗口截图<br>自动化脚本是由程序去执行的，因此有时候打印的错误信息并不是十分明确。如果在执行出错的时候对当前窗口截图保存，那么通过图片就可以非常直观地看到出错的原因<br><span class="hljs-comment">#截取当前窗口</span><br>driver.get_screenshot_as_file(<span class="hljs-string">"./demo.png"</span>)<br>                      <br>五. 数据存储<br>将数据写入CSV文件<br><span class="hljs-comment">#读写CSV文件</span><br><span class="hljs-keyword">import</span> csv<br><span class="hljs-comment">#以写入方式打开文件，如果文件不存在则自动创建</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">"d:/test.csv"</span>,<span class="hljs-string">'w'</span>)<br><span class="hljs-comment">#获取csvwriter，用于写入csv格式数据</span><br>writer = csv.writer(f)<br><span class="hljs-comment">#写入数据</span><br>writer.writerow([<span class="hljs-string">"张三"</span>,<span class="hljs-string">"男"</span>,<span class="hljs-string">"1.7"</span>])<br><span class="hljs-comment">#关闭文件</span><br>f.c1ose()<br> 将数据写到MySql<br>安装模块<br>pip install pymysql<br><span class="hljs-keyword">import</span> pymysq1<br><span class="hljs-comment">#创建连接</span><br>conn = pymysql.connect(host=<span class="hljs-string">'127.0.0.1'</span>,port=<span class="hljs-number">3306</span>,user=<span class="hljs-string">'root'</span>,passwd=<span class="hljs-string">''</span>,db=<span class="hljs-string">'tkq1'</span>,charset=<span class="hljs-string">'utf8'</span>)<br><span class="hljs-comment">#创建游标</span><br>cursor = conn.cursor()<br><span class="hljs-comment">#执行SQL，并返回收影响行数</span><br>effect_row = cursor.execute(<span class="hljs-string">"select * from tb7"</span>)<br><span class="hljs-comment">#执行SQL，并返回受影响行数</span><br><span class="hljs-comment">#effect_row = cursor.execute("update tb7 set pass= 123’where nid= %s",(11,))</span><br><span class="hljs-comment">#执行SQL，并返回受影响行数，执行多次</span><br><span class="hljs-comment">#effect_row=cursor.executemanyC"insert into tb7(user,pass,icnese）values（s,%s,%s）”</span><br>[（“ui<span class="hljs-string">"，“ulpass”11111)，（“u2”，u2pass”，*22222”)]）</span><br><span class="hljs-string">#提交，不然无法保存新建或者修改的数据</span><br><span class="hljs-string">conn.commit()</span><br><span class="hljs-string">#关闭游标</span><br><span class="hljs-string">cursor.close()</span><br><span class="hljs-string">#关闭连接</span><br><span class="hljs-string">conn.close()</span><br><span class="hljs-string"> </span><br><span class="hljs-string">六. 数据分析网站</span><br><span class="hljs-string">    https://www.heywhale.com/home</span><br><span class="hljs-string">    https://kaggle.com/</span><br><span class="hljs-string"> </span><br><span class="hljs-string">七.无头浏览器语法</span><br><span class="hljs-string">chrome_options = webdriver.ChromeOptions()</span><br><span class="hljs-string">chrome_options.add_argument('--headless')</span><br><span class="hljs-string">chrome_options.add_argument('--disable-gpu')</span><br><span class="hljs-string">chrome_options.add_argument('--no-sandbox')</span><br><span class="hljs-string">chrome_options.add_argument('--disable-infobars') #禁止显示浏览器正在受到自动测试软件控制的通知</span><br><span class="hljs-string">chrome_options.add_experimental_option("</span>excludeSwitches<span class="hljs-string">",["</span>enable-automation<span class="hljs-string">"]) #排除启用自动化扩展程序的开关，可以防止被网站检测到使用了自动化工具，减少被反爬虫封锁的可能性</span><br><span class="hljs-string">chrome_options.add_experimental_option("</span>userAutomationExtension<span class="hljs-string">",False) #禁用自动化扩展程序，同样是为了避免被网站检测到使用了自动化工具</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>对于浏览器窗口的切换和窗口中的iframe切换的方法：</li>
</ul>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 初始化 WebDriver，这里以 Chrome 为例</span><br>driver = webdriver.Chrome()<br><br><span class="hljs-comment"># 手动登录后假设打开了两个窗口</span><br><span class="hljs-comment"># 等待页面加载完成</span><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 切换到第1个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第1个窗口"</span>)<br><br><span class="hljs-comment"># 在第1个窗口中执行一些操作</span><br><span class="hljs-comment"># ...（省略具体操作代码）</span><br><br><span class="hljs-comment"># 切换到第2个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第2个窗口"</span>)<br><br><span class="hljs-comment"># 在第2个窗口中找到第1个 iframe 并切换到它</span><br>driver.switch_to.frame(driver.find_element(By.XPATH, <span class="hljs-string">'第1个 iframe 的 XPATH'</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第1个 iframe"</span>)<br><br><span class="hljs-comment"># 在第1个 iframe 中找到第2个嵌套的 iframe 并切换到它</span><br>driver.switch_to.frame(driver.find_element(By.XPATH, <span class="hljs-string">'第2个嵌套 iframe 的 XPATH'</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第2个嵌套的 iframe"</span>)<br><br><span class="hljs-comment"># 在嵌套的 iframe 中执行一些操作</span><br>element = driver.find_element(By.XPATH, <span class="hljs-string">'嵌套 iframe 中元素的 XPATH'</span>)<br>element.click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"点击了嵌套 iframe 中的元素"</span>)<br><br><span class="hljs-comment"># 完成操作后，如果需要切换回最外层的窗口，可以使用以下代码</span><br>driver.switch_to.default_content()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换回了最外层的窗口"</span>)<br><br><span class="hljs-comment"># 如果需要切换回上一级的 iframe，可以使用以下代码</span><br>driver.switch_to.parent_frame()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换回了上一级的 iframe"</span>)<br><br><span class="hljs-comment"># 关闭浏览器</span><br>driver.quit()<br>---------------------<br><span class="hljs-comment"># 窗口切换</span><br><span class="hljs-comment"># 切换到第一个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到第一个窗口"</span>)<br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 假设在此处进行一些操作...</span><br><br><span class="hljs-comment"># 切换到第二个窗口</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(driver.window_handles) &gt; <span class="hljs-number">1</span>:<br>    driver.switch_to.window(driver.window_handles[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到第二个窗口"</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"没有第二个窗口可以切换"</span>)<br><br></code></pre></td></tr></tbody></table></figure>

<h2 id="Qt图形界面开发"><a href="#Qt图形界面开发" class="headerlink" title="Qt图形界面开发"></a>Qt图形界面开发</h2><ul>
<li><p>PyQt GUI 主要类的层次结构：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># QObject &lt;= QWidget （组件）</span><br><span class="hljs-comment">## QWidget &lt;= QFrame &lt;= QLabel</span><br><span class="hljs-comment">## QWidget &lt;= QDialog</span><br><span class="hljs-comment">## QWidget &lt;= QAbstracButtom (抽象的按钮)</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QPushButtom</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QCheckBox</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QRadioButtom</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>一个简单的GUI图开界面：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br>app=QApplication(sys.argv) <span class="hljs-comment">#创建应用程序对象，在创建应用程序时需要一个列表对象，sys.argv可用于获取从命令行输入的参数列表</span><br>window=QWidget() <span class="hljs-comment">#窗口对象可以是QWidget、QFrame、QDialog类型。对一般小窗口使用QWidget类型即可</span><br>window.show() <span class="hljs-comment">#窗口默认是隐藏的，需要调用show函数才能展示</span><br>app.<span class="hljs-built_in">exec</span>() <span class="hljs-comment">#让应用程序进入主事件循环中</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>以面向对象方式实现PyQt GUI 程序：将图形窗口的定义封装成一个窗口类，实现统一调用的过程。可实现代码重用。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <span class="hljs-comment">#根据自己需要，也可以将QFrame和QDialog等窗口类作为父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):	  <span class="hljs-comment">#自定义一个窗口类构造函数</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):	 <span class="hljs-comment">#该函数用于初始化窗口中的控件，会在构造函数中调用</span><br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():		<span class="hljs-comment">#模块中的主函数</span><br>    app = QApplication(sys.argv)<br>    win = MyWindow()	<span class="hljs-comment">#实例化窗口对象</span><br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:	<span class="hljs-comment">#如果当前模块为主模块，则调用主函数启动窗口，加上这段代码是为在模块中方便自己调试代码，当这个模块不作为主模块而被其它模块调用时，以下代码块内容都不会运行</span><br>    main()<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>处理事件：在Qt中对事件的处理机制采用的是信号和槽方式，用于对象之间的通信，是Qt库的核心机制。处理事件有三个要素</p>
<ul>
<li><p>事件：是用户界面上的控件进行的操作，如点击，键盘动作，又叫信号</p>
</li>
<li><p>事件源：事件发生的场所，指控件</p>
</li>
<li><p>事件处理程者：对控件动作进行响应处理的函数，一般是一个对象某个方法，又叫槽</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel,QPushButton <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <span class="hljs-comment">#根据自己需要，也可以将QFrame和QDialog等窗口类作为父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)	<span class="hljs-comment">#创建标签控件是成员变量，因为需要在其它函数中访问该控件。这里是在槽函数中访问该控件的</span><br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>        buttom=QPushButton(<span class="hljs-string">'OK'</span>,<span class="hljs-variable language_">self</span>)<br>        buttom.move(<span class="hljs-number">170</span>,<span class="hljs-number">160</span>)<br>        buttom.clicked.connect(<span class="hljs-variable language_">self</span>.click_success) <span class="hljs-comment">#chicked是一种信号，它是按钮的单击事件，click_success是槽，它是一个事件处理函数，注意在连接槽时，clicked和click_success后面都没有小括号。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click_success</span>(<span class="hljs-params">self</span>):	<span class="hljs-comment">#槽，它是一个事件处理函数</span><br>        sender = <span class="hljs-variable language_">self</span>.sender()	<span class="hljs-comment">#sender()函数返回发送信号的对象(事件源)，这里就是按钮控件</span><br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Success!'</span>)<br>        <span class="hljs-built_in">print</span>(sender.text())	<span class="hljs-comment">#打印按钮的文本</span><br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>鼠标事件：对于控件的事件，将控件信号与槽函数连接起来就可以了，但在处理鼠标或键盘事件时，我们只需要重写QWidget类的一些函数就可以了，因为鼠标和键盘的事件非常特殊，它是QWiget类自带的，本身就带有处理的函数。鼠标事件就是鼠标的信号，有以下三种，实现鼠标事件只需要重写该函数，如下：</p>
<ul>
<li><p>mousePressEvent(event) ，鼠标按下，处理鼠标按下时调用的函数，event参数表示鼠标事件对象，保存了鼠标事件的一些信息。</p>
</li>
<li><p>mouseReleaseEvent(event) ，鼠标松开（释放）</p>
</li>
<li><p>moueMoveEvent(event) ，鼠标移动</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>       <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mousePressEvent</span>(<span class="hljs-params">self, event</span>): <span class="hljs-comment">#重写鼠标按下函数，这也就是一个槽函数，响应鼠标按下的信号，鼠标的信号源就是这个窗口</span><br>        <span class="hljs-keyword">if</span> event.button() == Qt.MouseButton.LeftButton: <span class="hljs-comment">#鼠标事件对象event的button()函数返回用户按下的鼠标键</span><br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Left Button Clicked'</span>)<br><br>        <span class="hljs-keyword">elif</span> event.button()==Qt.MouseButton.RightButton:<br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Right Button Clicked'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'鼠标未知按下'</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mouseReleaseEvent</span>(<span class="hljs-params">self, event</span>): <span class="hljs-comment">#重写鼠标释放函数</span><br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Mouse Released'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>键盘事件：</p>
<ul>
<li><p>keyPressEvent(event)，在按下键盘时调用的函数，event参数表示键盘事件对象，保存了键盘事件的一些信息</p>
</li>
<li><p>keyReleaseEvent(event)，在释放键盘时调用的函数</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>       <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, event</span>): <br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Key Pressed'</span>)<br>        <span class="hljs-built_in">print</span>(event.key())  <span class="hljs-comment">#键盘事件对象的key方法能获取按下的键盘的ascII值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyReleaseEvent</span>(<span class="hljs-params">self, event</span>): <br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Key Released'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>布局管理器：</p>
<ul>
<li><p>盒子布局管理器：QBoxLayout类，又分为二个子类QVBoxLayout，垂直布局；QHBoxLayout，水平布局</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QHBoxLayout,QPushButton<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        hboxLayout=QHBoxLayout(<span class="hljs-variable language_">self</span>)<br>        button1=QPushButton(<span class="hljs-string">'Button 1'</span>,<span class="hljs-variable language_">self</span>)<br>        button2=QPushButton(<span class="hljs-string">'Button 2'</span>,<span class="hljs-variable language_">self</span>)<br>        button3=QPushButton(<span class="hljs-string">'Button 3'</span>,<span class="hljs-variable language_">self</span>)<br>        hboxLayout.addWidget(button1)<br>        hboxLayout.addWidget(button2)<br>        hboxLayout.addWidget(button3)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>网格布局管理器：QGridLayout类，由行列组成，我们可以将控件放在指定单元格中。</p>
</li>
<li><p>表单布局管理器：QFormLayout类，表单一般由两列（第1列是标签列，第2列是控件列）和若干行构成，在表单布局中添加控件是通过addRow函数实现。</p>
</li>
</ul>
</li>
<li><p>常用控件</p>
<ul>
<li>文本输入控件：单行输入控件，QLineEdit；多行输入控件,QTextEdit</li>
<li>单选按钮：QRadioButton类，单选按钮在同一组中是互斥的，通过QButtonGroup类可以进行分组，不同组间互不干扰。QButtonGroup类只是单选按钮容器，不属于控件类，不会有任何视觉展示，因此在进行布局管理时还需要使用相应的布局管理器。</li>
<li>复选框：QCheckBox类，实现多选功能，提供两种状态的开和关。</li>
<li>列表控件：QlistWidget，提供了一个选项列表供用户选择，给列表添加选项的函数有，addItem(str)，添加一个选项；addItems(list)，一次添加多个选项。</li>
<li>下拉列表控件：QComboBox类，当列表控件占用空间太大，你希望空间紧凑时，可以使用该控件。</li>
<li>表格控件：QTableWidget类，可以将一个列表的数据展现在表格控件中的一行中，当有大量数据需要展示和修改时，可使用该控件。</li>
</ul>
</li>
<li><p>界面设计工具：QTDesigner</p>
</li>
</ul>
<h2 id="常见的编码和加密"><a href="#常见的编码和加密" class="headerlink" title="常见的编码和加密"></a>常见的编码和加密</h2><ul>
<li><p>常见的编码有base64、unicode、urlencode编码，加密有MD5、SHA1、HMAC、DES、RSA等。</p>
<ul>
<li><p>base64：base64是一种基于64个可打印ASCLL字符对任意字节数据进行编码的算法，其在编码后具有一定意义的加密作用。在逆向过程中经常会碰到base64编码。在python中使用base64：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> base64<br><span class="hljs-built_in">print</span>(base64.b64encode(<span class="hljs-string">'msb'</span>.encode()))<br><span class="hljs-built_in">print</span>(base64.b64decode(<span class="hljs-string">'bXNi'</span>.encode()))<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>unicode和urlencode：unicode是计算机中字符集、编码的一项业界标准，被称为统一码、万国码，表现形式一般以“\u” 或者 “&amp;#”开头。urlencode是URL编码，也称作百分号编码用于把URL中的符号进行转换。</p>
</li>
<li><p>MD5：MD5消息摘要算法（英文：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5加密算法是不可逆的，所以解密一般都是通过暴力穷举方法，以及网站的接口实现解密。python代码实现加密：</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br>pwd = <span class="hljs-string">"123"</span><br><span class="hljs-comment"># 生成MD5对象</span><br>m = hashlib.md5()<br><span class="hljs-comment"># 对数据进行加密</span><br>m.update(pwd.encode(<span class="hljs-string">'utf-8'</span>))<br><span class="hljs-comment"># 获取密文</span><br>pwd = m.hexdigest()<br><span class="hljs-built_in">print</span>(pwd)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>SHA1：SHA1（Secure Hash Algorithm）安全哈希算法主要适用于数字签名标准里面定义的数字签名算法，SHA1比MD5的安全性更强。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。一般在没有高度混淆的Js代码中，SHA1加密的关键词就是sha1。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br>sha1 = hashlib.sha1()<br>data1 = <span class="hljs-string">"msb"</span><br>data2 = <span class="hljs-string">"kkk"</span><br>sha1.update(data1.encode(<span class="hljs-string">"utf-8"</span>))<br>sha1_data1 = sha1.hexdigest()<br><span class="hljs-built_in">print</span>(sha1_data1)<br>sha1.update(data2.encode(<span class="hljs-string">"utf-8"</span>))<br>sha1_data2 = sha1.hexdigest()<br><span class="hljs-built_in">print</span>(sha1_data2)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>HMAC：HMAC全称：散列消息鉴别码。HMAC加密算法是一种安全的基于加密hash函数和共享密钥的消息认证协议。实现原理是用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hmac<br><span class="hljs-keyword">import</span> hashlib<br>key = <span class="hljs-string">"key"</span>.encode()<br>text = <span class="hljs-string">"msb"</span>.encode()<br>m = hmac.new(key, text, hashlib.sha256)<br><span class="hljs-built_in">print</span>(m.digest())<br><span class="hljs-built_in">print</span>(m.hexdigest())<br><span class="hljs-comment">#new（key,msg=None,digestmod）方法创建哈希对象,key和digestmod参数必须指定，key和msg（需要加密的内容）均为bytes类型，digestmod指定加密算法，比如‘md5’,'sha1'等</span><br><span class="hljs-comment">#对象digest（）方法：返回bytes类型哈希值</span><br><span class="hljs-comment">#对象hexdigest（）方法：返回十六进制哈希值</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>DES：</p>
</li>
<li><p>DES全称：数据加密标准（Data Encryption Standard），属于对称加密算法。DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8位都用作奇偶校验），密钥可以是任意的56位数，而且可以任意时候改变。Js逆向时，DES加密的搜索关键词有DES、mode、padding等。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># pyDes需要安装</span><br><span class="hljs-keyword">from</span> pyDes <span class="hljs-keyword">import</span> des, CBC, PAD_PKCS5<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-comment"># 秘钥</span><br>KEY = <span class="hljs-string">'dsj2020q'</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_encrypt</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    DES 加密</span><br><span class="hljs-string">    :param s: 原始字符串</span><br><span class="hljs-string">    :return: 加密后字符串，16进制</span><br><span class="hljs-string">    """</span><br>    secret_key = KEY<br>    iv = secret_key<br>    k = des(secret_key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)<br>    en = k.encrypt(s, padmode=PAD_PKCS5)<br>    <span class="hljs-keyword">return</span> binascii.b2a_hex(en).decode()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_decrypt</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    DES 解密</span><br><span class="hljs-string">    :param s: 加密后的字符串，16进制</span><br><span class="hljs-string">    :return:  解密后的字符串</span><br><span class="hljs-string">    """</span><br>    secret_key = KEY<br>    iv = secret_key<br>    k = des(secret_key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)<br>    de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5)<br>    <span class="hljs-keyword">return</span> de.decode()<br><br>text = <span class="hljs-string">'msb'</span><br>secret_str = des_encrypt(text)<br><span class="hljs-built_in">print</span>(secret_str)<br><br>clear_str = des_decrypt(secret_str)<br><span class="hljs-built_in">print</span>(clear_str)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>AES：AES全程：高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。AES也是对称加密算法，如果能够获取到密钥，那么就能对密文解密。Js逆向时，AES加密的搜索关键词有AES、mode、padding等。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#需要安装pip install pycryptodome</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><span class="hljs-comment"># AES</span><br><span class="hljs-comment"># 需要补位，str不是16的倍数那就补足为16的倍数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_16</span>(<span class="hljs-params">value</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(value) % <span class="hljs-number">16</span> != <span class="hljs-number">0</span>:<br>        value += <span class="hljs-string">'\0'</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.encode(value)  <span class="hljs-comment"># 返回bytes</span><br><br><span class="hljs-comment"># 加密方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">key, text</span>):<br>    aes = AES.new(add_to_16(key), AES.MODE_ECB)  <span class="hljs-comment"># 初始化加密器</span><br>    encrypt_aes = aes.encrypt(add_to_16(text))  <span class="hljs-comment"># 先进行aes加密</span><br>    encrypted_text = <span class="hljs-built_in">str</span>(base64.encodebytes(encrypt_aes), encoding=<span class="hljs-string">'utf-8'</span>)<br>    <span class="hljs-keyword">return</span> encrypted_text<br><br><span class="hljs-comment"># 解密方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">key, text</span>):<br>    aes = AES.new(add_to_16(key), AES.MODE_ECB)  <span class="hljs-comment"># 初始化加密器</span><br>    base64_decrypted = base64.decodebytes(text.encode(encoding=<span class="hljs-string">'utf-8'</span>))<br>    decrypted_text = <span class="hljs-built_in">str</span>(aes.decrypt(base64_decrypted), encoding=<span class="hljs-string">'utf-8'</span>).replace(<span class="hljs-string">'\0'</span>, <span class="hljs-string">''</span>)  <span class="hljs-comment"># 执行解密密并转码返回str</span><br>    <span class="hljs-keyword">return</span> decrypted_text<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>RSA：RSA全称：Rivest-Shamir-Adleman, RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用，它被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗目前为止已知的所有密码攻击。注意Js代码中的RSA常见标志setPublickey。</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#需要安装：pip install pycryptodome </span><br><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> PKCS1_v1_5<br><span class="hljs-keyword">from</span> Crypto <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><span class="hljs-comment"># ------------------------生成密钥对------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_rsa_pair</span>(<span class="hljs-params">is_save=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    创建rsa公钥私钥对</span><br><span class="hljs-string">    :param is_save: default:False</span><br><span class="hljs-string">    :return: public_key, private_key</span><br><span class="hljs-string">    """</span><br>    f = RSA.generate(<span class="hljs-number">2048</span>)<br>    private_key = f.exportKey(<span class="hljs-string">"PEM"</span>)  <span class="hljs-comment"># 生成私钥</span><br>    public_key = f.publickey().exportKey()  <span class="hljs-comment"># 生成公钥</span><br>    <span class="hljs-keyword">if</span> is_save:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"crypto_private_key.pem"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(private_key)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"crypto_public_key.pem"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(public_key)<br>    <span class="hljs-keyword">return</span> public_key, private_key<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_public_key</span>(<span class="hljs-params">file_path=<span class="hljs-string">"crypto_public_key.pem"</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> x:<br>        b = x.read()<br>        <span class="hljs-keyword">return</span> b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_private_key</span>(<span class="hljs-params">file_path=<span class="hljs-string">"crypto_private_key.pem"</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> x:<br>        b = x.read()<br>        <span class="hljs-keyword">return</span> b<br><br><span class="hljs-comment"># ------------------------加密------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encryption</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, public_key: <span class="hljs-built_in">bytes</span></span>):<br>    <span class="hljs-comment"># 字符串指定编码（转为bytes）</span><br>    text = text.encode(<span class="hljs-string">"utf-8"</span>)<br>    <span class="hljs-comment"># 构建公钥对象</span><br>    cipher_public = PKCS1_v1_5.new(RSA.importKey(public_key))<br>    <span class="hljs-comment"># 加密（bytes）</span><br>    text_encrypted = cipher_public.encrypt(text)<br>    <span class="hljs-comment"># base64编码，并转为字符串</span><br>    text_encrypted_base64 = base64.b64encode(text_encrypted).decode()<br>    <span class="hljs-keyword">return</span> text_encrypted_base64<br><span class="hljs-comment"># ------------------------解密------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decryption</span>(<span class="hljs-params">text_encrypted_base64: <span class="hljs-built_in">str</span>, private_key: <span class="hljs-built_in">bytes</span></span>):<br>    <span class="hljs-comment"># 字符串指定编码（转为bytes）</span><br>    text_encrypted_base64 = text_encrypted_base64.encode(<span class="hljs-string">"utf-8"</span>)<br>    <span class="hljs-comment"># base64解码</span><br>    text_encrypted = base64.b64decode(text_encrypted_base64)<br>    <span class="hljs-comment"># 构建私钥对象</span><br>    cipher_private = PKCS1_v1_5.new(RSA.importKey(private_key))<br>    <span class="hljs-comment"># 解密（bytes）</span><br>    text_decrypted = cipher_private.decrypt(text_encrypted, Random.new().read)<br>    <span class="hljs-comment"># 解码为字符串</span><br>    text_decrypted = text_decrypted.decode()<br>    <span class="hljs-keyword">return</span> text_decrypted<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># 生成密钥对</span><br>    <span class="hljs-comment"># create_rsa_pair(is_save=True)</span><br>    <span class="hljs-comment"># public_key = read_public_key()</span><br>    <span class="hljs-comment"># private_key = read_private_key()</span><br>    public_key, private_key = create_rsa_pair(is_save=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># 加密</span><br>    text = <span class="hljs-string">"msb"</span><br>    text_encrypted_base64 = encryption(text, public_key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"密文："</span>, text_encrypted_base64)<br><br>    <span class="hljs-comment"># 解密</span><br>    text_decrypted = decryption(text_encrypted_base64, private_key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"明文："</span>, text_decrypted)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Python爬虫学习</div>
      <div>http://example.com/2025/08/03/Python/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>阿布</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/03/git/" title="Git学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/03/AI/" title="AI学习">
                        <span class="hidden-mobile">AI学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
