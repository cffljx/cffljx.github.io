

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="阿布">
  <meta name="keywords" content="学习、生活">
  
    <meta name="description" content="git简述 2005年，开源项目Linux创始人Linus为了将代码放到版本控制系统内面，花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 G">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习">
<meta property="og:url" content="http://example.com/2025/08/03/git/index.html">
<meta property="og:site_name" content="Cffljx的学习空间">
<meta property="og:description" content="git简述 2005年，开源项目Linux创始人Linus为了将代码放到版本控制系统内面，花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 G">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-03T02:00:00.000Z">
<meta property="article:modified_time" content="2025-08-03T06:03:13.000Z">
<meta property="article:author" content="阿布">
<meta property="article:tag" content="学习、生活">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Git学习 - Cffljx的学习空间</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Cffljx的学习空间" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cffljx</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Git学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-03 10:00" pubdate>
          2025年8月3日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          107 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Git学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="git简述"><a href="#git简述" class="headerlink" title="git简述"></a>git简述</h1><ul>
<li>2005年，开源项目Linux创始人Linus为了将代码放到版本控制系统内面，花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</li>
<li>Git是分布式的版本控制系统，分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li>
<li>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li>
</ul>
<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><ul>
<li><p>在Linux上安装Git:如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt install git就可以直接完成Git的安装，非常简单。</p>
</li>
<li><p>在Windows上使用Git，也有两种安装方法。第一种是直接从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功。第二种是先安装一个包管理器，推荐Scoop，然后在PowerShell中通过以下命令安装Git：C:&gt; scoop install git,安装完成后，在PowerShell下运行命令git -v显示Git版本.使用包管理器安装Git只需一条命令，且升级非常方便。</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debian/Ubuntu Linux的APT、macOS的Homebrew、Windows的Scoop在命令行下的安装、升级、卸载命令都是类似的，例如，升级Git，三种包管理器对应的命令分别是：</span><br><span class="line">sudo apt update git</span><br><span class="line">brew update git</span><br><span class="line">scoop update git</span><br><span class="line">可以说熟悉一种包管理器的用法后，在其他平台也可迅速上手，推荐使用。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>配置Git:安装好Git后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global user.name "Your Name"</span><br><span class="line"><span class="built_in">$</span> git config --global user.email "email@example.com"</span><br><span class="line"><span class="params">#</span>注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</span><br></pre></td></tr></tbody></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
</li>
</ul>
<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><ul>
<li><p>版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单：</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一步：选择一个合适的地方，创建一个空目录：</span><br><span class="line"><span class="built_in">$</span> mkdir learngit</span><br><span class="line"><span class="built_in">$</span> cd learngit</span><br><span class="line"><span class="built_in">$</span> pwd</span><br><span class="line">/Users/michael/learngit</span><br><span class="line">第二步：通过git init命令把这个目录变成Git可以管理的仓库：</span><br><span class="line"><span class="built_in">$</span> git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br><span class="line">瞬间Git就把仓库建好了，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</span><br><span class="line"></span><br><span class="line">在 Git 中，“删除仓库” 通常有两种场景：删除本地仓库和删除远程仓库。两者的操作方式完全不同，具体如下：</span><br><span class="line">一、删除本地仓库（保留远程仓库）</span><br><span class="line">如果你只是想删除本地计算机上的 Git 仓库，但保留 GitHub/Gitee 等远程服务器上的仓库，有两种方法：</span><br><span class="line">方法 1：直接删除仓库文件夹</span><br><span class="line">这是最简单的方法，直接删除包含 .git 隐藏文件夹的项目目录。</span><br><span class="line">方法 2：清除 Git 版本控制（保留文件但不再是 Git 仓库）</span><br><span class="line">如果你想保留项目文件，但不再使用 Git 进行版本控制，可以删除项目中的 .git 目录</span><br><span class="line">二、删除远程仓库（彻底删除）</span><br><span class="line">如果你想删除 GitHub/Gitee 等平台上的远程仓库（此操作不可逆，会永久丢失数据），需通过平台的网页界面操作</span><br><span class="line">注意事项</span><br><span class="line">删除远程仓库是不可逆操作，所有代码和提交历史将永久丢失，建议提前备份。</span><br><span class="line">删除本地仓库后，若想重新获取代码，可通过 git clone 从远程仓库拉取。</span><br><span class="line">删除远程仓库前，确保团队成员已同步最新代码，避免数据丢失。</span><br><span class="line">根据你的实际需求选择合适的删除方式即可。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>把文件添加到版本库：</p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">现在我们编写一个readme.txt文件，一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。再把这个文件放到Git仓库只需要两步。</span><br><span class="line">第一步，用命令git add告诉Git，把文件添加到仓库：</span><br><span class="line"><span class="built_in">$</span> git add readme.txt</span><br><span class="line">第二步，用命令git commit告诉Git，把文件提交到仓库：</span><br><span class="line"><span class="built_in">$</span> git commit -m "wrote a readme file"</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line">简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</span><br><span class="line">嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</span><br><span class="line">为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件</span><br><span class="line">小结</span><br><span class="line">现在总结一下今天学的两点内容：</span><br><span class="line">初始化一个Git仓库，使用git init命令。</span><br><span class="line">添加文件到Git仓库，分两步：</span><br><span class="line">使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；</span><br><span class="line">使用命令git commit -m &lt;message&gt;，完成。</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li><p>要随时掌握工作区的状态，使用git status命令。</p>
</li>
<li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
</li>
<li><p>在Git中，我们用git log命令查看历史记录，显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上  –pretty=oneline  参数。</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br><span class="line">你看到的一大串类似1094adb...的是commit id（版本号）是一个SHA1计算出来的一个非常大的数字，用十六进制表示</span><br><span class="line">回退到上一个版本,首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD<span class="built_in">^</span>，上上一个版本就是HEAD<span class="built_in">^</span><span class="built_in">^</span>，当然往上100个版本写100个<span class="built_in">^</span>比较容易数不过来，所以写成HEAD~100。</span><br><span class="line">现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</span><br><span class="line"><span class="built_in">$</span> git reset --hard HEAD<span class="built_in">^</span></span><br><span class="line">HEAD is now at e475afc add distributed</span><br><span class="line"></span><br><span class="line">--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。</span><br><span class="line">让我们用git log再看看现在版本库的状态：</span><br><span class="line"><span class="built_in">$</span> git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br><span class="line">最新的那个版本append GPL已经看不到了，好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，怎么办？办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：</span><br><span class="line"><span class="built_in">$</span> git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br><span class="line"></span><br><span class="line">版本号没必要写全，前几位就可以了，Git会自动去找。</span><br><span class="line">Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL</span><br><span class="line">如果关掉了窗口或电脑的话，用以下命令显示用来记录你的每一次命令，从而找到你的commit id</span><br><span class="line"><span class="built_in">$</span> git reflog</span><br><span class="line">e475afc HEAD@{1}: reset: moving to HEAD<span class="built_in">^</span></span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL</span><br><span class="line">e475afc HEAD@{3}: commit: add distributed</span><br><span class="line">eaadf4e HEAD@{4}: commit (initial): wrote a readme file</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">现在总结一下：</span><br><span class="line">HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit<span class="built_in">_</span>id。</span><br><span class="line">穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><ul>
<li>工作区（Working Directory），就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。</li>
<li>版本库（Repository），工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>
<li>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</li>
<li>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</li>
<li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</li>
<li>小结：暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</li>
</ul>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><ul>
<li>Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</li>
<li>我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</li>
<li>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit，现在，把第二次修改提交了</li>
<li>小结：现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。</li>
</ul>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul>
<li><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
</li>
<li><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>
</li>
<li><p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</file></p>
</li>
<li><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p>
</li>
<li><p>小结</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</file></p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
</li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul>
<li>在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了，现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit；另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout – test.txt，<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li>
<li>从来没有被添加到版本库就被删除的文件，是无法恢复的！</li>
<li>小结<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li>
</ul>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul>
<li><p>有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
</li>
<li><p>你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1步：创建SSH Key.在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</span><br><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br><span class="line">如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</span><br><span class="line">第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容,点“Add Key”，你就应该看到已经添加的Key</span><br><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。</p>
</li>
</ul>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul>
<li><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p>
</li>
<li><p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在本地的learngit仓库下运行命令：</span><br><span class="line">$ git remote add origin git@github.com:cffljx@126.com/learngit.git</span><br><span class="line">说明：cffljx@126.com是你自己的GitHub账户名；origin是远程库的名字，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</span><br><span class="line">下一步，就可以把本地库的所有内容推送到远程库上：</span><br><span class="line">$ git push -u origin master</span><br><span class="line">把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line">推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样</span><br><span class="line">从现在起，只要本地作了提交，就可以通过命令：</span><br><span class="line">$ git push origin master</span><br><span class="line">把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>删除远程库：如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm <name>命令。使用前，建议先用git remote -v查看远程库信息：</name></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br><span class="line">然后，根据名字删除，比如删除origin：</span><br><span class="line">$ git remote rm origin</span><br><span class="line">此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>小结<br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>
<p>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；</p>
<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
</li>
</ul>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul>
<li><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。用命令git clone克隆一个本地库：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into 'gitskills'...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line">注意把Git库的地址换成你自己的,如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>GitHub给出的地址不止一个，还可以用<a target="_blank" rel="noopener" href="https://github.com/michaelliao/gitskills.git%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8CGit%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8ssh%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8https%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82%E4%BD%BF%E7%94%A8https%E9%99%A4%E4%BA%86%E9%80%9F%E5%BA%A6%E6%85%A2%E4%BB%A5%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E9%BA%BB%E7%83%A6%E6%98%AF%E6%AF%8F%E6%AC%A1%E6%8E%A8%E9%80%81%E9%83%BD%E5%BF%85%E9%A1%BB%E8%BE%93%E5%85%A5%E5%8F%A3%E4%BB%A4%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%8F%AA%E5%BC%80%E6%94%BEhttp%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8ssh%E5%8D%8F%E8%AE%AE%E8%80%8C%E5%8F%AA%E8%83%BD%E7%94%A8https%E3%80%82">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</a></p>
</li>
<li><p>小结<br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p>
<p>Git支持多种协议，包括https，但ssh协议速度最快。</p>
</li>
</ul>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul>
<li>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</li>
</ul>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ul>
<li><p>在版本回退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
</li>
<li><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">				HEAD</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">                 master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">				master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘</span><br><span class="line">                    ▲</span><br><span class="line">                    │</span><br><span class="line">                   dev</span><br><span class="line">                    ▲</span><br><span class="line">                    │</span><br><span class="line">                  HEAD</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<pre><code>                master
                    │
                    ▼
┌───┐    ┌───┐    ┌───┐    ┌───┐
│   │───▶│   │───▶│   │───▶│   │
└───┘    └───┘    └───┘    └───┘
                             ▲
                             │
                            dev
                             ▲
                             │
                           HEAD          
</code></pre>
</li>
<li><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                           HEAD</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">                          master</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br><span class="line">                             ▲</span><br><span class="line">                             │</span><br><span class="line">                            dev</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                           HEAD</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">                          master</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>下面开始实战。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch 'dev'</span><br><span class="line">然后，用git branch命令查看当前分支：</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line">然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</span><br><span class="line">Creating a new branch is quick.</span><br><span class="line">然后提交：</span><br><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m "branch test"</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">现在，dev分支的工作完成，我们就可以切换回master分支：</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</span><br><span class="line">                  HEAD</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">                 master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br><span class="line">                             ▲</span><br><span class="line">                             │</span><br><span class="line">                            dev</span><br><span class="line">现在，我们把dev分支的工作成果合并到master分支上：</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</span><br><span class="line">合并完成后，就可以放心地删除dev分支了：</span><br><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br><span class="line">删除后，查看branch，就只剩下master分支了：</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>switch:我们注意到切换分支使用git checkout <branch>，而前面讲过的撤销修改则是git checkout – <file>，同一个命令，有两种作用，确实有点令人迷惑。实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：</file></branch></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建并切换到新的`dev`分支，可以使用：</span><br><span class="line">$ git switch -c dev</span><br><span class="line">直接切换到已有的master分支，可以使用：</span><br><span class="line">$ git switch master</span><br><span class="line">使用新的git switch命令，比git checkout要更容易理解。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>小结<br>Git鼓励大量使用分支：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name>或者git switch <name></name></name></p>
<p>创建+切换分支：git checkout -b <name>或者git switch -c <name></name></name></p>
<p>合并某分支到当前分支：git merge <name></name></p>
<p>删除分支：git branch -d <name></name></p>
</li>
</ul>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ul>
<li><p>小结<br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用git log –graph命令可以看到分支合并图。</p>
</li>
</ul>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul>
<li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
</li>
<li><p>小结<br>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
</li>
</ul>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ul>
<li><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
</li>
<li><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>
</li>
<li><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug</p>
</li>
<li><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p>
</li>
<li><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交</p>
</li>
<li><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</p>
</li>
<li><p>现在，是时候接着回到dev分支干活了</p>
</li>
<li><p>小结<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</commit></p>
</li>
</ul>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><ul>
<li><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
</li>
<li><p>小结<br>开发一个新功能，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p>
</li>
</ul>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ul>
<li><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要查看远程库的详细信息，用git remote -v：</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br><span class="line">上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>推送分支<br>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">如果要推送其他分支，比如dev，就改成：</span><br><span class="line">$ git push origin dev</span><br><span class="line">但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</span><br><span class="line">master分支是主分支，因此要时刻与远程同步；</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</span><br><span class="line">bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</span><br><span class="line">feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</span><br><span class="line">总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>抓取分支：多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，推送就会失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p>
</li>
<li><p>因此，多人协作的工作模式通常是这样：</p>
<p>首先，可以尝试用git push origin <branch-name>推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；<br>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！<br>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></branch-name></branch-name></p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
</li>
<li><p>小结<br>查看远程库信息，使用git remote -v；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；<br>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
</li>
</ul>
<h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><ul>
<li>Git有一种称为<code>rebase</code>的操作，有人把它翻译成“变基”。把分叉的提交变成直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</li>
<li>小结<br>rebase操作可以把本地未push的分叉提交历史整理成直线；<br>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li>
</ul>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>标签也是版本库的一个快照，其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<ul>
<li><p>创建标签：</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在Git中打标签非常简单，首先，切换到需要打标签的分支上：</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">然后，敲命令git tag &lt;name&gt;就可以打一个新标签：</span><br><span class="line">$ git tag v1.0</span><br><span class="line">可以用命令git tag查看所有标签：</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了</span><br><span class="line">标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</span><br><span class="line">小结</span><br><span class="line">命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；</span><br><span class="line">命令git tag -a &lt;tagname&gt; -m "blablabla..."可以指定标签信息；</span><br><span class="line">命令git tag可以查看所有标签。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>操作标签</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小结</span><br><span class="line">命令git push origin &lt;tagname&gt;可以推送一个本地标签；</span><br><span class="line">命令git push origin --tags可以推送全部未推送过的本地标签；</span><br><span class="line">命令git tag -d &lt;tagname&gt;可以删除一个本地标签；</span><br><span class="line">命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</span><br><span class="line">git clone git@github.com:path/bootstrap.git</span><br></pre></td></tr></tbody></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</span><br><span class="line"></span><br><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────▶│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br><span class="line">如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</span><br><span class="line">如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</span><br></pre></td></tr></tbody></table></figure>

<p>小结<br>在GitHub上，可以任意Fork开源仓库；<br>自己拥有Fork后的仓库的读写权限；<br>可以推送pull request给官方仓库来贡献代码。</p>
<h1 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h1><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）</p>
<p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p>
<p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“设置”，然后在左侧菜单选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：点击“确定”即可完成并看到刚才添加的Key</p>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">首先，我们在Gitee上创建一个新的项目，选择右上角用户头像旁的加号，然后点击“新建仓库”：</span><br><span class="line">项目名称最好与本地库保持一致。</span><br><span class="line">然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联：</span><br><span class="line"><span class="built_in">$</span> git remote add origin git@gitee.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">之后，就可以正常地用git push和git pull推送了！</span><br><span class="line">如果在使用命令git remote add时报错：</span><br><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br><span class="line">这说明本地库已经关联了一个名叫origin的远程库,我们可以删除已有的GitHub远程库：</span><br><span class="line">git remote rm origin</span><br><span class="line">再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</span><br><span class="line"><span class="built_in">$</span> git remote add origin git@gitee.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。</span><br><span class="line">使用多个远程库时，即一个本地库既关联GitHub，又关联Gitee时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</span><br><span class="line"><span class="built_in">$</span> git remote add github git@github.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">远程库的名称叫github，不叫origin了。</span><br><span class="line"><span class="built_in">$</span> git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line"></span><br><span class="line">远程库的名称叫gitee，不叫origin。</span><br><span class="line">如果要推送到GitHub，使用命令：</span><br><span class="line">git push github master</span><br><span class="line">如果要推送到Gitee，使用命令：</span><br><span class="line">git push gitee master</span><br><span class="line">这样一来，我们的本地库就可以同时与多个远程库互相同步：</span><br><span class="line"></span><br><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     │           │</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></tbody></table></figure>

<p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a target="_blank" rel="noopener" href="https://gitee.com/liaoxuefeng/learngit%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAyour-gitee-id.txt%E7%9A%84%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%99%E7%82%B9%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E5%BF%83%E5%BE%97%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8E%A8%E9%80%81%E4%B8%80%E4%B8%AApull">https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，这个仓库会在Gitee和GitHub做双向同步。</p>
<h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。</p>
<ul>
<li><p>忽略特殊文件：有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等。这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.gitignore文件本身应该提交给Git管理，这样可以确保所有人在同一项目下都使用相同的.gitignore文件。</span><br><span class="line">不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：GitHub/gitignore</span><br><span class="line">忽略文件的原则是：</span><br><span class="line">忽略操作系统自动生成的文件，比如缩略图等；</span><br><span class="line">忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</span><br><span class="line">忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</span><br><span class="line">把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。</span><br><span class="line">.gitignore文件放哪？答案是放Git仓库根目录下，但其实一个Git仓库也可以有多个.gitignore文件，.gitignore文件放在哪个目录下，就对哪个目录（包括子目录）起作用。</span><br><span class="line">myproject          &lt;- Git仓库根目录</span><br><span class="line">├── .gitigore      &lt;- 针对整个仓库生效的.gitignore</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── docs</span><br><span class="line">│   └── .gitigore  &lt;- 仅针对docs目录生效的.gitignore</span><br><span class="line">└── source</span><br><span class="line">小结</span><br><span class="line">忽略某些文件时，需要编写.gitignore；</span><br><span class="line">.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>配置别名：我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global alias.st status</span><br><span class="line">--global 参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</span><br></pre></td></tr></tbody></table></figure>

<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p>
<figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global alias.unstage 'reset HEAD'</span><br><span class="line">当你敲入命令：</span><br><span class="line"><span class="built_in">$</span> git unstage test.py</span><br><span class="line">实际上Git执行的是：</span><br><span class="line"><span class="built_in">$</span> git reset HEAD test.py</span><br></pre></td></tr></tbody></table></figure>

<p>配置文件:配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote "origin"]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br><span class="line">别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</span><br></pre></td></tr></tbody></table></figure>

<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></tbody></table></figure>

<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置，或者直接删掉配置文件错误的那一行。</p>
<p>小结<br>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p>
</li>
<li><p>搭建Git服务器：搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第一步，安装git：</span><br><span class="line">$ sudo apt install git</span><br><span class="line">第二步，创建一个git用户，用来运行git服务：</span><br><span class="line">$ sudo adduser git</span><br><span class="line">第三步，创建证书登录：</span><br><span class="line">收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</span><br><span class="line">第四步，初始化Git仓库：</span><br><span class="line">先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</span><br><span class="line">$ sudo git init --bare sample.git</span><br><span class="line">Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</span><br><span class="line">$ sudo chown -R git:git sample.git</span><br><span class="line">第五步，禁用shell登录：</span><br><span class="line">出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</span><br><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br><span class="line">改为：</span><br><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br><span class="line">这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</span><br><span class="line">第六步，克隆远程仓库：</span><br><span class="line">现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</span><br><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into 'sample'...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">剩下的推送就简单了。</span><br></pre></td></tr></tbody></table></figure>

<p>小结<br>搭建Git服务器非常简单，通常10分钟即可完成；<br>要方便管理公钥，用Gitosis；<br>要像SVN那样变态地控制权限，用Gitolite。</p>
</li>
</ul>
<h1 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h1><p>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</p>
<p>首先从官网下载SourceTree并安装，然后直接运行SourceTree。</p>
<p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p>
<p>提交<br>我们双击learngit这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了git add README.md命令：然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：实际上是执行了git commit -m “update README.md”命令。</p>
<p>分支<br>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如master，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令git checkout master：要合并分支，同样选择待合并分支，例如dev，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令git merge dev：</p>
<p>推送<br>在SourceTree的工具栏上，分别有Pull和Push，分别对应命令git pull和git push，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p>
<p>小结<br>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>在一个目录CMD窗口下，输入：git init 命令，将实现初始化所在的目录，该目录又称为工作区，下会有一个隐藏的.git目录，它就是 Git 本地仓库的核心，称为版本库。.git 目录下的 Index 文件，用来临时存储代码，称为暂存区或索引区。删除目录相当于删除了整个仓库，只删除.git目录相当于git就不能进行本地仓库的版本控制功能。</p>
</li>
<li><p>git status 查看一下状态，终端显示如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">nothing to commit (create/copy files and use "git add" to track) // 暂存区没有什么可提交的</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>新建 index.txt 文件，然后 git status 查看一下状态，终端显示如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master  // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">Untracked files: // 工作区中还没有被跟踪的文件，也就是还没有被 add 的文件，add 之后将会进入暂存区</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line">        index.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track) // 暂存区没有任何提交，但是工作区存在没有被跟踪的文件</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>git add index.txt 将 index.txt add 到暂存区，然后 git status 查看一下状态，终端显示如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master  // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">Changes to be committed: // 暂存区将要被提交的修改，也就是已经从工作区 add 到暂存区中的文件，commit 之后将进入本地仓库</span><br><span class="line">  (use "git rm --cached &lt;file&gt;..." to unstage)  // 使用 ”git rm --cached &lt;file&gt;“ 将从暂存区删除并取消跟踪文件，恢复到 add 之前的状态</span><br><span class="line">        new file:   index.txt</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>git commit -m ‘commt index.txt’ 将 index.txt 提交到本地仓库，然后 git status 查看一下状态，终端显示如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master // 当前为 master 分支</span><br><span class="line">nothing to commit, working tree clean  // 暂存区没有什么可提交的，工作区的树也是干净的</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>执行 git log 查看当前分支 commit 提交的历史记录， 终端显示如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) // 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 哈希值为当次提交的 commit id 校验和</span><br><span class="line">Author: test &lt;test@&gt;</span><br><span class="line">Date:   Thu Sep 30 16:22:22 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit:index.txt</span><br><span class="line"></span><br><span class="line">commit bbeac607be274343dc74099887b9cee40e50d3a3</span><br><span class="line">Author: test &lt;test@&gt;</span><br><span class="line">Date:   Thu Sep 30 11:13:15 2021 +0800</span><br><span class="line">BAN</span><br><span class="line">    first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git log --pretty=oneline，来让每一条日志只显示一行，更加简洁</span><br><span class="line">7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) second commit:idex.txt</span><br><span class="line">bbeac607be274343dc74099887b9cee40e50d3a3 first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git log --oneline，不仅可以让每一条日志只显示一行，而且缩短了哈希值，更加简洁</span><br><span class="line">7d32b40 (HEAD -&gt; master) second commit:idex.txt</span><br><span class="line">bbeac60 first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git reflog</span><br><span class="line">7d32b40 (HEAD -&gt; master) HEAD@{0}: commit: second commit:idex.txt</span><br><span class="line">bbeac60 HEAD@{1}: commit (initial): first commit:index.txt  //  HEAD@{1} 表示移动到当前版本需要1步</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>添加远程仓库：git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:cffljx/ljx.git，gitee是远程仓库的名字。</p>
</li>
<li><p>使用ssh与远程仓库通讯前，需要作如下配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">在C:\Users\Administrator\.ssh目录下，生成密钥对：</span><br><span class="line">ssh-keygen -t ed25519 -C "cffljx@126.com" -f "$HOME/.ssh/id_ed25519"</span><br><span class="line"># 按提示设置密码（或直接回车跳过）</span><br><span class="line"></span><br><span class="line">在.ssh目录下，新建config和known_hosts文件</span><br><span class="line"></span><br><span class="line">config文件内容</span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile C:/Users/Administrator/.ssh/id_ed25519  # 使用 Windows 绝对路径</span><br><span class="line">    StrictHostKeyChecking no  # 临时禁用主机密钥检查（提高安全性建议设置为 ask）</span><br><span class="line"></span><br><span class="line">known_hosts文件内容：</span><br><span class="line">gitee.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5zTjR8iJbPZ+01ZJ146GQJ3v6xq3dC6pX0d5i+hVY=</span><br><span class="line">注意：ssh-后面的内容，换成你前面生成的公钥的内容。</span><br><span class="line"></span><br><span class="line">在远程仓库中将本地公钥填写进去</span><br><span class="line">验证连通性：</span><br><span class="line">D:\vscode\ljxgit&gt;ssh git@gitee.com</span><br><span class="line">Hi cffljx(@cffljx)! You've successfully authenticated, but GITEE.COM does not provide shell access.</span><br><span class="line">Connection to gitee.com closed.</span><br><span class="line">首次连接远程服务器时，系统会提示确认并自动添加：输入 yes 后，公钥会自动写入 known_hosts</span><br><span class="line"></span><br><span class="line">将文件推向远程仓库前，需要与远程仓库先同步：</span><br><span class="line">D:\vscode\ljxgit&gt;git pull --rebase gitee master</span><br><span class="line">remote: Enumerating objects: 18, done.</span><br><span class="line">remote: Counting objects: 100% (1/1), done.</span><br><span class="line">remote: Total 18 (delta 0), reused 0 (delta 0), pack-reused 17 (from 1)</span><br><span class="line">Unpacking objects: 100% (18/18), 5.49 KiB | 151.00 KiB/s, done.</span><br><span class="line">From gitee.com:cffljx/ljx</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; gitee/master</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br><span class="line"></span><br><span class="line">然后就可以将提交到本地仓库的内容推送到远程仓库中去，实现代码版本托管功能：</span><br><span class="line">D:\vscode\ljxgit&gt;git push -u gitee master</span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4/4), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 514 bytes | 514.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">remote: Powered by GITEE.COM [1.1.5]</span><br><span class="line">remote: Set trace flag a1441aaa</span><br><span class="line">To gitee.com:cffljx/ljx.git</span><br><span class="line">   edac3c2..006c899  master -&gt; master</span><br><span class="line">branch 'master' set up to track 'gitee/master'.</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>当然，你也可以用HTTPS协议与远程仓库通讯，只是推送时会提示输入用户名和密码，比较烦锁：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改远程仓库 URL</span><br><span class="line">git remote set-url gitee https://gitee.com/cffljx/ljx.git</span><br><span class="line"></span><br><span class="line"># 推送（会提示输入 Gitee 用户名和密码/令牌）</span><br><span class="line">git push gitee master</span><br></pre></td></tr></tbody></table></figure></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Git学习</div>
      <div>http://example.com/2025/08/03/git/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>阿布</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/03/hello-world/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
