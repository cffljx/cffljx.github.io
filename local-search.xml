<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dock学习</title>
    <link href="/2025/08/04/Docker/"/>
    <url>/2025/08/04/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-Server"><a href="#Ubuntu-Server" class="headerlink" title="Ubuntu Server"></a>Ubuntu Server</h1><h2 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h2><p>一、基本操作命令</p><ul><li>:w 保存当前文件</li><li>:wq或:x 保存并退出Vim</li><li>:q 退出Vim，如果文件有未保存的修改，会提示确认</li><li>:q! 强制退出Vim，不保存当前文件的修改</li></ul><p>二、光标移动命令</p><ul><li><p>h 光标向左移动一个字符</p></li><li><p>j 光标向下移动一行</p></li><li><p>k 光标向上移动一行</p></li><li><p>l 光标向右移动一个字符</p></li><li><p>gg 将光标跳转到文件的第一行</p></li><li><p>G 将光标跳转到文件的最后一行</p></li><li><p>数字+G 将光标跳转到数字指定的行</p></li></ul><p>三、编辑命令</p><ul><li><p>i 进入插入模式，开始在当前光标位置插入文本</p></li><li><p>a 进入插入模式，在当前光标后插入文本</p></li><li><p>o 进入插入模式，在光标所在行的下一行插入文本</p></li><li><p>O 进入插入模式，在光标所在行的上一行插入文件</p></li><li><p>x 删除光标所在位置的字符</p></li><li><p>dd 删除光标所在行的一整行</p></li><li><p>D 删除从光标位置到行尾的文本</p></li><li><p>yy 复制光标所在行的一行文本</p></li><li><p>p 粘贴复制的文本到光标所在位置的下一行</p></li><li><p>u 撤消上一次的编辑操作</p></li><li><p>Ctrl+r 重做上一次撤销的编辑操作</p></li></ul><p>四、查找和替换命令</p><ul><li>/查找文本 查找文件中的文本内容</li><li>n 查找下一个匹配项</li><li>N 查找上一个匹配项</li><li>:s/旧文本/新文本/ 替换当前行中第一个匹配的旧文本为新文本</li><li>%s/旧文本/新文本/g 替换整个文件中所有匹配的旧文本为新文本</li></ul><h2 id="使用root用户登录"><a href="#使用root用户登录" class="headerlink" title="使用root用户登录"></a>使用root用户登录</h2><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">sudo passwd root<br>先输入当前普通用户（如用户lxls）的密码，用于提权<br>然后再输入为root用户所设置的密码，输入两次，这样就完成设置root用户密码了<br>以root登录<br>su root<br></code></pre></td></tr></tbody></table></figure><h2 id="解锁SSH用root登录"><a href="#解锁SSH用root登录" class="headerlink" title="解锁SSH用root登录"></a>解锁SSH用root登录</h2><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">vim /etc/ssh/sshd_config<br>找到相应代码行并注释<br><span class="hljs-comment">#PermitRootLogin prohibit-password</span><br>添加上<br>PermitRootLogin yes<br>保存修改，重启ssh服务<br>service ssh restart<br></code></pre></td></tr></tbody></table></figure><h2 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h2><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs perl">安装vsftpd：<br>apt install vsftpd<br><br>vsftpd服务将在安装过程完成后自动启动。通过打印服务状态进行验证：<br>systemctl status vsftpd<br><br>输出如下所示，表明vsftpd服务处于活动状态并正在运行：<br>● vsftpd.service - vsftpd FTP server<br>     Loaded: loaded (<span class="hljs-regexp">/usr/li</span>b/systemd/<span class="hljs-keyword">system</span>/vsftpd.service; enabled; preset: enabled)<br>     Active: active (running) since Mon <span class="hljs-number">2025</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">01</span>:<span class="hljs-number">13</span>:<span class="hljs-number">07</span> UTC; 2h 24min ago<br>    Process: <span class="hljs-number">2416</span> ExecStartPre=<span class="hljs-regexp">/bin/m</span>kdir -p /var/run/vsftpd/empty (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>   Main PID: <span class="hljs-number">2418</span> (vsftpd)<br>      Tasks: <span class="hljs-number">3</span> (limit: <span class="hljs-number">19041</span>)<br>     Memory: <span class="hljs-number">1</span>.8M (peak: <span class="hljs-number">19</span>.3M)<br>        CPU: 862ms<br>     CGroup: <span class="hljs-regexp">/system.slice/</span>vsftpd.service<br>             ├─<span class="hljs-number">2418</span> /usr/sbin/vsftpd /etc/vsftpd.conf<br>             ├─<span class="hljs-number">2489</span> /usr/sbin/vsftpd /etc/vsftpd.conf<br>             └─<span class="hljs-number">2491</span> /usr/sbin/vsftpd /etc/vsftpd.conf<br>             <br>允许上传和删除：<br>修改vsftpd.conf文件：sudo vim /etc/vsftpd.conf，<br>将 <span class="hljs-comment">#write_enable=YES 前面的注释#去掉   </span><br><br>允许root登录FTP：<br>更改/etc/ftpusers，注释掉root用户：<br>sudo vim /etc/ftpusers<br><span class="hljs-comment">#root</span><br><br>在终端中重启FTP服务：<br>sudo /etc/init.d/vsftpd restart 或者运行<br>service vsftpd restart<br><br>确保vsftpd服务在系统启动时自动启动：<br>sudo systemctl enable vsftpd.service<br></code></pre></td></tr></tbody></table></figure><h2 id="镜像源配置"><a href="#镜像源配置" class="headerlink" title="镜像源配置"></a>镜像源配置</h2><figure class="highlight dts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts">新格式支持：从 Ubuntu <span class="hljs-number">24.04</span> 开始，支持新的 DEB822 格式，需将配置写入软件源文件<span class="hljs-keyword">/etc/</span>apt/sources.list.d/ubuntu.sources 格式如下：<br><br><span class="hljs-meta"># 阿里云</span><br><span class="hljs-symbol">Types:</span> deb<br><span class="hljs-symbol">URIs:</span> http:<span class="hljs-comment">//mirrors.aliyun.com/ubuntu/</span><br><span class="hljs-symbol">Suites:</span> noble noble-updates noble-security<br><span class="hljs-symbol">Components:</span> main restricted universe multiverse<br>Signed-By: <span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/keyrings/</span>ubuntu-archive-keyring.gpg<br><br>更新完软件源后即可使用更新后的镜像源~<br>更新软件源：<br>sudo apt-get update<br><br>更新软件（可选）：<br>sudo apt-get upgrade<br></code></pre></td></tr></tbody></table></figure><h2 id="网卡启动及配置"><a href="#网卡启动及配置" class="headerlink" title="网卡启动及配置"></a>网卡启动及配置</h2><ul><li><p>安装网络管理工具</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> net-tools<br></code></pre></td></tr></tbody></table></figure></li><li><p>查看网卡信息</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ip</span> a<br><span class="hljs-attribute">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="hljs-number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="hljs-number">1000</span><br>    <span class="hljs-attribute">link</span>/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    <span class="hljs-attribute">inet</span> <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">8</span> scope host lo<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br>    <span class="hljs-attribute">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host noprefixroute<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br><span class="hljs-attribute">2</span>: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> qdisc fq_codel state UP group default qlen <span class="hljs-number">1000</span><br>    <span class="hljs-attribute">link</span>/ether <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:<span class="hljs-number">29</span>:d6:<span class="hljs-number">8</span>e:<span class="hljs-number">66</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-attribute">altname</span> enp2s0<br>    <span class="hljs-attribute">inet</span> <span class="hljs-number">172.18.1.109</span>/<span class="hljs-number">22</span> metric <span class="hljs-number">100</span> brd <span class="hljs-number">172.18.3.255</span> scope global dynamic ens32<br>       <span class="hljs-attribute">valid_lft</span> <span class="hljs-number">86339</span>sec preferred_lft <span class="hljs-number">86339</span>sec<br>    <span class="hljs-attribute">inet6</span> fe80::<span class="hljs-number">20</span>c:<span class="hljs-number">29</span>ff:fed6:<span class="hljs-number">8</span>e66/<span class="hljs-number">64</span> scope link<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br><span class="hljs-attribute">3</span>: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> qdisc fq_codel state UP group default qlen <span class="hljs-number">1000</span><br>    <span class="hljs-attribute">link</span>/ether <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:<span class="hljs-number">29</span>:d6:<span class="hljs-number">8</span>e:<span class="hljs-number">70</span> brd ff:ff:ff:ff:ff:ff<br>    <span class="hljs-attribute">altname</span> enp2s1<br>    <span class="hljs-attribute">inet</span> <span class="hljs-number">11.82.10.99</span>/<span class="hljs-number">24</span> brd <span class="hljs-number">11.82.10.255</span> scope global ens33<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br>    <span class="hljs-attribute">inet6</span> fe80::<span class="hljs-number">20</span>c:<span class="hljs-number">29</span>ff:fed6:<span class="hljs-number">8</span>e70/<span class="hljs-number">64</span> scope link<br>       <span class="hljs-attribute">valid_lft</span> forever preferred_lft forever<br></code></pre></td></tr></tbody></table></figure></li><li><p>打开网卡</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br><span class="hljs-comment"># eth0是根据查看网卡信息得到的，你的机器需要跟据实际显示作出修改，up如果换成down就是关闭网卡</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>配置双网卡并设置静态路由</p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nix">ubuntu server <span class="hljs-number">20.04</span> 采用读yaml配置文件的方式修改网卡配置，文件在<span class="hljs-operator">/</span>etc<span class="hljs-operator">/</span>netplan<span class="hljs-operator">/</span>下，一般为 <span class="hljs-number">0</span>0-installer-config.yaml，我的为：<br>root@lxls:<span class="hljs-operator">/</span>etc<span class="hljs-operator">/</span>netplan<span class="hljs-comment"># l</span><br><span class="hljs-number">5</span>0-cloud-init.yaml<br>用vim编辑，在文件末尾添加另一块网卡，修改为静态ip,最终修改内容：<br><br>root@lxls:<span class="hljs-operator">/</span>etc<span class="hljs-operator">/</span>netplan<span class="hljs-comment"># cat 50*</span><br><span class="hljs-params">network:</span><br>  <span class="hljs-params">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-params">ethernets:</span><br>    <span class="hljs-params">ens32:</span><br>      <span class="hljs-params">dhcp4:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#动态获取的IP地址，会自动配置网关、路由表和域名地址</span><br>    <span class="hljs-params">ens33:</span><br>      <span class="hljs-params">dhcp4:</span> no<br>      <span class="hljs-params">addresses:</span> [<span class="hljs-number">11.82</span>.<span class="hljs-number">10.99</span><span class="hljs-operator">/</span><span class="hljs-number">24</span>]      <br>      <span class="hljs-params">routes:</span><br>        <span class="hljs-operator">-</span> <span class="hljs-params">to:</span> <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span><span class="hljs-symbol">/8</span>   <span class="hljs-comment"># 目标网络</span><br>          <span class="hljs-params">via:</span> <span class="hljs-number">11.82</span>.<span class="hljs-number">10.1</span>  <span class="hljs-comment"># 下一跳地址</span><br>        <span class="hljs-operator">-</span> <span class="hljs-params">to:</span> <span class="hljs-number">11.0</span>.<span class="hljs-number">0.0</span><span class="hljs-symbol">/8</span><br>          <span class="hljs-params">via:</span> <span class="hljs-number">11.82</span>.<span class="hljs-number">10.1</span><br>      <span class="hljs-params">nameservers:</span><br>            <span class="hljs-params">addresses:</span> [<span class="hljs-number">11.3</span>.<span class="hljs-number">127.13</span> ,<span class="hljs-number">11.3</span>.<span class="hljs-number">127.12</span>]<br>              <br>注意yaml对缩进和空格要求严格              <br></code></pre></td></tr></tbody></table></figure></li><li><p>应用更改</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> netplan apply<br></code></pre></td></tr></tbody></table></figure></li><li><p>添加内网路由（临时起作用，重启后失效，想重启后仍生效参加上面：配置双网卡并设置静态路由）</p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">route add -net <span class="hljs-number">11</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">8</span> gw <span class="hljs-number">11</span>.<span class="hljs-number">82</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span> ens33<br>route add -net <span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">8</span> gw <span class="hljs-number">11</span>.<span class="hljs-number">82</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span> ens33<br><br>查看路由表：<br># route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br><span class="hljs-number">0.0.0.0</span>         <span class="hljs-number">172</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>         UG    <span class="hljs-number">100</span>    <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens32<br><span class="hljs-number">10.0.0.0</span>        <span class="hljs-number">11</span>.<span class="hljs-number">82</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span>      <span class="hljs-number">255</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>       UG    <span class="hljs-number">0</span>      <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens33<br><span class="hljs-number">11.0.0.0</span>        <span class="hljs-number">11</span>.<span class="hljs-number">82</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span>      <span class="hljs-number">255</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>       UG    <span class="hljs-number">0</span>      <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens33<br><span class="hljs-number">11.82.10.0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>         <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>   U     <span class="hljs-number">0</span>      <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens33<br><span class="hljs-number">114.114.114.114</span> <span class="hljs-number">172</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>      <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span> UGH   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens32<br><span class="hljs-number">172.18.0.0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>         <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">252</span>.<span class="hljs-number">0</span>   U     <span class="hljs-number">100</span>    <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens32<br><span class="hljs-number">172.18.0.1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>         <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span> UH    <span class="hljs-number">100</span>    <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens32<br><span class="hljs-number">222.246.129.80</span>  <span class="hljs-number">172</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>      <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span> UGH   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>        <span class="hljs-number">0</span> ens32<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除路由命令</p><figure class="highlight dos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">sudo route <span class="hljs-built_in">del</span> -<span class="hljs-built_in">net</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> dev enp0s3<br>上述指令为删除指向互联网的默认路由。将所有数据包都通过enp0s3网卡的路由删除<br></code></pre></td></tr></tbody></table></figure></li><li><p>查看主机网络连接端口</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># netstat -tunlp</span><br><span class="hljs-attribute">Active</span> Internet connections (only servers)<br><span class="hljs-attribute">Proto</span> Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name<br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0.0.53:53</span>           <span class="hljs-number">0.0.0.0</span>:*               LISTEN      <span class="hljs-number">874</span>/systemd-resolve<br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0.0.54:53</span>           <span class="hljs-number">0.0.0.0</span>:*               LISTEN      <span class="hljs-number">874</span>/systemd-resolve<br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0.0.0:22</span>              <span class="hljs-number">0.0.0.0</span>:*               LISTEN      <span class="hljs-number">1</span>/init<br><span class="hljs-attribute">tcp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0.0.1:6012</span>          <span class="hljs-number">0.0.0.0</span>:*               LISTEN      <span class="hljs-number">5645</span>/sshd: root@pts<br><span class="hljs-attribute">tcp6</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">21</span>                   :::*                    LISTEN      <span class="hljs-number">1103</span>/vsftpd<br><span class="hljs-attribute">tcp6</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">22</span>                   :::*                    LISTEN      <span class="hljs-number">1</span>/init<br><span class="hljs-attribute">tcp6</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> ::<span class="hljs-number">1</span>:<span class="hljs-number">6012</span>                :::*                    LISTEN      <span class="hljs-number">5645</span>/sshd: root@pts<br><span class="hljs-attribute">udp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0.0.54:53</span>           <span class="hljs-number">0.0.0.0</span>:*                           <span class="hljs-number">874</span>/systemd-resolve<br><span class="hljs-attribute">udp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0.0.53:53</span>           <span class="hljs-number">0.0.0.0</span>:*                           <span class="hljs-number">874</span>/systemd-resolve<br><span class="hljs-attribute">udp</span>        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">172.18.1.109:68</span>         <span class="hljs-number">0.0.0.0</span>:*                           <span class="hljs-number">789</span>/systemd-network<br><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs perl">查看磁盘使用情况：<br><span class="hljs-comment"># df -h</span><br>Filesystem                         Size  Used Avail Use% Mounted on<br>tmpfs                              <span class="hljs-number">1</span>.2G  <span class="hljs-number">1</span>.6M  <span class="hljs-number">1</span>.2G   <span class="hljs-number">1</span>% <span class="hljs-regexp">/run</span><br><span class="hljs-regexp">/d</span>ev/mapper/ubuntu--vg-ubuntu--lv   98G  <span class="hljs-number">8</span>.2G   85G   <span class="hljs-number">9</span>% <span class="hljs-regexp">/</span><br><span class="hljs-regexp">tmpfs                              5.9G     0  5.9G   0% /d</span>ev/shm<br>tmpfs                              <span class="hljs-number">5</span>.0M     <span class="hljs-number">0</span>  <span class="hljs-number">5</span>.0M   <span class="hljs-number">0</span>% <span class="hljs-regexp">/run/l</span>ock<br>/dev/sda2                          <span class="hljs-number">2</span>.0G  100M  <span class="hljs-number">1</span>.7G   <span class="hljs-number">6</span>% <span class="hljs-regexp">/boot</span><br><span class="hljs-regexp">tmpfs                              1.2G   12K  1.2G   1% /run</span><span class="hljs-regexp">/user/</span><span class="hljs-number">0</span><br>overlay                             98G  <span class="hljs-number">8</span>.2G   85G   <span class="hljs-number">9</span>% <span class="hljs-regexp">/var/li</span>b/docker/overlay2/e15fb52a77f92480871a5ea8c73b13d23ad876f4364ec10bfb85cd1695081816/merged<br><br>查看所有磁盘及分区：<br>lsblk  <span class="hljs-comment"># 列出所有块设备（硬盘、分区、逻辑卷）</span><br>NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS<br>sda                         <span class="hljs-number">8</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>  500G  <span class="hljs-number">0</span> disk<br>├─sda1                      <span class="hljs-number">8</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    1M  <span class="hljs-number">0</span> part<br>├─sda2                      <span class="hljs-number">8</span>:<span class="hljs-number">2</span>    <span class="hljs-number">0</span>    2G  <span class="hljs-number">0</span> part /boot<br>└─sda3                      <span class="hljs-number">8</span>:<span class="hljs-number">3</span>    <span class="hljs-number">0</span>  498G  <span class="hljs-number">0</span> part<br>  └─ubuntu--vg-ubuntu--lv <span class="hljs-number">252</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>  100G  <span class="hljs-number">0</span> lvm  /<br>sr0                        <span class="hljs-number">11</span>:<span class="hljs-number">0</span>    <span class="hljs-number">1</span> 1024M  <span class="hljs-number">0</span> rom<br><br><span class="hljs-comment"># 扩展逻辑卷，使用卷组中全部空闲空间</span><br>lvextend -l +<span class="hljs-number">100</span><span class="hljs-variable">%FREE</span> /dev/ubuntu-vg/ubuntu-lv<br><br><span class="hljs-comment"># 扩展文件系统，让操作系统识别新增的空间。Ubuntu 默认使用 ext4 文件系统，执行：</span><br>resize2fs /dev/ubuntu-vg/ubuntu-lv<br><span class="hljs-comment">#如果你的文件系统是 xfs（较少见，可通过 df -T / 确认），则使用 xfs_growfs / 替代</span><br><br>查看系统内核（即linux）版本：内核只有一个正统来源，那就是linus的开发团队，内核只提供操作系统的基本功能和特性，如内存管理、进度调度、文件管理等等<br>root<span class="hljs-variable">@lxls</span>:<span class="hljs-regexp">/etc/d</span>ocker<span class="hljs-comment"># uname -r</span><br><span class="hljs-number">6.8</span>.<span class="hljs-number">0</span>-<span class="hljs-number">64</span>-generic<br><br>查看ubuntu的发行版本：发行版是由不同的厂商开发、定制不同的功能<br>root<span class="hljs-variable">@lxls</span>:<span class="hljs-regexp">/etc/d</span>ocker<span class="hljs-comment"># cat /etc/lsb-release</span><br>DISTRIB_ID=Ubuntu<br>DISTRIB_RELEASE=<span class="hljs-number">24.04</span><br>DISTRIB_CODENAME=noble<br>DISTRIB_DESCRIPTION=<span class="hljs-string">"Ubuntu 24.04.2 LTS"</span><br><span class="hljs-comment">#一个完整的系统，是由liunx的内核+发行版，才组成了一个可以使用的完整的系统</span><br><br><span class="hljs-comment"># 查看进程，并过滤查看指定名称的进程</span><br>ps -ef|<span class="hljs-keyword">grep</span> nginx<br></code></pre></td></tr></tbody></table></figure><h1 id="Docker国内镜像站"><a href="#Docker国内镜像站" class="headerlink" title="Docker国内镜像站"></a>Docker国内镜像站</h1><ul><li><p>以下同一些常见的国内镜像站</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">Docker有多个国内镜像管理网站，以下是一些常见的介绍：<br><span class="hljs-number">1</span>. 毫秒镜像：官网为https:<span class="hljs-regexp">//</span>docker.<span class="hljs-number">1</span>ms.run，支持Cloudflare和境内CDN，搜索功能强大，配置简单且稳定。<br><span class="hljs-number">2</span>. 腾讯云Docker镜像源：官网是https:<span class="hljs-regexp">//mi</span>rror.ccs.tencentyun.com，仅限腾讯云服务器内访问，安全稳定。<br><span class="hljs-number">3</span>. DaoCloud官方镜像源：官网为https:<span class="hljs-regexp">//</span>docker.m.daocloud.io，依托阿里云，存在白名单和限流机制。<br><span class="hljs-number">4</span>. <span class="hljs-number">1</span>Panel镜像源：官网是https:<span class="hljs-regexp">//</span>docker.<span class="hljs-number">1</span>panel.live，有Cloudflare支持，但部分地区可能受限。<br><span class="hljs-number">5</span>. 轩辕镜像：免费版官网为https:<span class="hljs-regexp">//</span>docker.xuanyuan.me，会员版官网为https:<span class="hljs-regexp">//</span>xuanyuan.cloud，均采用Cloudflare+境内CDN，官网支持搜索镜像，配置简单，有会员解答群，屏蔽违法内容，由境内公司运营，非常稳定。<br><span class="hljs-number">6</span>. 阿里云镜像服务：官网为https:<span class="hljs-regexp">//</span>cr.console.aliyun.com，仅阿里云服务器内推荐使用。<br><span class="hljs-number">7</span>. 网易镜像源：地址为http:<span class="hljs-regexp">//</span>hub-mirror.c.<span class="hljs-number">163</span>.com，可以提供镜像加速服务。<br><span class="hljs-number">8</span>. 中国科技大学镜像站：地址是https:<span class="hljs-regexp">//</span>docker.mirrors.ustc.edu.cn，除了Docker镜像，还提供多种软件包的镜像服务，但仅供内部访问。<br><span class="hljs-number">9</span>. OpenAtom Hub：官网为https:<span class="hljs-regexp">//</span>atomhub.openatom.cn，其中的AtomHub可信镜像仓库平台包含部分基础镜像。<br></code></pre></td></tr></tbody></table></figure></li><li><p>阿里云加速器地址</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://qyef4ruk.mirror.aliyuncs.com<br>Ubuntu下操作文档，通过修改daemon配置文件/etc/docker/daemon.json来使用加速器<br><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/docker<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">'EOF'</span><br>{<br>  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://qyef4ruk.mirror.aliyuncs.com"</span>]<br>}<br>EOF<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl restart docker<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>配置了国内镜像源（比如阿里的<a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020">docker</a>镜像源）是对 docker search 没有用的，因为docker命令最后还是通过他自己的地址搜索镜像，但是配置了国内镜像源可以加快 dockere pull 拉取镜像的速度。解决方法是指定镜像源地址搜索（绕过默认 API）：</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 毫秒镜像</span><br>docker search docker<span class="hljs-number">.1</span>ms.<span class="hljs-built_in">run</span>/nginx<br><br><span class="hljs-comment"># 轩辕镜像源搜索 mysql</span><br>docker search hl1mitwelzr416b.xuanyuan.<span class="hljs-built_in">run</span>/mysql<br>docker search docker.xuanyuan.<span class="hljs-keyword">me</span>/nginx  <br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="使用Docker的优点"><a href="#使用Docker的优点" class="headerlink" title="使用Docker的优点"></a>使用Docker的优点</h1><ul><li>容器对比KVM的好处：<ul><li>容器能够提供宿主机的性能，而KVM虚拟机是分配宿主机硬件资源，性能较弱。</li><li>同样配置的宿主机，最多可以启动10个虚拟机的话，那么就可以启动100+的容器数量。</li><li>启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，或许需要20秒，而启动一个容器只需要1秒。</li><li>KVM需要硬件CPU的虚拟化支持，而容器不需要。</li><li>容器不需要进行硬件虚拟化以及运行一个完整系统的额外开销，对系统资源利用率更高。</li><li>Docker引擎容器在主机操作系统上作为一个独立的进程运行，与其它容器共享内核。</li></ul></li></ul><h1 id="Docker的安装部署"><a href="#Docker的安装部署" class="headerlink" title="Docker的安装部署"></a>Docker的安装部署</h1><ul><li><p>Docker引擎：Docker Engine是C/S架构的。</p></li><li><p>Docker Daemon（守护进程），安装使用Docker，得先运行Docker Daemon，用于管理Docker，如：</p><ul><li>镜像 images，是一个只读的系统模板，用于创建容器，类似于编程开发中面向对象的类，构建容器的过程，就是运行镜像，生成容器实例。也可以通过Dockerfile文本描述镜像内容，将你要部署项目的操作，写成一个部署脚本，且该脚本还能够构建出镜像文件，包含如下的指令。<ul><li>FROM 定义基础镜像</li><li>MAINTAINER作者</li><li>RUN 运行Linux命令</li><li>ADD 添加文件/目录</li><li>ENV 环境变量</li><li>CMD 运行进程</li></ul></li><li>容器 containers，是一个镜像运行的运行实例。你的应用程序就跑在容器中。</li><li>网络 network</li><li>数据卷 Data Volumes</li></ul></li><li><p>Rest接口：提供和Daemon交互的API接口。（Representational State Transfer Application Programming Interface，表述性状态转移应用程序接口）是一种基于 HTTP 协议设计的软件架构风格，用于实现不同系统之间的通信和数据交互。它并非严格的标准，而是一套设计原则，旨在让接口更简洁、可扩展、易于理解和维护。</p></li><li><p>Docker Client：客户端（各种命令行操作）使用 REST API 和 Docker Daemon 进行访问。</p></li><li><p>Docker平台组成：客户端、Docker主机、镜像仓库。</p><ul><li>客户端：<ol><li>基于Dockerfile构建自己的镜像</li><li>下载别人的镜像Docker pull</li><li>启动Docker容器</li></ol></li><li>Docker主机：在服务器上通过启动镜像，生成运行着的容器</li><li>镜像仓库（DockerHub）：是网络中的一个仓库，用于管理Docker的镜像Image，提供上传和下载功能，作用好比github</li></ul></li><li><p>容器创建过程：</p><ul><li>获取镜像，如 Docker pull centos ，从镜像仓库拉取</li><li>使用镜像创建容器</li><li>分配文件系统，挂载一个读写层，在读写层加载镜像</li><li>分配网络/网桥接口，创建一个网络接口，让容器和宿主机通信</li><li>容器获取IP地址</li><li>执行容器命令，如：/bin/bash</li><li>反馈容器启动结果</li></ul></li><li><p>安装Docker：提前准备好一个宿主机（用vmware去创建一个linux机器，然后安装Docker去使用）</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">1</span>. 移除旧的或错误的 Docker 源配置<br>sudo rm /etc/apt/sources.list.d/docker.list  <span class="hljs-comment"># 删除可能存在的错误配置</span><br><br><span class="hljs-number">2</span>. 添加 Docker 官方 GPG 密钥<br>curl -fsSL https:<span class="hljs-regexp">//d</span>ownload.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-number">3</span>. 添加 Docker 官方软件源<br>echo <span class="hljs-string">"deb [arch=<span class="hljs-variable">$(</span>dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu <span class="hljs-variable">$(</span>lsb_release -cs) stable"</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; <span class="hljs-regexp">/dev/null</span><br><br><span class="hljs-number">4</span>. 更新软件包索引<br>sudo apt update<br><br><span class="hljs-number">5</span>. 再次尝试安装 Docker<br>sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br><br>验证安装结果<br>sudo docker run hello-world<br><br><span class="hljs-number">6</span>. 配置 Docker 镜像加速（可选），我使用的是阿里云<br>sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">'EOF'</span><br>{<br>  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://qyef4ruk.mirror.aliyuncs.com"</span>]<br>}<br>EOF<br><br>重启 Docker 服务：<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br><br>查看 Docker 服务状态<br>sudo systemctl status docker<br><br>查看版本<br><span class="hljs-comment"># docker --version</span><br>Docker version <span class="hljs-number">28.3</span>.<span class="hljs-number">2</span>, build 578ccf6<br><br><span class="hljs-comment"># 将其它用户添加到docker组，使其它用户也能执行docker命令</span><br>usermod -aG docker lxls<br><span class="hljs-comment"># 移除一个组的用户命令，</span><br>sudo gpasswd -d lxls root<br>Removing user lxls from group root<br><span class="hljs-comment"># 查看是否还在该组内：</span><br>groups lxls<br>lxls : lxls adm cdrom sudo dip plugdev lxd docker<br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>查看docker服务信息：docker info</li></ul><p><strong>获取、查看、删除镜像</strong></p><ul><li><p>搜索镜像：docker search nginx 国内需要加上加速镜像站地址，docker search docker.1ms.run/nginx</p></li><li><p>下载镜像： docker pull nginx  下载指定版本镜像，docker pull nginx:1.26.0</p></li><li><p>查看所有镜像： docker images</p></li><li><p>删除镜像（可根据名字或id来删除）：docker  rmi  e784f4560448</p></li><li><p>批量删除多个镜像：docker rmi  ‘docker images -aq’  或者 docker rmi $(docker images -aq)</p></li><li><p>查看镜像的详细信息：docker inspect 镜像id</p></li><li><p>查看镜像的构建历史：docker history 镜像id</p></li></ul><p><strong>导出、导入镜像</strong></p><ul><li>提交变化后的容器，打包成新的镜像：docker commit -m “news message”   容器id   新的镜像名</li><li>保存镜像为tar包文件（方便传输给别人）：docker save -o mynginx.tar mynginx:v1.0</li><li>加载tar包文件成为docker镜像：docker load -i mynginx.tar</li></ul><p><strong>容器管理</strong></p><ul><li><p>创建+启动容器：docker run 镜像名，如果镜像不存在本地，则会在线去下载该镜像，这也是前台运行容器，运行时会占用一个终端屏幕，显示实时信息。</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">运行一个容器并进入容器内面：<br>docker run -it afb6fca bash<br><span class="hljs-comment">#参数解释 -i 交互式命令操作；-t 开启一个终端；afb6fca 是镜像的id；bash 进入容器后，使用的解释器</span><br><span class="hljs-comment">#重要的三个参数：-d 后台启动；-p 端口映射；--name 容器名</span><br><span class="hljs-comment">#退出容器</span><br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>查看运行中的容器：docker ps</p></li><li><p>查看所有容器（包括停止、挂掉的容器）：docker ps -a</p></li><li><p>查看容器内的进程信息：docker top 容器id</p></li><li><p>停止容器：docker stop nginx</p></li><li><p>启动容器：docker start 592</p></li><li><p>重启容器：docker restart 592</p></li><li><p>查看容器资源占用情况：docker stats 592</p></li><li><p>查看容器日志：docker logs -f  592   # -f 表示实时刷新日志</p></li><li><p>查看容器的详细信息：docker  inspect 容器id</p></li><li><p>删除指定容器：docker rm 592</p></li><li><p>强制删除指定容器（正在运行的容器）：docker rm -f 592</p></li><li><p>批量删除容器：docker rm ‘docker ps -aq’  或者 docker rm $(docker ps -aq)</p></li><li><p>后台启动容器：docker run -d –name mynginx nginx</p></li><li><p>后台启动并暴露端口：docker run -d –name mynginx -p 80:80 nginx</p></li><li><p>进入一个已经运行的容器内部（后台运行的容器）：docker exec -it myngix /bin/bash</p></li><li><p>将容器内的数据拷贝到宿主机上：docker cp 容器id:容器内目录  目的的主机路径</p></li></ul><p><strong>将镜像发布到社区，供别人pull使用：</strong></p><ul><li><p>登录docker hub：docker login  # 这里只是进入网页登录界面，后面会再提示需要输入用户名和密码</p></li><li><p>重新给镜像打标签：docker tag mynginx:v1.0 cffljx/mynginx:v1.0  #docker官方对镜像取名有格式要求</p></li><li><p>推送镜像：docker push cffljx/mynginx:v1.0</p></li></ul><h1 id="镜像分层原理"><a href="#镜像分层原理" class="headerlink" title="镜像分层原理"></a>镜像分层原理</h1><ul><li><p>Docker通过联合文件系统（union file system），将镜像不同的每一层，整合成一个文件系统，为用户隐藏了多层的视角。当通过一个image启动容器时，docker会在该image最顶层，添加一个可读写文件系统作为容器，然后运行该容器。</p></li><li><p>只读镜像，不能修改，包括：</p><ul><li>宿主机提供linux内核：boot-file system（bootfs）Linux内核，bootfs主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux启动时会加载bootfs文件系统</li><li>docker获取基础镜像：rootfs（root-file system）Linux发行版，rootfs在bootfs之上，包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同操作系统的发行版，比如ubuntu、centos等等</li><li>依赖环境1：其它镜像，如：jdk</li><li>依赖环境2：其它镜像，如tomcat</li></ul></li><li><p>容器层、可写层：如代码修改后，重启容器生效。</p><ul><li>具体的程序运行：可以写入的容器，如你想运行的代码程序</li></ul></li><li><p>镜像定义：docker镜像不包含linux内核，和宿主机共用。</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">如果我们想定义一个mysql5.<span class="hljs-number">6</span>镜像，我们需要这么做：<br><span class="hljs-number">1</span>.获取基础镜像，选择一个发行版平台（ubuntu、centos)<br><span class="hljs-number">2</span>.在基础镜像中安装mysql5.<span class="hljs-number">6</span>软件<br><span class="hljs-number">3</span>.导出镜像，命令为mysql5.<span class="hljs-number">6</span>镜像文件<br><span class="hljs-comment"># 从这个过程，我们可以感觉出这是一层一层的添加的，docker的层级概念就出来了，底层是centos镜像，上层是mysql镜像，centos镜像层属于父镜像。</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>可写的容器层：当容器启动后，一个新的可写层被加载到镜像的顶部，这一层通常被称为 容器层，容器层下的都称为 镜像层。所有对容器的修改动作，都只会发生在 容器层 里，只有 容器层 是可写的，其余  镜像层 都是只读的。</p><table><thead><tr><th>文件操作</th><th>说明（都是在容器层中进行的）</th></tr></thead><tbody><tr><td>添加文件</td><td>在容器中创建文件时，新文件被添加到容器层中</td></tr><tr><td>读取文件</td><td>在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件，一旦找到，立即将其复制到容器层，然后打开并读入内存</td></tr><tr><td>修改文件</td><td>在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件，一旦找到，立即将其复制到容器层，然后修改之</td></tr><tr><td>删除文件</td><td>在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件，找到后，会在容器层中记录下此删除操作。（只作记录删除操作）</td></tr></tbody></table><p>只有当需要修改时才会复制一份数据，这种特性被称为Copy-on-Write（写时复制特性）。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。所以镜像层都是只读的，可以被多个容器共享。</p></li></ul><h1 id="镜像定制Dockerfile"><a href="#镜像定制Dockerfile" class="headerlink" title="镜像定制Dockerfile"></a>镜像定制Dockerfile</h1><p>dockerfile相当于一个脚本，通过dockerfile自己的指令，来构建软件依赖，文件依赖、存储等等，用于构建docker镜像，部署一个用于运行你所需的容器环境。</p><p>dockerfile主要组成部分：</p><ul><li>基础镜像信息 FROM centos:6.8</li><li>制作镜像操作指令 RUN yum install opeenssh-server -y</li><li>容器启动后要执行的指令 CMD [“/bin/bash”]</li></ul><p><strong>容器能够运行，必须在容器内有一个进程在前台执行。</strong></p><p>dockerfile指令：</p><ul><li><p>FROM  这个镜像的妈妈是谁？（指定基础镜像）</p></li><li><p>MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可没有）</p></li><li><p>RUN 你想让它干什么（在命令前面加上RUN即可）</p></li><li><p>ADD 添加宿主机的文件到容器内，还多了一个自动解压功能</p></li><li><p>COPY 作用和ADD一样，都是拷贝宿主机的文件到容器内，COPY就是仅仅拷贝</p></li><li><p>WORKDIR 我是 cd ，今天刚化了妆（设置当前工作目录）</p></li><li><p>VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录）</p></li><li><p>EXPOSE 它要打开的门是啥（指定对外端口），在容器内暴露一个端口</p></li><li><p>CMD 奔跑吧，兄弟（指定容器启动后的要干的事情）</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 实例 </span><br><span class="hljs-comment"># 1.创建一个 dockerfile 文件，内容如下</span><br>FROM nginx<br>RUN echo <span class="hljs-string">'&lt;meta charse=utf-8&gt;阿布用docker运行nginx服务'</span> &gt; <span class="hljs-regexp">/usr/s</span>hare/nginx/html/index.html<br><br><span class="hljs-comment"># 2.构建dockerfile</span><br>docker build .<br><br><span class="hljs-comment"># 3.修改一下镜像名字</span><br>docker tag 镜像id cffljx/my_nginx<br><br><span class="hljs-comment"># 4.运行该镜像</span><br>docker run -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> cffljx/my_nginx<br><br><span class="hljs-comment"># 5.查看宿主机的80端口</span><br>http:<span class="hljs-regexp">//</span>宿主机IP地址<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMD ["参数1","参数2"]<br>CMD ["/bin/bash"]<br>#该容器运行时执行的命令，等同于命令行的直接操作，docker run -it centos cat /etc/os-release<br>CMD ["cat","/etc/os-release"]<br><br># 注意：docker不是虚拟机的概念，虚拟机里的程序运行，基本上都是在后台运行，利用systemctl运行，但容器内没有后台进程的概念，必须在前台运行。<br># 容器就是为了主进程而存在的，主进程退出了，容器也就失去意义，自动退出。<br>所以：CMD systemctl start nginx 写法是错误的，容器会立即退出。<br>因为 systemctl start nginx 是希望以守护进程形式启动nginx,且命令会转化为：<br>CMD ["sh","-c","systemctl start nginx"]<br>这样的命令主进程是 sh 解释器，执行完毕后立即结束了，因此容器也就退出了。<br>正确写法如下：<br>CMD ["nginx","-g","daemon off;"]<br><br>ENTRYPOINT 的作用和 CMD 一样，都是在指定容器启动程序以及参数<br>当指定了 ENTRYPOINT 之后，CMD指令的语义就有了变化，而是把CMD的内容当作参数传递给 ENTRYPOINT 指令<br>简单讲就是 docker启动命令时，如果用的是CMD指令后面再加参数，就会替换前面CMD命令和参数，而ENTRYPOINT指令的话，能加参数，与前面的参数一起工作。<br></code></pre></td></tr></tbody></table></figure></li><li><p>ARG和ENV命令：设置环境变量</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">ENV NAME=<span class="hljs-string">"cffljx"</span><br>后续所有的操作，通过 <span class="hljs-variable">$NAME</span> 就可以直接获取变量值。<br>ARG和ENV一样，设置环境变量，区别在于 ENV 无论在构建镜像时，还是容器运行，该变量都可以使用；而 ARG 只是用于构建镜像需要设置的变量，容器运行时就消失了。 <br></code></pre></td></tr></tbody></table></figure></li><li><p>VOLUME</p><p>容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载，写入到宿主机上，进行维护。这时就要用到 VOLUME 参数</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">VOLUME /data <span class="hljs-comment">#将容器内的/data文件夹，在容器运行时，该目录自动挂载为匿名卷，任何向该目录中写入数据的操作，都不会被容器记录，保证容器存储层无状态理念。</span><br><span class="hljs-comment"># Dockerfile</span><br>FROM centos<br>MAINTAINER cffljx<br>VOLUME [<span class="hljs-string">"/data1"</span>,<span class="hljs-string">"/data2"</span>]<br><span class="hljs-comment"># 该容器运行时候，这2个目录自动和宿主机的目录做好映射关系</span><br>通过命令：docker  inspect <span class="hljs-number">2018</span> 查看内面的<br><span class="hljs-string">"Mounts"</span>: [],<br>内容，就能知道挂载在宿主机的哪个地方<br></code></pre></td></tr></tbody></table></figure></li><li><p>EXPOSE ：指定容器运行时对外提供的端口服务</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker port 容器<br>docker run -p 宿主机端口:容器端口<br>docker run -P <span class="hljs-comment"># 作用是随机宿主机端口:容器内端口</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>WORKDIR：用于在dockerfile中，目录的切换，更改工作目录</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">WORKDIR　/opt<br></code></pre></td></tr></tbody></table></figure></li><li><p>USER：用于改变环境，用于切换用户</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">USER root<br>USER cffljx<br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs perl">两种方式，注意区分：<br><span class="hljs-number">1</span>.目录挂载：-v /app/nghtml:<span class="hljs-regexp">/usr/s</span>hare/nginx/html<br><span class="hljs-comment">#目录挂载是将宿主机的文件映射到容器内，容器内原来的文件消失不见，全部与外面的宿主机文件一样</span><br><span class="hljs-number">2</span>.卷映射： -v ngconfig:<span class="hljs-regexp">/etc/nginx</span><br><span class="hljs-comment">#卷映射分为具名挂载，-v 卷名:容器目录名;和匿名挂载, -v 容器目录名，匿名挂载会自动生成一个卷名</span><br><span class="hljs-comment">#卷映射是将容器内的文件映射到外面宿主机中，容器内原来的文件还在，并且外面的宿主机中也有和容器内一样的文件。同时卷 ngconfig 统一放在宿主机的 /var/lib/docker/volumes目录下面,容器/etc/nginx目录内的文件，对应在 /var/lib/docker/volumes/ngconfig/_data 目录内</span><br><span class="hljs-comment">#以上二种方法可以保证容器内的数据不会丢失,并解决了直接进到容器内，不方便修改文件数据的麻烦。</span><br>卷挂载时的文件处理规则：<br><span class="hljs-number">1</span>.宿主机目录存在，容器内目录为空。结果：宿主机目录内容会 <span class="hljs-string">"填充"</span> 到容器内挂载点<br><span class="hljs-number">2</span>.宿主机目录存在，容器内目录有内容。结果：容器内原有内容被 <span class="hljs-string">"隐藏"</span>，无法访问（但未删除）<br><span class="hljs-number">3</span>.宿主机目录不存在。结果：Docker 会自动创建该目录<br><br><span class="hljs-comment">#查看卷命令：</span><br>docker volume ls<br>DRIVER    VOLUME NAME<br><span class="hljs-keyword">local</span>     hexo_data<br><span class="hljs-keyword">local</span>     my_hexo_data<br><br><span class="hljs-comment">#创建卷：</span><br>docker volume cffljx <span class="hljs-comment">#创建了一个名为cffljx的卷，宿主机会统一放到/var/lib/docker/volumes目录下</span><br><br><span class="hljs-comment">#查看卷的详细信息：</span><br>docker volume inspect my_hexo_data<br>[<br>    {<br>        <span class="hljs-string">"CreatedAt"</span>: <span class="hljs-string">"2025-07-30T17:28:37+08:00"</span>,<br>        <span class="hljs-string">"Driver"</span>: <span class="hljs-string">"local"</span>,<br>        <span class="hljs-string">"Labels"</span>: null,<br>        <span class="hljs-string">"Mountpoint"</span>: <span class="hljs-string">"/var/lib/docker/volumes/my_hexo_data/_data"</span>,  <span class="hljs-comment">#这里是卷的位置</span><br>        <span class="hljs-string">"Name"</span>: <span class="hljs-string">"my_hexo_data"</span>,<br>        <span class="hljs-string">"Options"</span>: null,<br>        <span class="hljs-string">"Scope"</span>: <span class="hljs-string">"local"</span><br>    }<br>]<br></code></pre></td></tr></tbody></table></figure><ul><li><p>日常工作中，使用卷映射到宿主机上的目录在固定位置，不太灵活，不如使用目录挂载。但配置文件目录挂载要先做好相关准备工作，否则容器启动会失败。例如，将容器的 /etc/nginx 目录（内含配置文件）映射到宿主机，需要注意必须先确保宿主机目录包含完整的 nginx 配置文件，否则直接挂载空目录会覆盖容器内默认配置，导致 nginx 启动失败。正确操作步骤如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs assembly">1. 先在宿主机创建目录，用于存放 nginx 配置<br>mkdir -p /path/on/host/nginx  # 替换为宿主机实际路径，如 ~/nginx-config<br>2. 从 nginx 容器中复制默认配置到宿主机目录<br>先临时启动一个 nginx 容器，将容器内 /etc/nginx 的所有文件复制到宿主机目录（确保配置完整）：<br># 临时启动容器（--rm 表示退出后删除）<br>docker run --rm -d --name temp-nginx nginx<br><br># 复制容器内 /etc/nginx 所有文件到宿主机目录<br>docker cp temp-nginx:/etc/nginx/. /path/on/host/nginx/<br><br># 停止临时容器（会自动删除）<br>docker stop temp-nginx<br>此时宿主机的 /path/on/host/nginx 已包含完整的默认配置（与容器内一致）。<br><br>3. 挂载目录并启动容器<br>通过 -v 参数将宿主机目录挂载到容器的 /etc/nginx，确保配置文件完整，nginx 可正常运行：<br>用 docker run 启动：<br>docker run -d --name my-nginx -p 80:80 -v /path/on/host/nginx:/etc/nginx nginx <br># 挂载宿主机目录到容器内 /etc/nginx<br>  <br>用 Docker Compose 配置：<br>yaml<br>services:<br>  nginx:<br>    container_name: my-nginx<br>    image: nginx<br>    ports:<br>      - "80:80"<br>    volumes:<br>      - /path/on/host/nginx:/etc/nginx  # 挂载配置目录<br>    restart: always<br>    <br>关键注意事项：<br>必须先复制默认配置：<br>容器内的 /etc/nginx 包含 nginx 运行必需的配置文件（如 nginx.conf、conf.d/ 目录等），直接挂载空目录会覆盖这些文件，导致 nginx 因缺少配置而启动失败。<br>权限问题：<br>确保宿主机目录 /path/on/host/nginx 的权限允许容器内的 nginx 用户（通常是 nginx 或 www-data）访问，必要时调整权限：<br>chmod -R 755 /path/on/host/nginx  # 临时放宽权限测试<br><br>修改配置后需重启容器：<br>在宿主机修改 /path/on/host/nginx 下的配置文件后，需重启容器使配置生效：<br>docker restart my-nginx<br><br>通过以上步骤，既能将 /etc/nginx 映射到宿主机方便管理配置，又能保证 nginx 正常运行。核心是先确保宿主机目录包含完整的默认配置，再进行挂载。<br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p>当一个容器内创建了卷时，称为数据卷容器。容器之间可以通过继承关系来实现各容器之间的数据同步共享。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 实例<br># 创建一个dockerfile文件，内容如下：<br>FROM centos<br>VOLUME ["volume01","volume02"]<br>CMD echo "---end---"<br>CMD /bin/bash<br># 根据dockerfile文件创建一个镜像<br>docker build -f dockerfile -t cffljx/centos:1.0<br># 这时启动cffljx/centos:1.0镜像成容器后，这个容器内面就有二个卷：volume0和volume02<br>docker run -it --name docker01  cffljx/centos:1.0<br># 再以cffljx/centos:1.0镜像启动第二个容器，就能以继承第一个容器的卷：volume0和volume02<br>docker run -it --name docker02 --volumes-from docker01 cffljx/centos:1.0<br># 这时候就实现了容器之间的数据共享和同步，同时容器卷之间是双向拷贝同步的，一个卷删除后，其它卷的数据不会丢失<br><br># 实例二：多个mysql实现数据共享<br>docker run -d -p 3306:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345 --name mysql01 mysql:5.7<br><br>docker run -d -p 3306:3306  -e MYSQL_ROOT_PASSWORD=12345 --name mysql02 --volumes-form mysql01 mysql:5.7<br># 这个时候，也可以实现两个容器数据同步<br># 结论：容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！<br></code></pre></td></tr></tbody></table></figure><h1 id="容器启动流程"><a href="#容器启动流程" class="headerlink" title="容器启动流程"></a>容器启动流程</h1><p>docker run 启动容器的时候，docker后台操作流程是：</p><ul><li><p>检查本地是否有该镜像，没有就下载</p></li><li><p>利用镜像创建且启动一个容器</p></li><li><p>分配容器文件系统，在只读的镜像层挂载读写层</p></li><li><p>宿主机的网桥接口会分配一个虚拟接口到容器中</p></li><li><p>容器获得地址池里的ip地址</p></li><li><p>执行用户指定的程序</p></li><li><p>若程序里没有进程在运行，容器执行完毕后立即终止</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker start 可以启动一个处于 stop 状态的容器<br></code></pre></td></tr></tbody></table></figure></li></ul><p>**最佳实践：**命令+以下三项（都需要参考官方镜像的说明来进行编写）</p><ul><li>网络：需不需要将容器端口暴露在外面</li><li>存储：配置和数据持久化需要</li><li>环境变量：给容器运行需要的基本变量值</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>掌握网络机制，才能轻松构建集群。</p><ul><li><p>docker服务启动后，会生成一个docker0的网卡，地址为172.17.0.1，以后每个容器运行时docker都会分配一个172.17.0.X 的地址给容器，并加入到这个网卡的网络中。</p></li><li><p>各容器之间通过容器ip+容器端口可以互相访问。</p></li><li><p>因为各容器运行时的ip是动态变化的，我们可以通过主机域名访问的方式来访问容器。</p></li><li><p>docker0网络不支持主机域名，我们可以通过自定义网络来解决这个问题。</p></li><li><p>创建自定义网络，如 mynet ，容器名就是稳定域名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 创建自定义网络命令：<br>docker network create mynet<br>8452e1c4db05397e60fc1200e4f7e188b236e217b0f754e1f30b5057f1c90749<br><br># 查看docker网络命令：<br>docker network ls<br>NETWORK ID     NAME      DRIVER    SCOPE<br>4fa58b08a8e2   bridge    bridge    local<br>3ed18df33c8e   host      host      local<br>8452e1c4db05   mynet     bridge    local<br>bd723318f340   none      null      local<br><br># 启动二个容器加入自定义网络的：<br>docker run -d -p 80:80 --name app1 --network mynet nginx<br>docker run -d -p 80:80 --name app2 --network mynet nginx<br><br># 这时，进入到容器app1中,就可以通过容器名访问了<br>docker exec -it app1 bash<br>curl http://app2:80<br><br># 也可以直接将容器加入指定网络中，实现跨网络连通<br>docker network connect mynet 容器名<br></code></pre></td></tr></tbody></table></figure></li><li><p>实例：Redis主从同步集群</p></li><li><p>容器带来的网卡，都是一对对的，evth-pair 就是一对的虚拟设备接口，它们都是成对出现的，一段连着协议，一段彼此相连。因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的。openstac,Docker容器之间的连接，OVS的连接，都是使用 evth-pair 技术</p></li><li><p>所有的容器在不指定网络的情况下，都是 docker0 路由的，docker 会给我们的容器分配一个默认的可用IP 。</p></li><li><p>Docker 使用的是 Linux 桥接，宿主机中是一个Docker容器的网桥 docker0 ，容器间通讯都是通过docker0转接通信的，并不是直接互联。</p></li><li><p>Docker 中所有的网络接口都是虚拟的，虚拟的转发效率高。当容器删除后，对应网桥一对就没有了。</p></li><li><p>容器互联参数 –link 就是我们在hosts配置中增加了一条  ip地址  容器名  的记录，目前不建议使用了，我们推荐使用自定义网络</p></li></ul><h1 id="Compose批量管理容器工具"><a href="#Compose批量管理容器工具" class="headerlink" title="Compose批量管理容器工具"></a>Compose批量管理容器工具</h1><p>compose（创作，撰写），使用docker compose时，需要先准备一个 compose.yaml 文件，接下来将你需要启动的所有容器的配置都写入这个文件内。</p><ul><li>上线：docker compose up -d  #用在第一次创建并启动</li><li>下线：docker compose down</li><li>启动：docker compose start x1 x2 x3   # 用在之前启动过，x代表在compose.yaml中配置的应用</li><li>停止：docker compose stop x1 x2 x3   # 把这些应用停止</li><li>扩容：docker compose scale x2=3  # 把x2应用启动3份</li></ul><p><strong>compose.yaml文件语法格式</strong>：</p><ul><li>顶级元素<ul><li>name：名字，这次应用部署的名字</li><li>services：服务，需要部署的服务，服务代表将要启动的每一个应用</li><li>networks：网络，启动的应用要用到哪个网络</li><li>volumes：卷，启动的应用要用到哪些卷</li><li>configs：配置</li><li>secrets：密钥</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs assembly">name: myblog<br>services:<br>     mysql:<br>         container_name: mysql # 容器不定义名字时，ymal文件运行后会自动赋一个名字<br>         image: mysql:8.0<br>         ports:<br>          - "3306:3306"<br>         environment: # 有多列时采用 - 数组形式，只有一项可以用字典键值形式表示<br>             - MYSQL_ROOT_PASSWORD=123456<br>             - MYSQL_DATABASE=wordpress<br>         volumes:<br>             - mysql-data:/var/lib/mysql #卷挂载方式挂载数据文件<br>             - /app/myconf:/etc/mysql/conf.d #目录挂载方式挂载配置文件<br>         restart: always # 总是会自动重启<br>         networks:<br>          - blog<br>     wordpress:<br>         image: wordpress<br>         ports:<br>          - "8080:80"<br>         environment:<br>         WORDPRESS_DB_HOST: mysql<br>         WORDPRESS_DB_USER: root<br>         WORDPRESS_DB_PASSWORD: 123456<br>         WORDPRESS_DB_NAME: wordpress<br>         volumes:<br>          - wordpress:/var/www/html<br>         restart: always<br>         networks:<br>          - blog<br>         depends_on: # 依赖关系，会先启动<br>          - mysql<br>volumes: #services中用到的卷都要在这里声明<br>     mysql-data:<br>     wordpress:<br>networks: #services中用到的网络都要在这里声明<br>   blog:<br></code></pre></td></tr></tbody></table></figure><ul><li>启动：docker compose -f compose.yaml up -d  # 如果文件是compose.yaml默认名字，可以省略参数  -f compose.yaml  直接写成  docker compose up -d</li><li>启动后，如果修改了yaml文件内容，再次运行时只会重新开始修改后的容器，原来正常运行的容器不会变。</li><li>停止：docker compose -f compose.yaml -down ，会移除容器和网络，但卷不会移除，下次启动挂载后数据还在。</li><li>如果要移除卷，用命令：docker compose -f compose.yaml down  -v</li><li>查看错误：docker logs 容器的名字</li></ul><h1 id="Dockerfile构建自定义镜像"><a href="#Dockerfile构建自定义镜像" class="headerlink" title="Dockerfile构建自定义镜像"></a>Dockerfile构建自定义镜像</h1><p>将自己的应用打包制作成镜像，就要用到 dockerfile ，常见指令如下：</p><ul><li><p>FROM  指定镜像基础环境</p></li><li><p>RUN  运行自定义命令</p></li><li><p>CMD  容器启动命令或参数</p></li><li><p>LABEL  自定义标签</p></li><li><p>EXPOSE  指定暴露端口</p></li><li><p>ENV  环境变量</p></li><li><p>ADD  添加文件到镜像</p></li><li><p>COPY 复制文件到镜像</p></li><li><p>ENTRYPOINT 容器固定启动命令</p></li><li><p>VOLUME 数据卷</p></li><li><p>USER  指定用户和用户组</p></li><li><p>WORKDIR  指定默认工作目录</p></li><li><p>ARG  指定构建参数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#构建实例一般分4步<br># 1.编写dockerfile文件，添加以下指令<br>FROM openjdk:17<br>LABEL author=cffljx<br>COPY app.jar /app.jar<br>EXPOSE 8080<br>ENTRYPOINT ["java","-jar","/app.jar"]<br><br>#2.docker build 构建成为一个镜像，下面命令中，-t 表示tag镜像名，最后的 . 确定构建时的层级不能省略。<br>docker build -f dockerfile -t myjavapp:v1.0 .<br><br># 3.docker run 运行镜像<br><br># 4.docer push 发布镜像到 DockerHub等仓库，供别人下载使用<br><br># 实例测试：创建一个自己的centos<br># Docker Hub中99%镜像都是从这个基础镜像过来的 FROM scratch ，然后配置需要的软件和配置来进行构建<br># 1.编写一个文件:mydockerfile-centos<br>FROM　centos<br>MAINTAINER cffljx&lt;cffljx@126.com&gt;<br><br>ENV MYPATH /usr/local<br>WORKDIR $MYPATH<br><br>RUN yum -y install vim<br>RUN yum -y install net-tools<br><br>EXPOSE 80<br><br>CMD echo $MYPATH<br>CMD echo "---end---"<br>CMD /bin/bash<br><br># 2.通过这个文件构建镜像<br>docker build -f mydockerfile-centos -t mycentos:0.1 .<br><br># 3.测试运行<br>docker run -it mycentos:0.1<br></code></pre></td></tr></tbody></table></figure></li></ul><p><strong>我们拿到一个镜像，可以通过 docker history 镜像id 来学习它是怎样构建的</strong></p><ul><li>docker history --no-trunc --format "table {{.CreatedBy}}" ff20900769a2 </li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/03/hello-world/"/>
    <url>/2025/08/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2025/08/03/git/"/>
    <url>/2025/08/03/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git简述"><a href="#git简述" class="headerlink" title="git简述"></a>git简述</h1><ul><li>2005年，开源项目Linux创始人Linus为了将代码放到版本控制系统内面，花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</li><li>Git是分布式的版本控制系统，分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li><li>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li></ul><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><ul><li><p>在Linux上安装Git:如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt install git就可以直接完成Git的安装，非常简单。</p></li><li><p>在Windows上使用Git，也有两种安装方法。第一种是直接从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功。第二种是先安装一个包管理器，推荐Scoop，然后在PowerShell中通过以下命令安装Git：C:&gt; scoop install git,安装完成后，在PowerShell下运行命令git -v显示Git版本.使用包管理器安装Git只需一条命令，且升级非常方便。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debian/Ubuntu Linux的APT、macOS的Homebrew、Windows的Scoop在命令行下的安装、升级、卸载命令都是类似的，例如，升级Git，三种包管理器对应的命令分别是：</span><br><span class="line">sudo apt update git</span><br><span class="line">brew update git</span><br><span class="line">scoop update git</span><br><span class="line">可以说熟悉一种包管理器的用法后，在其他平台也可迅速上手，推荐使用。</span><br></pre></td></tr></tbody></table></figure></li><li><p>配置Git:安装好Git后，还需要最后一步设置，在命令行输入：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global user.name "Your Name"</span><br><span class="line"><span class="built_in">$</span> git config --global user.email "email@example.com"</span><br><span class="line"><span class="params">#</span>注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</span><br></pre></td></tr></tbody></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p></li></ul><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><ul><li><p>版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一步：选择一个合适的地方，创建一个空目录：</span><br><span class="line"><span class="built_in">$</span> mkdir learngit</span><br><span class="line"><span class="built_in">$</span> cd learngit</span><br><span class="line"><span class="built_in">$</span> pwd</span><br><span class="line">/Users/michael/learngit</span><br><span class="line">第二步：通过git init命令把这个目录变成Git可以管理的仓库：</span><br><span class="line"><span class="built_in">$</span> git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br><span class="line">瞬间Git就把仓库建好了，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</span><br><span class="line"></span><br><span class="line">在 Git 中，“删除仓库” 通常有两种场景：删除本地仓库和删除远程仓库。两者的操作方式完全不同，具体如下：</span><br><span class="line">一、删除本地仓库（保留远程仓库）</span><br><span class="line">如果你只是想删除本地计算机上的 Git 仓库，但保留 GitHub/Gitee 等远程服务器上的仓库，有两种方法：</span><br><span class="line">方法 1：直接删除仓库文件夹</span><br><span class="line">这是最简单的方法，直接删除包含 .git 隐藏文件夹的项目目录。</span><br><span class="line">方法 2：清除 Git 版本控制（保留文件但不再是 Git 仓库）</span><br><span class="line">如果你想保留项目文件，但不再使用 Git 进行版本控制，可以删除项目中的 .git 目录</span><br><span class="line">二、删除远程仓库（彻底删除）</span><br><span class="line">如果你想删除 GitHub/Gitee 等平台上的远程仓库（此操作不可逆，会永久丢失数据），需通过平台的网页界面操作</span><br><span class="line">注意事项</span><br><span class="line">删除远程仓库是不可逆操作，所有代码和提交历史将永久丢失，建议提前备份。</span><br><span class="line">删除本地仓库后，若想重新获取代码，可通过 git clone 从远程仓库拉取。</span><br><span class="line">删除远程仓库前，确保团队成员已同步最新代码，避免数据丢失。</span><br><span class="line">根据你的实际需求选择合适的删除方式即可。</span><br></pre></td></tr></tbody></table></figure></li><li><p>把文件添加到版本库：</p><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">现在我们编写一个readme.txt文件，一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。再把这个文件放到Git仓库只需要两步。</span><br><span class="line">第一步，用命令git add告诉Git，把文件添加到仓库：</span><br><span class="line"><span class="built_in">$</span> git add readme.txt</span><br><span class="line">第二步，用命令git commit告诉Git，把文件提交到仓库：</span><br><span class="line"><span class="built_in">$</span> git commit -m "wrote a readme file"</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line">简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</span><br><span class="line">嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</span><br><span class="line">为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件</span><br><span class="line">小结</span><br><span class="line">现在总结一下今天学的两点内容：</span><br><span class="line">初始化一个Git仓库，使用git init命令。</span><br><span class="line">添加文件到Git仓库，分两步：</span><br><span class="line">使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；</span><br><span class="line">使用命令git commit -m &lt;message&gt;，完成。</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul><li><p>要随时掌握工作区的状态，使用git status命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li><li><p>在Git中，我们用git log命令查看历史记录，显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上  –pretty=oneline  参数。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br><span class="line">你看到的一大串类似1094adb...的是commit id（版本号）是一个SHA1计算出来的一个非常大的数字，用十六进制表示</span><br><span class="line">回退到上一个版本,首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD<span class="built_in">^</span>，上上一个版本就是HEAD<span class="built_in">^</span><span class="built_in">^</span>，当然往上100个版本写100个<span class="built_in">^</span>比较容易数不过来，所以写成HEAD~100。</span><br><span class="line">现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</span><br><span class="line"><span class="built_in">$</span> git reset --hard HEAD<span class="built_in">^</span></span><br><span class="line">HEAD is now at e475afc add distributed</span><br><span class="line"></span><br><span class="line">--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。</span><br><span class="line">让我们用git log再看看现在版本库的状态：</span><br><span class="line"><span class="built_in">$</span> git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br><span class="line">最新的那个版本append GPL已经看不到了，好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，怎么办？办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：</span><br><span class="line"><span class="built_in">$</span> git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br><span class="line"></span><br><span class="line">版本号没必要写全，前几位就可以了，Git会自动去找。</span><br><span class="line">Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL</span><br><span class="line">如果关掉了窗口或电脑的话，用以下命令显示用来记录你的每一次命令，从而找到你的commit id</span><br><span class="line"><span class="built_in">$</span> git reflog</span><br><span class="line">e475afc HEAD@{1}: reset: moving to HEAD<span class="built_in">^</span></span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL</span><br><span class="line">e475afc HEAD@{3}: commit: add distributed</span><br><span class="line">eaadf4e HEAD@{4}: commit (initial): wrote a readme file</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">现在总结一下：</span><br><span class="line">HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit<span class="built_in">_</span>id。</span><br><span class="line">穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><ul><li>工作区（Working Directory），就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。</li><li>版本库（Repository），工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li><li>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</li><li>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</li><li>小结：暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</li></ul><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><ul><li>Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</li><li>我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</li><li>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit，现在，把第二次修改提交了</li><li>小结：现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。</li></ul><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul><li><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p></li><li><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p></li><li><p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</file></p></li><li><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p></li><li><p>小结</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</file></p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p></li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul><li>在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了，现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit；另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout – test.txt，<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li><li>从来没有被添加到版本库就被删除的文件，是无法恢复的！</li><li>小结<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li><p>有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p></li><li><p>你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1步：创建SSH Key.在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</span><br><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br><span class="line">如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</span><br><span class="line">第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容,点“Add Key”，你就应该看到已经添加的Key</span><br><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</span><br></pre></td></tr></tbody></table></figure></li><li><p>在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。</p></li></ul><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul><li><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p></li><li><p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在本地的learngit仓库下运行命令：</span><br><span class="line">$ git remote add origin git@github.com:cffljx@126.com/learngit.git</span><br><span class="line">说明：cffljx@126.com是你自己的GitHub账户名；origin是远程库的名字，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</span><br><span class="line">下一步，就可以把本地库的所有内容推送到远程库上：</span><br><span class="line">$ git push -u origin master</span><br><span class="line">把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line">推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样</span><br><span class="line">从现在起，只要本地作了提交，就可以通过命令：</span><br><span class="line">$ git push origin master</span><br><span class="line">把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除远程库：如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm <name>命令。使用前，建议先用git remote -v查看远程库信息：</name></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br><span class="line">然后，根据名字删除，比如删除origin：</span><br><span class="line">$ git remote rm origin</span><br><span class="line">此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</span><br></pre></td></tr></tbody></table></figure></li><li><p>小结<br>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p></li></ul><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul><li><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。用命令git clone克隆一个本地库：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into 'gitskills'...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line">注意把Git库的地址换成你自己的,如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</span><br></pre></td></tr></tbody></table></figure></li><li><p>GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8CGit%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8ssh%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8https%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82%E4%BD%BF%E7%94%A8https%E9%99%A4%E4%BA%86%E9%80%9F%E5%BA%A6%E6%85%A2%E4%BB%A5%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E9%BA%BB%E7%83%A6%E6%98%AF%E6%AF%8F%E6%AC%A1%E6%8E%A8%E9%80%81%E9%83%BD%E5%BF%85%E9%A1%BB%E8%BE%93%E5%85%A5%E5%8F%A3%E4%BB%A4%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%8F%AA%E5%BC%80%E6%94%BEhttp%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8ssh%E5%8D%8F%E8%AE%AE%E8%80%8C%E5%8F%AA%E8%83%BD%E7%94%A8https%E3%80%82">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</a></p></li><li><p>小结<br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p><p>Git支持多种协议，包括https，但ssh协议速度最快。</p></li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</li></ul><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ul><li><p>在版本回退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p></li><li><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">                 master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘</span><br></pre></td></tr></tbody></table></figure></li><li><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘</span><br><span class="line">                    ▲</span><br><span class="line">                    │</span><br><span class="line">                   dev</span><br><span class="line">                    ▲</span><br><span class="line">                    │</span><br><span class="line">                  HEAD</span><br></pre></td></tr></tbody></table></figure></li><li><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><pre><code>                master                    │                    ▼┌───┐    ┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │───▶│   │└───┘    └───┘    └───┘    └───┘                             ▲                             │                            dev                             ▲                             │                           HEAD          </code></pre></li><li><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                           HEAD</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">                          master</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br><span class="line">                             ▲</span><br><span class="line">                             │</span><br><span class="line">                            dev</span><br></pre></td></tr></tbody></table></figure></li><li><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                           HEAD</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">                          master</span><br><span class="line">                             │</span><br><span class="line">                             ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br></pre></td></tr></tbody></table></figure></li><li><p>下面开始实战。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line">git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch 'dev'</span><br><span class="line">然后，用git branch命令查看当前分支：</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line">然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</span><br><span class="line">Creating a new branch is quick.</span><br><span class="line">然后提交：</span><br><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m "branch test"</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">现在，dev分支的工作完成，我们就可以切换回master分支：</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</span><br><span class="line">                  HEAD</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">                 master</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">┌───┐    ┌───┐    ┌───┐    ┌───┐</span><br><span class="line">│   │───▶│   │───▶│   │───▶│   │</span><br><span class="line">└───┘    └───┘    └───┘    └───┘</span><br><span class="line">                             ▲</span><br><span class="line">                             │</span><br><span class="line">                            dev</span><br><span class="line">现在，我们把dev分支的工作成果合并到master分支上：</span><br><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</span><br><span class="line">合并完成后，就可以放心地删除dev分支了：</span><br><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br><span class="line">删除后，查看branch，就只剩下master分支了：</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</span><br></pre></td></tr></tbody></table></figure></li><li><p>switch:我们注意到切换分支使用git checkout <branch>，而前面讲过的撤销修改则是git checkout – <file>，同一个命令，有两种作用，确实有点令人迷惑。实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：</file></branch></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建并切换到新的`dev`分支，可以使用：</span><br><span class="line">$ git switch -c dev</span><br><span class="line">直接切换到已有的master分支，可以使用：</span><br><span class="line">$ git switch master</span><br><span class="line">使用新的git switch命令，比git checkout要更容易理解。</span><br></pre></td></tr></tbody></table></figure></li><li><p>小结<br>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch <name></name></p><p>切换分支：git checkout <name>或者git switch <name></name></name></p><p>创建+切换分支：git checkout -b <name>或者git switch -c <name></name></name></p><p>合并某分支到当前分支：git merge <name></name></p><p>删除分支：git branch -d <name></name></p></li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ul><li><p>小结<br>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用git log –graph命令可以看到分支合并图。</p></li></ul><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul><li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p></li><li><p>小结<br>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p></li></ul><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ul><li><p>在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p></li><li><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p></li><li><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug</p></li><li><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p></li><li><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交</p></li><li><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支</p></li><li><p>现在，是时候接着回到dev分支干活了</p></li><li><p>小结<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</commit></p></li></ul><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><ul><li><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p></li><li><p>小结<br>开发一个新功能，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p></li></ul><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ul><li><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要查看远程库的详细信息，用git remote -v：</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br><span class="line">上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</span><br></pre></td></tr></tbody></table></figure></li><li><p>推送分支<br>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">如果要推送其他分支，比如dev，就改成：</span><br><span class="line">$ git push origin dev</span><br><span class="line">但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</span><br><span class="line">master分支是主分支，因此要时刻与远程同步；</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</span><br><span class="line">bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</span><br><span class="line">feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</span><br><span class="line">总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</span><br></pre></td></tr></tbody></table></figure></li><li><p>抓取分支：多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，推送就会失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p></li><li><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以尝试用git push origin <branch-name>推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；<br>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！<br>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></branch-name></branch-name></p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p></li><li><p>小结<br>查看远程库信息，使用git remote -v；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；<br>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><ul><li>Git有一种称为<code>rebase</code>的操作，有人把它翻译成“变基”。把分叉的提交变成直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</li><li>小结<br>rebase操作可以把本地未push的分叉提交历史整理成直线；<br>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>标签也是版本库的一个快照，其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><ul><li><p>创建标签：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在Git中打标签非常简单，首先，切换到需要打标签的分支上：</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">然后，敲命令git tag &lt;name&gt;就可以打一个新标签：</span><br><span class="line">$ git tag v1.0</span><br><span class="line">可以用命令git tag查看所有标签：</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了</span><br><span class="line">标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</span><br><span class="line">小结</span><br><span class="line">命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；</span><br><span class="line">命令git tag -a &lt;tagname&gt; -m "blablabla..."可以指定标签信息；</span><br><span class="line">命令git tag可以查看所有标签。</span><br></pre></td></tr></tbody></table></figure></li><li><p>操作标签</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小结</span><br><span class="line">命令git push origin &lt;tagname&gt;可以推送一个本地标签；</span><br><span class="line">命令git push origin --tags可以推送全部未推送过的本地标签；</span><br><span class="line">命令git tag -d &lt;tagname&gt;可以删除一个本地标签；</span><br><span class="line">命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</span><br><span class="line">git clone git@github.com:path/bootstrap.git</span><br></pre></td></tr></tbody></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</span><br><span class="line"></span><br><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────▶│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br><span class="line">如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</span><br><span class="line">如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</span><br></pre></td></tr></tbody></table></figure><p>小结<br>在GitHub上，可以任意Fork开源仓库；<br>自己拥有Fork后的仓库的读写权限；<br>可以推送pull request给官方仓库来贡献代码。</p><h1 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h1><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）</p><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“设置”，然后在左侧菜单选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：点击“确定”即可完成并看到刚才添加的Key</p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">首先，我们在Gitee上创建一个新的项目，选择右上角用户头像旁的加号，然后点击“新建仓库”：</span><br><span class="line">项目名称最好与本地库保持一致。</span><br><span class="line">然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联：</span><br><span class="line"><span class="built_in">$</span> git remote add origin git@gitee.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">之后，就可以正常地用git push和git pull推送了！</span><br><span class="line">如果在使用命令git remote add时报错：</span><br><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br><span class="line">这说明本地库已经关联了一个名叫origin的远程库,我们可以删除已有的GitHub远程库：</span><br><span class="line">git remote rm origin</span><br><span class="line">再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</span><br><span class="line"><span class="built_in">$</span> git remote add origin git@gitee.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。</span><br><span class="line">使用多个远程库时，即一个本地库既关联GitHub，又关联Gitee时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</span><br><span class="line"><span class="built_in">$</span> git remote add github git@github.com:path/learngit.git</span><br><span class="line"></span><br><span class="line">远程库的名称叫github，不叫origin了。</span><br><span class="line"><span class="built_in">$</span> git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line"></span><br><span class="line">远程库的名称叫gitee，不叫origin。</span><br><span class="line">如果要推送到GitHub，使用命令：</span><br><span class="line">git push github master</span><br><span class="line">如果要推送到Gitee，使用命令：</span><br><span class="line">git push gitee master</span><br><span class="line">这样一来，我们的本地库就可以同时与多个远程库互相同步：</span><br><span class="line"></span><br><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     │           │</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></tbody></table></figure><p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAyour-gitee-id.txt%E7%9A%84%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%99%E7%82%B9%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E5%BF%83%E5%BE%97%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8E%A8%E9%80%81%E4%B8%80%E4%B8%AApull">https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，这个仓库会在Gitee和GitHub做双向同步。</p><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><p>在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。</p><ul><li><p>忽略特殊文件：有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等。这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.gitignore文件本身应该提交给Git管理，这样可以确保所有人在同一项目下都使用相同的.gitignore文件。</span><br><span class="line">不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：GitHub/gitignore</span><br><span class="line">忽略文件的原则是：</span><br><span class="line">忽略操作系统自动生成的文件，比如缩略图等；</span><br><span class="line">忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</span><br><span class="line">忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</span><br><span class="line">把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。</span><br><span class="line">.gitignore文件放哪？答案是放Git仓库根目录下，但其实一个Git仓库也可以有多个.gitignore文件，.gitignore文件放在哪个目录下，就对哪个目录（包括子目录）起作用。</span><br><span class="line">myproject          &lt;- Git仓库根目录</span><br><span class="line">├── .gitigore      &lt;- 针对整个仓库生效的.gitignore</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── docs</span><br><span class="line">│   └── .gitigore  &lt;- 仅针对docs目录生效的.gitignore</span><br><span class="line">└── source</span><br><span class="line">小结</span><br><span class="line">忽略某些文件时，需要编写.gitignore；</span><br><span class="line">.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</span><br></pre></td></tr></tbody></table></figure></li><li><p>配置别名：我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global alias.st status</span><br><span class="line">--global 参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</span><br></pre></td></tr></tbody></table></figure><p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> git config --global alias.unstage 'reset HEAD'</span><br><span class="line">当你敲入命令：</span><br><span class="line"><span class="built_in">$</span> git unstage test.py</span><br><span class="line">实际上Git执行的是：</span><br><span class="line"><span class="built_in">$</span> git reset HEAD test.py</span><br></pre></td></tr></tbody></table></figure><p>配置文件:配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote "origin"]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br><span class="line">别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</span><br></pre></td></tr></tbody></table></figure><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></tbody></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置，或者直接删掉配置文件错误的那一行。</p><p>小结<br>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p></li><li><p>搭建Git服务器：搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第一步，安装git：</span><br><span class="line">$ sudo apt install git</span><br><span class="line">第二步，创建一个git用户，用来运行git服务：</span><br><span class="line">$ sudo adduser git</span><br><span class="line">第三步，创建证书登录：</span><br><span class="line">收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</span><br><span class="line">第四步，初始化Git仓库：</span><br><span class="line">先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</span><br><span class="line">$ sudo git init --bare sample.git</span><br><span class="line">Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</span><br><span class="line">$ sudo chown -R git:git sample.git</span><br><span class="line">第五步，禁用shell登录：</span><br><span class="line">出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</span><br><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br><span class="line">改为：</span><br><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br><span class="line">这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</span><br><span class="line">第六步，克隆远程仓库：</span><br><span class="line">现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</span><br><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into 'sample'...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">剩下的推送就简单了。</span><br></pre></td></tr></tbody></table></figure><p>小结<br>搭建Git服务器非常简单，通常10分钟即可完成；<br>要方便管理公钥，用Gitosis；<br>要像SVN那样变态地控制权限，用Gitolite。</p></li></ul><h1 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h1><p>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</p><p>首先从官网下载SourceTree并安装，然后直接运行SourceTree。</p><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p><p>提交<br>我们双击learngit这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了git add README.md命令：然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：实际上是执行了git commit -m “update README.md”命令。</p><p>分支<br>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如master，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令git checkout master：要合并分支，同样选择待合并分支，例如dev，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令git merge dev：</p><p>推送<br>在SourceTree的工具栏上，分别有Pull和Push，分别对应命令git pull和git push，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p><p>小结<br>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>在一个目录CMD窗口下，输入：git init 命令，将实现初始化所在的目录，该目录又称为工作区，下会有一个隐藏的.git目录，它就是 Git 本地仓库的核心，称为版本库。.git 目录下的 Index 文件，用来临时存储代码，称为暂存区或索引区。删除目录相当于删除了整个仓库，只删除.git目录相当于git就不能进行本地仓库的版本控制功能。</p></li><li><p>git status 查看一下状态，终端显示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">nothing to commit (create/copy files and use "git add" to track) // 暂存区没有什么可提交的</span><br></pre></td></tr></tbody></table></figure></li><li><p>新建 index.txt 文件，然后 git status 查看一下状态，终端显示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master  // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">Untracked files: // 工作区中还没有被跟踪的文件，也就是还没有被 add 的文件，add 之后将会进入暂存区</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line">        index.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track) // 暂存区没有任何提交，但是工作区存在没有被跟踪的文件</span><br></pre></td></tr></tbody></table></figure></li><li><p>git add index.txt 将 index.txt add 到暂存区，然后 git status 查看一下状态，终端显示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master  // 当前为 master 分支</span><br><span class="line">No commits yet // 本地仓库还没有任何提交</span><br><span class="line">Changes to be committed: // 暂存区将要被提交的修改，也就是已经从工作区 add 到暂存区中的文件，commit 之后将进入本地仓库</span><br><span class="line">  (use "git rm --cached &lt;file&gt;..." to unstage)  // 使用 ”git rm --cached &lt;file&gt;“ 将从暂存区删除并取消跟踪文件，恢复到 add 之前的状态</span><br><span class="line">        new file:   index.txt</span><br></pre></td></tr></tbody></table></figure></li><li><p>git commit -m ‘commt index.txt’ 将 index.txt 提交到本地仓库，然后 git status 查看一下状态，终端显示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master // 当前为 master 分支</span><br><span class="line">nothing to commit, working tree clean  // 暂存区没有什么可提交的，工作区的树也是干净的</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行 git log 查看当前分支 commit 提交的历史记录， 终端显示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) // 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 哈希值为当次提交的 commit id 校验和</span><br><span class="line">Author: test &lt;test@&gt;</span><br><span class="line">Date:   Thu Sep 30 16:22:22 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit:index.txt</span><br><span class="line"></span><br><span class="line">commit bbeac607be274343dc74099887b9cee40e50d3a3</span><br><span class="line">Author: test &lt;test@&gt;</span><br><span class="line">Date:   Thu Sep 30 11:13:15 2021 +0800</span><br><span class="line">BAN</span><br><span class="line">    first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git log --pretty=oneline，来让每一条日志只显示一行，更加简洁</span><br><span class="line">7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) second commit:idex.txt</span><br><span class="line">bbeac607be274343dc74099887b9cee40e50d3a3 first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git log --oneline，不仅可以让每一条日志只显示一行，而且缩短了哈希值，更加简洁</span><br><span class="line">7d32b40 (HEAD -&gt; master) second commit:idex.txt</span><br><span class="line">bbeac60 first commit:index.txt</span><br><span class="line"></span><br><span class="line">// 或者使用 git reflog</span><br><span class="line">7d32b40 (HEAD -&gt; master) HEAD@{0}: commit: second commit:idex.txt</span><br><span class="line">bbeac60 HEAD@{1}: commit (initial): first commit:index.txt  //  HEAD@{1} 表示移动到当前版本需要1步</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加远程仓库：git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:cffljx/ljx.git，gitee是远程仓库的名字。</p></li><li><p>使用ssh与远程仓库通讯前，需要作如下配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">在C:\Users\Administrator\.ssh目录下，生成密钥对：</span><br><span class="line">ssh-keygen -t ed25519 -C "cffljx@126.com" -f "$HOME/.ssh/id_ed25519"</span><br><span class="line"># 按提示设置密码（或直接回车跳过）</span><br><span class="line"></span><br><span class="line">在.ssh目录下，新建config和known_hosts文件</span><br><span class="line"></span><br><span class="line">config文件内容</span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile C:/Users/Administrator/.ssh/id_ed25519  # 使用 Windows 绝对路径</span><br><span class="line">    StrictHostKeyChecking no  # 临时禁用主机密钥检查（提高安全性建议设置为 ask）</span><br><span class="line"></span><br><span class="line">known_hosts文件内容：</span><br><span class="line">gitee.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5zTjR8iJbPZ+01ZJ146GQJ3v6xq3dC6pX0d5i+hVY=</span><br><span class="line">注意：ssh-后面的内容，换成你前面生成的公钥的内容。</span><br><span class="line"></span><br><span class="line">在远程仓库中将本地公钥填写进去</span><br><span class="line">验证连通性：</span><br><span class="line">D:\vscode\ljxgit&gt;ssh git@gitee.com</span><br><span class="line">Hi cffljx(@cffljx)! You've successfully authenticated, but GITEE.COM does not provide shell access.</span><br><span class="line">Connection to gitee.com closed.</span><br><span class="line">首次连接远程服务器时，系统会提示确认并自动添加：输入 yes 后，公钥会自动写入 known_hosts</span><br><span class="line"></span><br><span class="line">将文件推向远程仓库前，需要与远程仓库先同步：</span><br><span class="line">D:\vscode\ljxgit&gt;git pull --rebase gitee master</span><br><span class="line">remote: Enumerating objects: 18, done.</span><br><span class="line">remote: Counting objects: 100% (1/1), done.</span><br><span class="line">remote: Total 18 (delta 0), reused 0 (delta 0), pack-reused 17 (from 1)</span><br><span class="line">Unpacking objects: 100% (18/18), 5.49 KiB | 151.00 KiB/s, done.</span><br><span class="line">From gitee.com:cffljx/ljx</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; gitee/master</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br><span class="line"></span><br><span class="line">然后就可以将提交到本地仓库的内容推送到远程仓库中去，实现代码版本托管功能：</span><br><span class="line">D:\vscode\ljxgit&gt;git push -u gitee master</span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4/4), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 514 bytes | 514.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)</span><br><span class="line">remote: Powered by GITEE.COM [1.1.5]</span><br><span class="line">remote: Set trace flag a1441aaa</span><br><span class="line">To gitee.com:cffljx/ljx.git</span><br><span class="line">   edac3c2..006c899  master -&gt; master</span><br><span class="line">branch 'master' set up to track 'gitee/master'.</span><br></pre></td></tr></tbody></table></figure></li><li><p>当然，你也可以用HTTPS协议与远程仓库通讯，只是推送时会提示输入用户名和密码，比较烦锁：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改远程仓库 URL</span><br><span class="line">git remote set-url gitee https://gitee.com/cffljx/ljx.git</span><br><span class="line"></span><br><span class="line"># 推送（会提示输入 Gitee 用户名和密码/令牌）</span><br><span class="line">git push gitee master</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫学习</title>
    <link href="/2025/08/03/Python/"/>
    <url>/2025/08/03/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python爬虫知识"><a href="#Python爬虫知识" class="headerlink" title="Python爬虫知识"></a>Python爬虫知识</h1><ul><li>学好爬虫需要的知识：</li><li><ul><li>计算机网络协议（http/https协议，tcp/ip协议，socket编程）</li><li>前端基础</li><li>正则表达式</li><li>数据存储技术（分布式存储）</li><li>并发处理技术（多线程，多进程，线程池，协程）</li><li>图像识别（处理反爬、验证码），机器学习算法（验证法、数据解析）</li></ul></li><li>爬虫要解决的问题：</li><li><ul><li>爬虫的采集和更新策略</li><li>解决反爬</li><li>数据解析</li><li>数据存储</li><li>模拟登录（验证码识别）</li><li>爬虫的监督和部署</li><li>数据的去重（url去重，内容去重）</li></ul></li></ul><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul><li><p>变量：可以发生改变的一个量，变量是用来区分不同数据的，可以指向一个内存空间，帮我们存储一些数据。</p></li><li><p>变量命名规范：</p></li><li><ol><li>必须是数字或字母或下划线组成。</li><li>不能以数字开头，更不能是纯数字。</li><li>不能用python关键字。</li><li>不要用中文</li><li>要有意义</li><li>推荐使用下划线或者驼峰命名。</li></ol></li><li><p>常量：可以把所有的变量的字母变成大写就可以认为是常量。</p></li><li><p>不存在绝对意义的常量。</p></li></ul><h2 id="简单认识数据类型"><a href="#简单认识数据类型" class="headerlink" title="简单认识数据类型"></a>简单认识数据类型</h2><ul><li><p>数据类型：区分不同的数据，不同的数据类型应该有不同的操作。</p></li><li><p>数字：+-*/</p><pre><code class="hljs">整数，int</code></pre><p>​    小数，float</p></li><li><p>文字：展示</p><p>​    字符串：str（重点掌握）</p><p>​    表示 方式：’ ‘，” “，’’’ ‘’’，””” “””</p><p>​    操作：+ ：左右两端必须是字符串，表示字符串连接操作。</p><p>​           * ：一个字符串只能乘以一个数字，表示字符串重复次数。    </p></li><li><p>布尔：条件判断，主要有二个值：True 表示真 和 Flase 表示假</p><p>​    布尔运算符中，非0的数值类型表示True，0表示Flase；其它类型中，非空值表示True，空值表示Flase</p></li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li><p>1、if 条件:</p><p>​        代码</p><p>​    如果条件成立就执行代码，如果不成立，就不执行。</p><p>2、if 条件</p><p>​       代码1</p><p>​      else</p><p>​        代码2</p><p>​    如果条件成立，执行代码1，不成立执行代码2</p><p>3、if语句可以互相嵌套。</p><p>​        if 条件</p><p>​            if ….:</p><p>​            else:</p><p>​        else:</p><p>​            代码2</p><p>4、 if  条件1:</p><p>​        代码1</p><p>​    else: 条件2</p><p>​        代码2</p><p>​    else: 条件3</p><p>​        代码3</p><p>​    ……..</p><p>​    else:</p><p>​        代码XXXX</p></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul><li><p>while循环：</p><p>​    while 条件:</p><p>​        代码</p><p>过程：判断条件是否为真，如果真，执行代码，然后再次判断条件，直到条件为假循环结束。</p></li><li><p>break：让当前循环立即停止。</p></li><li><p>continue：停止当前本次循环，继续执行下一次循环。</p></li><li><p>for循环：</p><p>​    for 变量 in 可迭代的成员</p><p>​        代码</p><p>把可迭代的成员中的每一项内容拿出来，挨个的赋值给变量，每一次赋值都要执行一次循环体（代码）。</p><p>循环想要计数，必须借助于range，range(n)：从0到n，不包含n。range(m,n)：从m到n，不包含n。range(m,n,s):从m到n，不包含n，每次间隔为s。</p></li><li><p>平时用得多的是for循环，while循环用的多的是死循环。</p></li></ul><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><ul><li>pass是代码占位标志。</li></ul><h2 id="基础数据类型详解"><a href="#基础数据类型详解" class="headerlink" title="基础数据类型详解"></a>基础数据类型详解</h2><ul><li><p>“””   int ，float，bool</p><p>​    str（非常重要）</p><p>​    list（非常重要)</p><p>​    tuple (了解就行)</p><p>​    set（了解就行)</p><p>​    dict（非常重要)</p><p>​    bytes（重要)</p><p>​    运算符（重要)</p><p>​    文件操作(比较重要)</p><p>“””</p><p>以上是大多数需要记忆内容，理解的东西不多。在python爬虫中会经常用到。 </p><p>1。字符串的格式化：</p><p>​    %s 字符串占位，也能用在数值占位。</p><p>​    %d 数值占位。</p><p>​    %f 占位小数。</p><p>​    f”{变量}”，格式化一个字符串。</p><p>2、索引和切片：</p><p>​    索引：按照位置提取无素。可以采用索引的方式来提取某一个字符（文字）。</p><p>​    切片：从一个字符串中提取一部分内容。语法：s[start:end]，从start到end进行切片，但是提到不到end。</p><p>​    可以给切片添加步长来控制切片的方向：s[::-1] ，负责表示从右往左，正数表示从左往右。</p><p>3、字符串的常规操作：</p><p>​    字答串的操作不会对原字符串产生影响，一般是返回一个新字符串。</p><p>​    s.upper()：把所有字母变成大写字母。用得比较多，常用于条件判断时对输入进行转换比较。</p><p>​    s.lower()：把所有字母变成小写字母。</p><p>​    s.strip()：去掉字符串左右两端的空白符（空格，\t，\n）。</p><p>​    s.replace(old,new)：字符串替换。</p><p>​    s.split(“_”)：可以用任字符串进行切割，切割之后的结果会放到列表当中。</p><p>​    s.find(“str”)：查找和判断，返回如果是-1就是没有该字符串出现。</p><p>​    s.index(“str”)：如果报错就是没有字符串出现。</p><p>​    以上二种查找和判断一般不常用，常用的的方法是：”str”  in s  这里in是成员运算符，返回bool值。</p><p>​    s.startswitch(“str”)：判断字符串是不是以str开头。返回bool值。</p><p>​    s.endswitch(“str”)：判断字符串是不是以str结尾。返回bool值。</p><p>​    s.isdigit()：判断s字符串是不是0和正整数，返回bool值。</p><p>​    len(s)：输出s字符串长度。</p><p>​    s=””.join(list)：将列表list，用双引号中间的字符连接成一个字符串。双引号中间可以是空字符。</p><p>4、字符串的循环和遍历：</p><p>​    for c  in s:</p><p>​        print(c)        字符串中的每一个字符。</p><p>5、关于in用在:</p><p>​    1.判断XXX是否在XXXX中了现。</p><p>​    2.for循环中用到。</p></li><li><p>列表</p><p>定义：列表是能装东西的东西，在python中用[]来表示一个列表，列表中的元素通过”,”隔开。</p><p>特性：1、也像字符串一样有索引和切片。2、索引超过范围会报错。3、可用for循环进行遍历。4、用len()拿到列表的长度。</p><p>列表的增删改查：</p><p>​    lst.append(元素)    添加元素到列表末尾。</p><p>​    lst.insrt(索引，元素)    将无素插入到索引处。</p><p>​    lst.extend(列表)    可以合并两个列表，批量的添加。</p><p>​    ret=lst.pop(索引)    将索引处的元素删除，并将删除的元素返回到ret变量。</p><p>​    lst.remove(元素)    删除某个无素。</p><p>​    lst[索引]=无素    直接用索引就可以进行修改操作。</p><p>​    print(lst[索引])    直接用索引进行查询操作。</p><p>列表排序：</p><p>​    lst.sort()    对列表进行升序排序。</p><p>​    lst.sort(reverse=True)    对列表进行降序排序。</p><ul><li>元组</li></ul><p>​    tuple，元组，特点：不可变的列表。用途：当固定某些数据，不允许外界修改时使用。</p><p>   元组如果只有一个元素(*，)，需要在元素的末尾添加一个逗号。否则()默认是优先级的使用了。</p><p>   关于元组的不可变，是指内存地址变。t=tuple(1,2,3,[‘a’,’b’,’c’])中，元素列表指定的址是不变，但列表内面的元    素是可以变化。</p><ul><li>集合set</li></ul><p> set集合是无序的。</p><p> 表示方式：s={元素1，元素2，…}</p><p> set集合要求存储的数据必须是可以进行哈希计算的，可哈希的数据类型是不可变的有,int,str,tuple,bool。而可变的数据类型有：list,dict,set，它们是不能存在于集合内，成为集合的元素的。</p><p> 只能通过s=set()来创造空集合。而列表可通过l=[]或l=list()、元组通过t=()、字符串s=””或s=str()创建空的对象。</p><p> 由于集合的无序特性，不能使用索引来定位元素，所以修改集合时只能通过先删除后添加来实现：s.remove(无素)，s.add(无素)，使用s.pop()时，()内面也不能写索引，只会删除最后一个元素，具有不确定性。查询集合元素只能通过for  in 循环来实现。</p><p> 集合的一个重要作用是：去重性。常用于将列表重复元素去除，然后重新赋给列表。方法：s=list(set(lst))。但获得的列表与原列表的元素位置会改变。</p><ul><li>字典：字典是以键值对的形式进行存储数据的。</li></ul><p> 字典的表示方式：{key:value，key2:value，key3:value，…}，使用时只是把索引变成了key。</p><p> 字典的key必须是可哈希的数据类型（不可变）。value可以是任何数据类型。</p><p> 字典的增删改查：</p><p> dic[key]=”元素”    增加一项key:value。</p><p> 再次相同的dis[key]=”元素”    表示修改已存在的key键的value值。</p><p> dic.setdefault(key:value)    在字典内面的增加一项默认值，如果key存在，后面的value就不起作用。</p><p> dic.pop(key)    删除字典内健为key的一项键值。根据key删除。</p><p> print(dic[key])    查询字典对应键的值，如果key不存在程序会报错。当确定key存在的情况用得多。</p><p> print(dic.get(key))    功能同上，查询字典对应键的值，但如果key不存在会返回None值。当不确定key的时候用得多。</p><p> None是一种类型为NoneType类型，单纯的就是空，表示没有意思，谁都不能用，可放到if语句做判断。而s=””表示空字符串，是能够被其它函数使用的。</p><p> 可以用for循环直接拿到key</p><p> for key in dic:</p><p> ​    print(key,dic[key])</p><p> 把所有key保存在一个列表中：</p><p> dic.keys()    拿到所有的key了。</p><p> list(dic.key())    列表显示字典内所有的key。</p><p> list(dic.values())    列表显示字典内所有的value值。</p><p> print(list(dic.items()))    直接拿到字典中的所有key和value。</p><p> for key,value in dic.items():    字典的items函数直接能拿到key和value的值。</p><p>​    print(key,value)        直接将字典每个键对值分别赋给二个变量：key,value。元组和列表也能执                        行该操作，该操作被称为解构（解包）。</p><ul><li><p>bytes</p><p>字符集和编码：电脑通过一系列的0和1存储信息。这一系列的0和1通过编码就能表示对应的字符信息。</p><p>首先是美国的ascii编码，共编排了128个文字符号，只需要7个0和1个就可以表示。同时前面加一个0正好是一个字节8位：01111111</p><p>当电脑传到其它国家后，其它国家需要在asii码的基础上扩展本国的文字符号，于是美国制订了ANSI标准，每个字符采用16位，2个字节：00000000  01111111，前8位给不同国家自己编码使用，后面的01111111是ascii标准，不允许修改。</p><p>到了中国，首先是对二万个常用字符进行了编码（ANSI是16位，2个字节，能表示65536个字符），标准是gb2312编码，后来又扩展成了GBK编码（中文windows默认就是使用这个）</p><p>但如果采用ANSI标准编码，不同国家之间的文字要正确显示就必须切换成本国的编码。</p><p>为了避免不同国家文字需要切换成本国的编码标准才能正确显示字符。国际标准统一组织就制订了unicode编码，将世界所有国家的文字都进行了编码，又称万国码。</p><p>但unicode使用了4个字节，在存储和网络传输时会浪费大量资源。因此，只能是概念性编码，是一种标准，没法实际落地使用。于是在unicode基础上，另一种编码UTF编码产生，它是一种可变长的unicode编码，可以进行数据存储和传输。</p><p>utf有二种标准：utf-8表示最短的字节长度为8，对应英文就是8bit，1个字节，对应欧洲文字就是16bit，2个字节，对应中文就是24bit，3个字节；utf-16表示最短的字节长度为16</p><p>因此，gbk源自ansi标准，utf-8源自unicode标准，二者之间不能直接就进行转化。相当于二套密码本（编码），要通过一套密码本转换成文字，然后再将文字转换成另一种密码本来进行相互转化。</p><p>程序员平时遇见的所有数据最终单位都是字节byte。bytes就是字节串的意思。</p><p>将字符串变成字节就是进行编码str.encode(“编码”)，将字节转化成字符串就是进行解码tytes.decode(“编码”)</p><p><em># 怎样将一个bgk字节转化成uft-8的字节</em>：</p><p>bs=b’\xc0\xee\xbc\xcc\xcf\xfe’ <em>#开头的b表示 bytes类型</em></p><p><em># 先用gbk解码成字符串。</em></p><p>s=bs.decode(‘gbk’)</p><p><em># 再用utf-8重新编码成字节。</em></p><p>bs=s.encode(‘utf-8’)</p><p>print(bs)</p><p>注意：英语字母在所有编码内面都能正常显示，不存在单独编码，因此在字符串中和bytes中都会正常显示成英文。</p><p>注意2：python内存中使用的是unicode编码，因为内存数据随时可以抹除，不需要象保存到硬盘中的文件而需要编码来节约资源。</p></li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算符中，a//b表示取商，a%b表示取余数（得到商后剩下的数字）</li><li>逻辑运算符运算顺序：先算（）&gt;not&gt;and&gt;or</li><li>成员运算符：in  判断xxx是否在xxxx中出现了。not in 判断xxx是否不在xxxx中出现了。</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li><p>读取文件语法：f=open(文件路径,mode=”r”,encoding=”utf-8”)文件路径可以是相对路径或绝对路径；mode是对文件的操作模式，在这里r表示读取，这条命令执行完并不会把文件全部加载到内存，只是在你的程序与文件间建立了一条通道，后读还要使用f.read()或f.readline()等方式将文件内容加载到内存；encoding是指出文件是以什么方式进行编码的（使用的是哪种字符集），一般对文本文件建议加上，对于其它文件如图片，音频等，因为其内容与编码没关系，在这里可以省略这个参数。</p><ul><li>for line in f:            从f中读取到每一行数据。</li></ul><p>​    print(line.strip())</p></li><li><p>写入文件语法：f=open(文件路径,mode=”w”,encoding=”utf-8”)      w模式下，写入的文件不存在会自动创建该文件，如果存在该文件都会清空该文件内容。同理该行代码也只是程序与文件间建立了一条通道，后面还要使用f.write()命令来写入数据内容。</p></li><li><p>追加写入文件语法：f=open(文件路径,mode=”a”,encoding=”utf-8”)    a模式下，不会清空该文件原来内容，后面使用f.write()时，会在该文件后面追加数据内容。</p></li><li><p>f.close()    不管读或写，最后注意要使用该语句关闭文件链接（即关闭程序与文件间的通道）。</p></li><li><p>使用with open(文件路径,mode=”w”,encoding=”utf-8”)  as f:    with表示上下文件管理，这时就不需要使用f.close()了，该语句会自动关闭文件。</p></li><li><p>对于非文本文件读写语法：f=open(图片或音频等文件路径,mode=”rb”)    要在mode中加入b属性，后面也不能再使用encoding参数了。读取出来的是字节内容。</p></li><li><p>从源文件中读取内容，写入到新的路径去：with open(图片或音频等文件路径,mode=”rb”) as f1,open(图片或音频等文件路径,mode=”wb”) as f2:</p><p>​    for line in f1:</p><p>​        f2.write(line)</p></li><li><p>修改文件的方法：1、从源文件中读取内容。2、在内存中进行修改。3、把修改后的内容写入新文件中。4、删除源文件，将新文件重命名成源文件。</p></li></ul><h2 id="函数编程-上"><a href="#函数编程-上" class="headerlink" title="函数编程_上"></a>函数编程_上</h2><ul><li><p>函数：对某一特定功能或代码进行封装，在需要使用该功能的时候直接调用即可。</p></li><li><p>定义：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数的名字</span>():<br>    函数体<span class="hljs-comment">#被封装的功能或者代码块</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>调用方法：函数的名字()    #函数定义后如果不调用是不会执行。</p></li><li><p>形参与实参：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2</span>，..</span>)<span class="hljs-comment">#在定义的时候使用，接收调用的时候传过来的参数，在函数体代码中使用。</span><br>函数体<br>main(实参<span class="hljs-number">1</span>,实参<span class="hljs-number">2</span>，...)<span class="hljs-comment">#在调用的时候传入。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">*参数</span>)<span class="hljs-comment">#*号表示接收位置参数的动态传参，参数的类型必须是元组。</span><br>函数体<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">**参数</span>)<span class="hljs-comment">#**表示接收关键字参数的动态传参，参数类型必须是字典。</span><br>函数体<br><span class="hljs-comment">#参数存放顺序：位置&gt;*args&gt;默认值&gt;**kwargs</span><br>main(*参数)<span class="hljs-comment">#在实参位置使用*号是把列表（或有序数据类型）打散成位置参数进行传递。</span><br> <br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul><li>如果函数体没有return，此时外界收到的返回值是None</li><li>函数体执行到return时，会直接返回，如果return后面没有值也会返回None值</li><li>如果return 值1，值2，值3，….，这时返回的是一个元组，元组内是该反回值</li></ul><h2 id="内置函数（上）"><a href="#内置函数（上）" class="headerlink" title="内置函数（上）"></a>内置函数（上）</h2><ul><li><p>反射函数4个</p></li><li><p>基础数据类型相关38个</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs tex">一、和数字相关14个<br>1、数据类型4个<br>1.bool<br>2.int<span class="hljs-params">#</span> a=0b10010,int(a)能将二进制转变成10进制。<br>3.float<br>4.complex：复数，实部+虚部<br>2、进制转换3个<br>1.bin:<span class="hljs-params">#</span>输出结果似0b10010，以0b开头。<br>2.oct<span class="hljs-params">#</span> 0o22，以0o开头。<br>3.hex<span class="hljs-params">#</span> 0x12，以0x开头。<br>3、数学运算7个<br>1.obs<br>2.divmod<br>3.round<br>4.pow<span class="hljs-params">#</span> pow(a,b),次幂，计算a的b次方，与a**b等价。<br>5.sum<span class="hljs-params">#</span> sum(lst)，计算列表中所有元素的和。<br>6.min<span class="hljs-params">#</span> mix(lst)，计算列表中最小的值。<br>7.max<span class="hljs-params">#</span> max(lst)，计算列表中最大的值。<br>二、和数据结构相关24个<br>1、序列13个<br>1.列表与元组2个<br>1.list<span class="hljs-params">#</span> s={1,2,3} list(s) 将传递进来的集合变成一个列表。<br>2.tuple<br>2.相关内置函数2个<br>1.reversed<span class="hljs-params">#</span> 翻转<br>2.slice<span class="hljs-params">#</span> 切片 s=slice(1,4,2)  lst[s] 与 lst[1,4,2]相同。<br>3.字符串9个<br>1.str<span class="hljs-params">#</span> 字符串，通过encode()能编码成字节串（二进制字符串）<br>2.format<span class="hljs-params">#</span> 格式化 a=18 format(a,"08b") 将a格式化8位的二进制，前面不足的补0。<br>3.bytes<span class="hljs-params">#</span> bytes类型的字符串，又称字节串（二进制的字符串），是为了满足网络传输时的需要而定义的一种数据类型，通过decode()能解码成字符串，<br>4.bytearry<br>5.memoryview<br>6.ord<span class="hljs-params">#</span> 输出码位 a='中' ord(a) 将"中"字的unicode的码位输出来。<br>7.chr<span class="hljs-params">#</span> chr(20013) 给出码位位置，展示出文字。通过for i in range(65536)展示大量文字<br>8.ascii将传入的对象以ascii字节形式做一个切割。<br>9.repr<br>2、数据集合3个<br>1.字典1个<br>dict<br>2.集合2个<br>1.set<br>2.frozenset<span class="hljs-params">#</span> 冻结的集合，不可变，与元组相同。<br>3、相关内置函数8个<br>1.len<br>2.sorted排序<br>3.enumerate通过for item in enumerate(list): 可以拿到索引和元素。<br>4.all当成逻辑运算符and来看，all([1,"","abc"]),相当于运算成：t and f and t<br>5.any当成逻辑运算符or来看，any([1,"","abc"]),相当于运算成：t or f or t<br>6.zip可以把多个可迭代内容进行合并。<br>7.fiter筛选<br>8.map映射<br></code></pre></td></tr></tbody></table></figure></li><li><p>作用域相关2个</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span><span class="hljs-built_in">locals</span> 函数会以字典的类型返回当前位置的全部局部变量<br><span class="hljs-number">2.</span><span class="hljs-built_in">globals</span> 函数以字典的类型返回全部全局变量。<br></code></pre></td></tr></tbody></table></figure></li><li><p>面向对象相关9个</p></li><li><p>迭代器/生成器相关3 个</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span><span class="hljs-built_in">range</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">iter</span><br><span class="hljs-number">3.</span><span class="hljs-built_in">next</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>其它12个</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs te">一、字符串类型代码的执行3个<br>1.eval执行字符串类型的代码，并返回最终结果<br>2.exec执行字符串类型的代码<br>3.complie将一个字符串编辑为字节代码<br>二、输入输出2个<br>1.input<br>2.print<br>三、内存相关2个<br>1.hashhash(s) 对不可变的类型进行计算出一个数字，转化成内存地址，进行数据存储为字典(集合)哈希表<br>2.idid(s) 直接拿到s在内存中的存储地址<br>四、文件操作相关1个<br>open<br>五、模块相关1个<br>__import__<br>六、帮助1个<br>helphelp(类型) 查看类型的定义和使用方法等详细信息。<br>七、调用相关1个<br>callable<br>八、查看内置属性1个<br>dirdir(对象) 查看当前对象（数据）能执行哪些操作。<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="函数编程-下"><a href="#函数编程-下" class="headerlink" title="函数编程_下"></a>函数编程_下</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>变量的访问权限：函数外面，顶格左边定义的变量称为全局变量，称全局作用域，在所有定义的函数中都能使用。而在函数内部定义的变量称为局部变量，称作局部作用域，只能在函数内部使用，外部调用不了。如果想要在函数外面访问函数内面的东西，必须要用到return返回值来获取。</li><li>顶格左边声明的函数也是全局的，是全局的一个函数，跟变量调用范围相同。</li></ul><h3 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h3><ul><li>在定义函数的内面再定义一个函数就会形成函数嵌套。在内面定义的函数也是局部函数，在外面不能调用。</li><li>局部的东西一般都是自己访问使用的。</li><li>函数可以作为返回值进行返回，函数也可以作为参数进行相互传递。因此函数名实际上就是一个变量名，都表示一个内存地址。</li></ul><h3 id="二个关键字"><a href="#二个关键字" class="headerlink" title="二个关键字"></a>二个关键字</h3><ul><li>global  把外面的全局变量引入到局部。</li><li>nonlocal 在局部，引入外层的局部变量，如果有就引入，如果没有，继续向外一层查找引入，直到全局(不包括)</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包本质是内层函数对外层函数的局部变量的使用，此时内层函数被称为闭包函数。用于协作写出高效程序代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs te">1、可以让一个变量常驻与内存。<br>2、可以避免全局变量被修改。<br>def fun():<br>a=10<br>def inner():<br>nonlocal a# 注意，这里是引入和使用的是外层局部变量。没有在内部重新定义一个a局部变量<br>a+=1#这里的局部变量a因为常驻与内存，不会被垃圾回收，值一直在。<br>return a<br>return inner<br>a=20<br>ret=fun()<br>r1=ret()<br>print(r1)  <br>r2=ret()<br>print(r2)<br>第一个输出结果是：11<br>第二个输出结果是: 12<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><ul><li><p>装饰器本身是一个闭包，它的作用是在不改变原有函数的情况下，给函数增加新的功能。可以这样来理解：可以在函数前后添加新功能，但是不改变原来的代码。</p></li><li><p>装饰器一般用在用户登录的地方、日志。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#理解装饰器之前需要理解三点知识：1.函数可以作为参数进行传递；2.函数可以作为返回值进行返回；3.函数名称可以当成变量一样进行赋值操作。</span><br><span class="hljs-comment">#装饰器的通用写法：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">fn</span>):<span class="hljs-comment">#wrapper：装饰器，fn:目标函数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment">#在目标函数执行之前...</span><br>        ret=fn(*args, **kwargs)<br>        <span class="hljs-comment">#在目标函数执行之后...</span><br>        <span class="hljs-keyword">return</span> ret<br>    <span class="hljs-keyword">return</span> inner<span class="hljs-comment">#不要加()</span><br><span class="hljs-meta">@wrapper</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>()<br><span class="hljs-keyword">pass</span><br>target()<span class="hljs-comment"># 这里调用的inner了。</span><br><br><span class="hljs-comment">#一个函数可以被多个装饰器装饰。</span><br><span class="hljs-meta">@wrapper1</span><br><span class="hljs-meta">@wrapper2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"..."</span>)<br><span class="hljs-comment">#运行的规则与规律：wrapper1 wrapper2 target wrapper2 wrapper1</span><br>---------------------------------------<br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">guanjia</span>(<span class="hljs-params">game</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<span class="hljs-comment"># * **表示接收所有参数，打包成元组和字典。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'开始游戏...'</span>)<br>        game(*args, **kwargs)<span class="hljs-comment">#这里的* **表示把元组和字典打散成位置参数以及关键字参数传递进去。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'结束游戏...'</span>)<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@guanjia    </span><span class="hljs-comment">#相当于pisa=guanjia(pisa)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pisa</span>(<span class="hljs-params">user,password</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'%s欢迎来到Pisa,你的密码是%s'</span>%(user,password))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'正在玩Pisa...'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"获得了返回信息..."</span><br><br><span class="hljs-meta">@guanjia    </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xiaomi</span>(<span class="hljs-params">user,password,title</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'%s欢迎来到xiaomi,你的密码是%s,你选择的型号是%s'</span>%(user,password,title))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'正在玩小米...'</span>)<br><br>ret=pisa(<span class="hljs-string">'admin'</span>,<span class="hljs-string">'123456'</span>)<span class="hljs-comment">#此时运行的是guanjia的内层函数inner</span><br><span class="hljs-built_in">print</span>(ret)<br>xiaomi(<span class="hljs-string">'admin'</span>,<span class="hljs-string">'123456'</span>,<span class="hljs-string">'note8'</span>)<br>运行结果：<br>开始游戏...<br>admin欢迎来到Pisa,你的密码是<span class="hljs-number">123456</span><br>正在玩Pisa...<br>结束游戏...<br>获得了返回信息...<br>开始游戏...<br>admin欢迎来到xiaomi,你的密码是<span class="hljs-number">123456</span>,你选择的型号是note8<br>正在玩小米...<br>结束游戏...<br><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li><p>iterable 可迭代的东西，包括：str、list、tuple、dict、set、open()</p></li><li><p>iterator：迭代器。</p></li><li><p>可迭代的数据类型都会提供一个叫迭代器的东西，这个迭代器可以帮我们把数据类型中的所有数据逐一拿到。</p></li><li><p>for内面一定是要拿迭代器的，所以所有不可以迭代的东西不能用for循环。</p></li><li><p>for循环内面一定有__next__出现。</p></li><li><p>迭代器统一了不同数据类型的遍历工作。</p></li><li><p>迭代器本身也是可迭代的。</p></li><li><p>迭代器本身的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#获取迭代器的两种方案</span><br><span class="hljs-number">1.</span>inter() 内置函数可以直接拿到迭代器。<br>    it=<span class="hljs-built_in">iter</span>(<span class="hljs-string">"abc"</span>)<br><span class="hljs-built_in">print</span>(it)<br>    运行结果：<br>    &lt;str_ascii_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x00000212A7091BD0</span>&gt;<br>    <span class="hljs-number">2.</span>__inter__() 特殊方法<br>    it=<span class="hljs-string">"abc"</span>.__iter__()<br><span class="hljs-built_in">print</span>(it)<br>    运行结果：<br>    &lt;str_ascii_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000012B1CF41BD0</span>&gt;<br><span class="hljs-comment">#从迭代器中拿到数据</span><br><span class="hljs-number">1.</span><span class="hljs-built_in">next</span>()<br>    it=<span class="hljs-built_in">iter</span>(<span class="hljs-string">"abc"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it))<br>    运行结果：<br>    a<br>b<br>c<br>    <span class="hljs-number">2.</span>__iter__() 特殊方法<br>    it=<span class="hljs-string">"abc"</span>.__iter__()<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    <span class="hljs-built_in">print</span>(it.__next__())<br>    运行结果：<br>    a<br>b<br>c<br><span class="hljs-comment"># 迭代器本身也可以迭代：</span><br>    s=<span class="hljs-string">"abc"</span><br>    it=<span class="hljs-built_in">iter</span>(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>        <span class="hljs-built_in">print</span>(i)<br>    运行结果：<br>    a<br>b<br>c<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul><li><p>generator  生成器，本质就是迭代器，也具有迭代器的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 创建生成器的两种方案</span><br><span class="hljs-number">1.</span>生成器函数 语法：<span class="hljs-keyword">yield</span><br><span class="hljs-number">2.</span>生成器表达式 语法：(数据 <span class="hljs-keyword">for</span>循环 <span class="hljs-keyword">if</span>判断)<br><span class="hljs-comment"># 生成器函数有一个关键字：yield，生成器函数执行的时候，并不会执行函数，得到的是生成器。</span><br><span class="hljs-comment"># yield：只要函数中出现了yield，它就是一个生成。作用：1.可以返回数据。2.可以分段的执行函数中的内容，通过__next__()可以执行到下一个yield位置，用得好这个功能，特别的节省内存。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br><span class="hljs-built_in">print</span>(fun())<br>运行结果：<br>&lt;generator <span class="hljs-built_in">object</span> fun at <span class="hljs-number">0x00000203EE0CCAC0</span>&gt;<br><span class="hljs-comment">#如果要执行函数，就用迭代器去调用，因为生成器本质就是迭代器。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br><span class="hljs-built_in">print</span>(fun().__next__())<br>运行结果：<br>Hello<br><span class="hljs-number">999</span><br><span class="hljs-comment"># yield也有与return相似的返回功能，return是直接返回，后面语句不会执行，但yield后面的语句还可以继续运行。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>fun().__next__()<br>运行结果：<br>hello<span class="hljs-comment"># 因为没有变量接收yield 999的值，所以仅仅只是执行了fun函数的print语句。</span><br><span class="hljs-comment"># 多个yield分段执行过程：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">999</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"World"</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">666</span><br>ret=fun()<br><span class="hljs-built_in">print</span>(ret.__next__())<br><span class="hljs-built_in">print</span>(ret.__next__())<br>运行结果：<br>Hello<br><span class="hljs-number">999</span><br>World<br><span class="hljs-number">666</span><br><span class="hljs-comment"># 生成器表达式演示：</span><br>t=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(t)<br>输出结果：<span class="hljs-comment"># 如果是元组推导式的话，t应该会输出元组数据，实际输出t是生成器对象，说明不存在元组推导式。</span><br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x0000024D0E520380</span>&gt;<br><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> gen:<span class="hljs-comment">#因为生成器本质上是一种迭代器，要获取gen的数据只能通过for循环迭代实现。</span><br>    <span class="hljs-built_in">print</span>(item)<br>输出结果：<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br>lst=<span class="hljs-built_in">list</span>(gen)<span class="hljs-comment"># 将生成器转换成列表。</span><br><span class="hljs-built_in">print</span>(lst)<br>输出结果：<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]<span class="hljs-comment"># 结果说明，list()肯定包含了for循环，而for循环肯定就调用了next()函数。</span><br><br><span class="hljs-comment"># 生成器表达式也是一次性的，各前取完后就不存在数据了。</span><br>gen=(i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-built_in">print</span>(item)<br>lst=<span class="hljs-built_in">list</span>(gen)<br><span class="hljs-built_in">print</span>(lst)<br>输出结果：<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br>[]<span class="hljs-comment"># 前面for循环已取完生成器数据，因为是向前一次性的取数，所以再使用列表去取数就会显示为空。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><ul><li><p>推导式简化代码。数据有规律时使用。分为三种推导式：列表推导式、字典推导式、集合推导式。</p></li><li><p>对于复杂长代码不建议用推导式，用for循环实现代码可读性更强。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 语法：</span><br><span class="hljs-comment">#列表推导式 [数据 for循环 if判断]  数据就是你想往列表内放的东西，并且这个东西还能通过if语句判断条件来进行处理，if判断是可选择项。</span><br>    <span class="hljs-comment">#集合推导式 {数据 for循环 if判断}</span><br>    <span class="hljs-comment">#字典推导式 {k:v  for循环 if判断}</span><br><span class="hljs-comment"># (数据 for循环 if判断) 这不是元组推导式，元组不允许修改，所以根本没有元组推导式，这种叫生成器表达式。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul><li><p>匿名函数又称为： lambda表达式，语法：变量=lambda 参数1,参数2,…：返回值 。实现了一句话创建了一个函数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 一个正常的函数定义包涵：def 、函数名、(参数)如果有的话、冒号、函数体、返回结果，如下：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br><span class="hljs-comment">#调用方法：用一变量接收函数fun(),并将参数放在()中的返回值。同时函数fun中的函数体代码也已经开始运行完成。</span><br>ret=fun(参数)  <br><br><span class="hljs-comment"># 匿名函数定义省略了：def 函数名、冒号、函数体，只乘下参数、冒号和返回结果，并用lambda来标识，如下：</span><br>fn=<span class="hljs-keyword">lambda</span> 参数:返回值<span class="hljs-comment">#最显著少了函数名和函数体。</span><br><span class="hljs-comment"># 调用方法：用一变量接收匿名函数fn(),并在()中传递参数。</span><br>ret=fn(参数)<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="内置函数（下）"><a href="#内置函数（下）" class="headerlink" title="内置函数（下）"></a>内置函数（下）</h3><ul><li><p>sorted 排序</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">lst1=[<span class="hljs-string">'中'</span>,<span class="hljs-string">'中华人民共和国'</span>,<span class="hljs-string">'中国'</span>]  <span class="hljs-comment"># 当lst不是数字时，按key=确定排序方法的函数来进行排序</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(lst1,key=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">len</span>(x)))<span class="hljs-comment"># 对于匿名函数只是在这里需调用的时候，直接写在这里更合理。</span><br>运行结果：<br>[<span class="hljs-string">'中'</span>, <span class="hljs-string">'中国'</span>, <span class="hljs-string">'中华人民共和国'</span>]<br><br>lst=[{<span class="hljs-string">'id'</span>:<span class="hljs-number">5</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'中'</span>},{<span class="hljs-string">'id'</span>:<span class="hljs-number">7</span>,<span class="hljs-string">'name'</span>:<span class="hljs-string">'中国'</span>}]<br>s=<span class="hljs-built_in">sorted</span>(lst,key=<span class="hljs-keyword">lambda</span> d:d[<span class="hljs-string">'id'</span>],reverse=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 在sorted中，这时的lst成为列表中的每项即字典了</span><br><span class="hljs-built_in">print</span>(s)<br>运行结果：<br>[{<span class="hljs-string">'id'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'中国'</span>}, {<span class="hljs-string">'id'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'中'</span>}]<br></code></pre></td></tr></tbody></table></figure></li><li><p>filter 筛选</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">lst=[<span class="hljs-string">'张三'</span>,<span class="hljs-string">'李四'</span>,<span class="hljs-string">'王五'</span>,<span class="hljs-string">'张天矣'</span>,<span class="hljs-string">'张明明'</span>]<br>f=<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-keyword">not</span> x.startswith(<span class="hljs-string">'张'</span>),lst)<span class="hljs-comment"># 对lst中每个元素进行判断，符合条件的放入f中。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(f))<br>运行结果：<br>[<span class="hljs-string">'李四'</span>, <span class="hljs-string">'王五'</span>]<br></code></pre></td></tr></tbody></table></figure></li><li><p>map 映射</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">lst=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>f=<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x**<span class="hljs-number">2</span>,lst)<span class="hljs-comment"># 对lst每一项进行处理后放在f中，f是一个可迭代的map对象。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>(f))<span class="hljs-comment"># 对可迭代的map对象转换成元组。</span><br>输出结果：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul><li>递归：函数自己调用自己</li><li>递归如果没有任何东西拦截的话，它默认就是一个死循环。</li><li>默认递归深度最大限制为1000</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="time和datetime"><a href="#time和datetime" class="headerlink" title="time和datetime"></a>time和datetime</h3><ul><li><p>time 通过import time导入，该模块基本上被datetime模块取代，实际使用中就只用记住二个功能：sleep()、time()</p></li><li><p>time.sleep()功能：让程序停止一会儿。</p></li><li><p>time.time()：返回一串长的数字表示的是时间戳。也叫数字类型的时间。</p></li><li><p>datetime 掌握二个功能：通过from datetime import datetime和from datetime import date。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-comment">#datetim:年月日时分秒；date:年月日;time:时分秒</span><br><br><span class="hljs-built_in">print</span>(datetime.now())<span class="hljs-comment"># 显示当前时间</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span> <span class="hljs-number">18</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29.543848</span><br><br><span class="hljs-built_in">print</span>(datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">42</span>,<span class="hljs-number">31</span>)) <span class="hljs-comment">#格式化或创建一个时间</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span> <span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">31</span><br><br>t1=datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">42</span>,<span class="hljs-number">31</span>)<br>t2=datetime(<span class="hljs-number">2025</span>,<span class="hljs-number">4</span>,<span class="hljs-number">19</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>)<br>diff=t2-t1<br><span class="hljs-built_in">print</span>(diff)<span class="hljs-comment"># 显示两个时间的差，以天数，小时，分钟，秒显示。</span><br><span class="hljs-built_in">print</span>(diff.total_seconds())<span class="hljs-comment"># 显示两个时间差，以秒显示。</span><br>输出结果：<br><span class="hljs-number">30</span> days, <span class="hljs-number">7</span>:<span class="hljs-number">29</span>:<span class="hljs-number">30</span><br><span class="hljs-number">2618970.0</span><br><br><span class="hljs-comment"># 格式化一个时间：</span><br>t=datetime.now()<br><span class="hljs-built_in">print</span>(t.strftime(<span class="hljs-string">"%Y年%m月%d日 %H时:%M分钟:%S秒"</span>))<span class="hljs-comment"># 以字符串形式格式化时间。</span><br>输出结果：<br><span class="hljs-number">2025</span>年03月<span class="hljs-number">19</span>日 <span class="hljs-number">18</span>时:<span class="hljs-number">55</span>分钟:04秒<br><br><span class="hljs-comment"># 把字符串转化成时间：</span><br>s=<span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入时间(格式:yyyy-mm-dd HH:MM:SS):"</span>)<span class="hljs-comment"># 由用户按格式输入时间</span><br>t=datetime.strptime(s, <span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>)   <span class="hljs-comment"># p:parse(转化的意思)</span><br><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date <span class="hljs-comment"># 用法与datetime相同，也能实现strftime()和strptime()等功能。</span><br><br><span class="hljs-built_in">print</span>(date.today())<span class="hljs-comment">#date只需要掌握这个功能。</span><br>输出结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">19</span><br><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="随机数模块"><a href="#随机数模块" class="headerlink" title="随机数模块"></a>随机数模块</h3><ul><li><p>random 通过import random导入，随机产生一个0到1之间的小数。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 这里导入的是radmom模块内的一个random函数，实现产生一个随机数功能。</span><br><br><span class="hljs-built_in">print</span>(random())<br>输出结果：<br><span class="hljs-number">0.5512596462326173</span><br><br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)) <span class="hljs-comment">#随机整数，能够取到边界值</span><br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)) <span class="hljs-comment">#随机浮点数，1-100之间</span><br><br>lst=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(random.choice(lst)) <span class="hljs-comment"># 从列表中随机选取一项。</span><br><br><br><span class="hljs-keyword">import</span> random<br><span class="hljs-comment">#随机生成4验证码，包含数字、大写字母、小写字母</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_int</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_upper</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(random.randint(<span class="hljs-number">65</span>,<span class="hljs-number">90</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_lower</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">chr</span>(random.randint(<span class="hljs-number">97</span>,<span class="hljs-number">122</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rand_verify_code</span>(<span class="hljs-params">n=<span class="hljs-number">4</span></span>):<br>    lst=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        switch = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">if</span> switch == <span class="hljs-number">1</span>:<br>            s=rand_int()<br>        <span class="hljs-keyword">elif</span> switch == <span class="hljs-number">2</span>:<br>            s=rand_upper()<br>        <span class="hljs-keyword">else</span>:<br>            s=rand_lower()<br>        lst.append(s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(lst)<br><br><span class="hljs-built_in">print</span>(rand_verify_code())<br><br><br><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="pickle对象转字节"><a href="#pickle对象转字节" class="headerlink" title="pickle对象转字节"></a>pickle对象转字节</h3><ul><li><p>把python对象写入文件的一种解决方案，写入到文件的是字节bytes， 这种过程叫做序列化。</p></li><li><p>网络传输时只认字节，这种转化就很好地解决了这个问题。</p></li><li><p>python代码中的字典数据通过open()方式写入文件只能通过转换成字符串才能写入，但在反过来读取的文件的时候，数据就是字符串类型，不能还原原来的字典数据类型，这时候通过pickle转化就能解决上述问题。</p></li><li><p>把数据存储到文件中最合理的方案就是pickle，而eval存在安全隐患。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br>lst=[<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">'陈菲菲'</span>,<span class="hljs-string">'李奕妙'</span>]<br><span class="hljs-built_in">print</span>(pickle.dumps(lst))<br>输出结果：<br><span class="hljs-string">b'\x80\x04\x95)\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\t\xe6\x9d\x8e\xe7\xbb\xa7\xe6\x99\x93\x94\x8c\t\xe9\x99\x88\xe8\x8f\xb2\xe8\x8f\xb2\x94\x8c\t\xe6\x9d\x8e\xe5\xa5\x95\xe5\xa6\x99\x94e.'</span><br><br><span class="hljs-keyword">import</span> pickle<br><br>b=<span class="hljs-string">b'\x80\x04\x95)\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\t\xe6\x9d\x8e\xe7\xbb\xa7\xe6\x99\x93\x94\x8c\t\xe9\x99\x88\xe8\x8f\xb2\xe8\x8f\xb2\x94\x8c\t\xe6\x9d\x8e\xe5\xa5\x95\xe5\xa6\x99\x94e.'</span><br><span class="hljs-built_in">print</span>(pickle.loads(b))<br>输出结果：<br>[<span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'陈菲菲'</span>, <span class="hljs-string">'李奕妙'</span>]<br><br><span class="hljs-keyword">import</span> pickle<br><br>dic={<span class="hljs-string">'name'</span>:<span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>:<span class="hljs-number">50</span>}<br>b=pickle.dumps(dic)<br>pickle.dump(dic,<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.data"</span>,mode=<span class="hljs-string">"wb"</span>))<span class="hljs-comment">#将字典转化成字节写入文件。</span><br><br><span class="hljs-keyword">import</span> pickle<br><br>dic=pickle.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.data"</span>,mode=<span class="hljs-string">"rb"</span>))<span class="hljs-comment"># 将文件读取并还原成字典。</span><br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic))<br>输出结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">50</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt;<br><br><span class="hljs-comment"># 说明：</span><br><span class="hljs-comment"># 序列化：把对象转化成二进制字节；反序列化：把二进制字节转化回对象。</span><br>    <span class="hljs-comment"># 1.dumps 把对象（数据）转化成字节。</span><br>    <span class="hljs-comment"># 2.loads 把字节转化回对象（数据）</span><br>    <span class="hljs-comment"># 3.dump 把对象序列化成字节之后写入文件。</span><br>    <span class="hljs-comment"># 4.load 把文件中的字节反序列化成对象。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ul><li><p>json是前后端交互的枢纽，相当于编程界的普通话，json的语法格式能完美展示出一个对象，全称为js对象简谱。它是一种数据传输的数据格式。 </p></li><li><p>目前，几乎大部app后端返回的数据都是json格式，它非常方便前端处理。</p></li><li><p>通过import json来导入json包。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 浏览器前端和python程序之间只能以字符串进行传递，所以我们需要做的事是：</span><br><span class="hljs-comment"># 1.把python中的数据类型，如字典、列表、字符串，转化成json字符串，这种转换又称为序列化。</span><br><span class="hljs-keyword">import</span> json<br><br>dic={<span class="hljs-string">"name"</span>:<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">'25'</span>}<br>s=json.dumps(dic)<span class="hljs-comment"># 在这里转化时，会默认调用到ascii函数，中文将转化成字节。</span><br><span class="hljs-built_in">print</span>(s,<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">"name"</span>: <span class="hljs-string">"\u674e\u7ee7\u6653"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-string">"25"</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br>dic={<span class="hljs-string">"name"</span>:<span class="hljs-string">'李继晓'</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">'25'</span>}<br>s=json.dumps(dic,ensure_ascii=<span class="hljs-literal">False</span>)<span class="hljs-comment"># 这里禁止调用ascii函数转化，中文就会正常显示。</span><br><span class="hljs-built_in">print</span>(s,<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">"name"</span>: <span class="hljs-string">"李继晓"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-string">"25"</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br><span class="hljs-comment"># 2.前端返回的json字符串，想办法变成python中的数据类型，如字典、列表、字符串，这种转换又称为反序列化，反序列化的目的是让转换后的数据类型便于pthon语言方便处理。</span><br><span class="hljs-keyword">import</span> json<br><br>s=<span class="hljs-string">'{"name":"李继晓","age":"25","text":null}'</span><br>dic=json.loads(s)<br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic),<span class="hljs-built_in">type</span>(s))<br>运行结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'25'</span>,<span class="hljs-string">'text'</span>:<span class="hljs-literal">None</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br><br><span class="hljs-comment"># 写入文件和读取文件代码：</span><br><span class="hljs-keyword">import</span> json<br><br>dis={<span class="hljs-string">"name"</span>:<span class="hljs-string">"李继晓"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-string">"25"</span>,<span class="hljs-string">"test"</span>:<span class="hljs-literal">None</span>}<br>f=json.dump(dis,<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.txt"</span>,mode=<span class="hljs-string">"w"</span>,encoding=<span class="hljs-string">"utf-8"</span>),ensure_ascii=<span class="hljs-literal">False</span>)<br>dic=json.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">"ljx.txt"</span>,mode=<span class="hljs-string">"r"</span>,encoding=<span class="hljs-string">"utf-8"</span>))<br><span class="hljs-built_in">print</span>(dic,<span class="hljs-built_in">type</span>(dic))<br>运行结果：<br>{<span class="hljs-string">'name'</span>: <span class="hljs-string">'李继晓'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'25'</span>, <span class="hljs-string">'test'</span>: <span class="hljs-literal">None</span>} &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt;<br><br><span class="hljs-comment"># 总结：</span><br><span class="hljs-comment"># 前端的json和python中的字典数据类型写法有细微差别，但用法一样：</span><br>    <span class="hljs-comment"># python前端</span><br>        <span class="hljs-comment"># Trueture</span><br>        <span class="hljs-comment"># Nonenull</span><br><span class="hljs-comment"># 1.dumps 可以把对象（数据）转化成json，注意后面要跟参数：ensure_ascii=False否则中文会出问题。</span><br>    <span class="hljs-comment"># 2.loads 可以把json转化回对象（数据）</span><br>    <span class="hljs-comment"># 3.dump 可以把对象（数据）以json格式写入文件，注意后面要跟参数：ensure_ascii=False</span><br>    <span class="hljs-comment"># 4.load 可以从文件中读取json格式的数据转化成对象（数据）</span><br>    <span class="hljs-comment"># 5.json来自前端。</span><br>    <span class="hljs-comment"># 6.json是一种数据交互的数据格式，它本身就是一种象字符串的格式。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h3><ul><li><p>MD5是一种不可逆的加密算法，由于MD5存在很久了，一些简单排列组合来计算MD5的密文被保存后，当出现相同的MD5密文后就能反推原来的数据，这种现象叫撞库。应对方法就是在使用MD5时，给函数的参数传递一个byte来进行MD5加密计算形成密文，这种方法称为哈希加盐。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br><br><span class="hljs-comment"># 创建md5对象</span><br>md5 = hashlib.md5()<br><span class="hljs-comment"># 把要加密的信息传递给md5对象</span><br>md5.update(<span class="hljs-string">'123456'</span>.encode(<span class="hljs-string">'utf-8'</span>))<span class="hljs-comment">#参数字符串编码成字节。</span><br><span class="hljs-comment"># 获取加密后的结果  </span><br>result = md5.hexdigest()<br><span class="hljs-built_in">print</span>(result)<br>运行结果：<br>e10adc3949ba59abbe56e057f20f883e<br><br><span class="hljs-comment"># 正常的默认加密过程容易撞库，解决方法就是加盐。</span><br>md5=hashlib.md5(<span class="hljs-string">b'fdafdfadfdfdfa'</span>)<span class="hljs-comment"># 这里参数是字节。</span><br>md5.update(<span class="hljs-string">b'123456'</span>)<span class="hljs-comment">#这里参数也是字节。</span><br><span class="hljs-built_in">print</span>(md5.hexdigest())<br>运行结果：<br>f6f8eda769519bb05b203a15818cf736<br><br><span class="hljs-comment"># 动态加盐</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">salt,s</span>):<br>    md5=hashlib.md5(salt.encode(<span class="hljs-string">'utf-8'</span>))<br>    md5.update(s.encode(<span class="hljs-string">'utf-8'</span>))<br>    <span class="hljs-keyword">return</span>(md5.hexdigest())<br><br>username=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入用户名：'</span>)<br>password=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入密码：'</span>)<br>mi_pasword=func(username,password)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(username+<span class="hljs-string">'\n'</span>+mi_pasword)<br>------------------------------------------<br><span class="hljs-comment"># 登录验证：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">salt,s</span>):<br>    md5=hashlib.md5(salt.encode(<span class="hljs-string">'utf-8'</span>))<br>    md5.update(s.encode(<span class="hljs-string">'utf-8'</span>))<br>    <span class="hljs-keyword">return</span>(md5.hexdigest())<br>username=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入用户名：'</span>)<br>password=<span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入密码：'</span>)<br>password=func(username,password)<span class="hljs-comment"># 需要将用户输入的用户名和密码进行加密后再去判断。</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">if</span> f.readline().strip() == username <span class="hljs-keyword">and</span> f.readline().strip() == password:       <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'登录成功！'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'登录失败！'</span>)<br><br><span class="hljs-comment"># 对文件进行加密：</span><br><span class="hljs-keyword">import</span> hashlib<br><br>md5=hashlib.md5(<span class="hljs-string">b'ab566daf'</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'user.txt'</span>,<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        md5.update(line)<br><span class="hljs-built_in">print</span>(md5.hexdigest())<br>运行结果：<br>f87f39c6f3744ac2d185246d18561cc4<br><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h3><ul><li><p>主要封装了文件和文件夹的相关操作，比如文件复制粘贴，文件移动，文件夹的复制，移动等。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> shutil<br><br>shutil.move(<span class="hljs-string">"test.mp4"</span>,<span class="hljs-string">'video/'</span>) <span class="hljs-comment"># 把当前目录下的test.mp4文件移动到video目录内。</span><br>shutil.copy(<span class="hljs-string">"test2.py"</span>,<span class="hljs-string">"video/test2.py"</span>) <span class="hljs-comment"># 复制文件+权限。</span><br>shutil.copy2(<span class="hljs-string">"test2.py"</span>,<span class="hljs-string">"video/test2.py"</span>) <span class="hljs-comment"># 复制文件+权限+时间。</span><br>shutil.copytree(<span class="hljs-string">"img/"</span>,<span class="hljs-string">"img_bak/"</span>) <span class="hljs-comment"># 复制文件夹，文件夹内的文件也一起会复制。</span><br>shutil.rmtree(<span class="hljs-string">"img_bak/"</span>) <span class="hljs-comment"># 删除文件夹。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><ul><li>logging代码模块不用记，只需要知道怎样用就行了（日志等级）。</li></ul><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># filename:文件名。</span><br><span class="hljs-comment"># format:日志格式。最终在日志文件中显示的样子：时间-名称-级别-模块：错误信息。</span><br><span class="hljs-comment"># level:日志级别，有debug、info、warning、error等。</span><br><span class="hljs-comment"># datefmt:时间格式:%Y-%m-%d %H:%M:%S。</span><br>logging.basicConfig(filename=<span class="hljs-string">'test.log'</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">'%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s'</span>,<br>                    datefmt=<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>,<br>                    level=<span class="hljs-number">0</span>) <span class="hljs-comment"># 0表示最低级别，输出所有信息,当软件交付客户使用时，应调成40，只记录错误。</span><br><br>llogging.log(<span class="hljs-number">5</span>, <span class="hljs-string">'This is a log message'</span>) <span class="hljs-comment"># 0表示最低级别，输出所有信息，在这里可以自定义级别。</span><br>logging.debug(<span class="hljs-string">'This is a debug message'</span>) <span class="hljs-comment"># 10表示最低级别，输出最少的信息。</span><br>logging.info(<span class="hljs-string">'This is an info message'</span>) <span class="hljs-comment"># 20表示最低级别，输出最少的信息。</span><br>logging.warning(<span class="hljs-string">'This is a warning message'</span>) <span class="hljs-comment"># 30表示最低级别，输出最少的信息。</span><br>logging.error(<span class="hljs-string">'This is an error message'</span>) <span class="hljs-comment"># 40表示最低级别，输出最少的信息。</span><br>logging.critical(<span class="hljs-string">'This is a critical message'</span>) <span class="hljs-comment"># 50表示最高级别，输出最重要的错误信息。</span><br>输出结果：<span class="hljs-comment"># 输出在当前目录下test.log文件中。</span><br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root Level <span class="hljs-number">5</span> test4: This <span class="hljs-keyword">is</span> a log message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root DEBUG test4: This <span class="hljs-keyword">is</span> a debug message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root INFO test4: This <span class="hljs-keyword">is</span> an info message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root WARNING test4: This <span class="hljs-keyword">is</span> a warning message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root ERROR test4: This <span class="hljs-keyword">is</span> an error message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:06:<span class="hljs-number">32</span> root CRITICAL test4: This <span class="hljs-keyword">is</span> a critical message<br><br><br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># 如何将日志到不同文件。</span><br><span class="hljs-comment"># 创建一个操作日志的对象logger。</span><br>file_handler = logging.FileHandler(<span class="hljs-string">"./log/test.log"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-comment"># f=open()</span><br>file_handler.setFormatter(logging.Formatter(<span class="hljs-string">"fmt=%(asctime)s - %(levelname)s - %(message)s"</span>))<br>logger1=logging.Logger(<span class="hljs-string">"test1"</span>,level=<span class="hljs-number">40</span>) <span class="hljs-comment"># 创建日志对象，级别为40。</span><br>logger1.addHandler(file_handler) <span class="hljs-comment"># 给日志设置文件信息。</span><br>logger1.error(<span class="hljs-string">"test1 message"</span>) <span class="hljs-comment"># 记录错误信息。</span><br><br>file_handler2 = logging.FileHandler(<span class="hljs-string">"./log/test2.log"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-comment"># f=open()</span><br>file_handler2.setFormatter(logging.Formatter(<span class="hljs-string">"fmt=%(asctime)s - %(levelname)s - %(message)s"</span>))<br>logger2=logging.Logger(<span class="hljs-string">"test2"</span>,level=<span class="hljs-number">40</span>) <span class="hljs-comment"># 创建日志对象，级别为40。</span><br>logger2.addHandler(file_handler2) <span class="hljs-comment"># 给日志设置文件信息。</span><br>logger2.error(<span class="hljs-string">"test2 message"</span>) <span class="hljs-comment"># 记录错误信息。</span><br>运行结果：<span class="hljs-comment"># 在log目录下会创建test和test2文件，内容如下。</span><br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">33</span>,<span class="hljs-number">881</span> - ERROR - test1 message<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">33</span>,<span class="hljs-number">881</span> - ERROR - test2 message<br><br><span class="hljs-comment"># 在全用时选择以下二种方式之一会按要求来记录日志。</span><br>llogging.log(<span class="hljs-number">5</span>, <span class="hljs-string">'This is a log message'</span>) <span class="hljs-comment"># 自定义。</span><br>logger2.error(<span class="hljs-string">"test2 message"</span>) <span class="hljs-comment"># 系统默认之一。</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><p>程序运行中出现错误，需要提供try…except来处理。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"程序出错了"</span>)<br>输出结果：<br>程序出错了<br><br><span class="hljs-comment"># 异常处理标准格式：</span><br><span class="hljs-keyword">try</span>:<br>    代码<br>excep 错误<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> 变量<span class="hljs-number">1</span>:<br>excep 错误<span class="hljs-number">2</span> <span class="hljs-keyword">as</span> 变量<span class="hljs-number">2</span>:<br>excep Exception <span class="hljs-keyword">as</span> e:<span class="hljs-comment">#当以上所有异常都不符合条件时，最终会执行这条异常处理语句。万能错误接收。</span><br>    最终处理<br><span class="hljs-keyword">finally</span>:<span class="hljs-comment">#上面的异常都没有发生也会运行下面代码收尾。不论是否出错都要执行finally</span><br>    <span class="hljs-built_in">print</span>()<br><br><span class="hljs-comment"># 程序也能主动抛出异常：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,b</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(a)==<span class="hljs-built_in">int</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(b)==<span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> a+b<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"非整数类型错误。"</span>)  <span class="hljs-comment"># 抛出异常，调用的该函数，谁接收该异常。</span><br><span class="hljs-comment"># 实例：</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">a,b</span>):<br>        <span class="hljs-keyword">if</span> a&gt;b:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">"a is greater than b"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"a is not greater than b"</span>)<br>    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>        main(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br>运行结果：<br>a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> greater than b<br><br><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="traceback"><a href="#traceback" class="headerlink" title="traceback"></a>traceback</h3><ul><li><p>当通过try…except捕获异常后，虽然能处理异常，但错误信息在哪里发生的不知道，如果想知道报错的信息和位置，就需要调用trackback这个模块。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"error"</span>)<br>    <span class="hljs-built_in">print</span>(traceback.format_exc())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"end"</span>)<br>输出结果：<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"d:\vscode\python\PisaApp\test4.py"</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br>end<span class="hljs-comment"># 虽然程序报错了，但下面的代码依旧会继续运行。</span><br><br><span class="hljs-comment"># 与logging结合使用：</span><br><span class="hljs-comment"># 准备好记录日志的logging</span><br>logging.basicConfig(filename=<span class="hljs-string">'test.log'</span>,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">'%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s'</span>,<br>                    datefmt=<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>,<br>                    level=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#正常写程序</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"error"</span>)<br>    logging.error(traceback.format_exc())<br>运行结果：<br><span class="hljs-number">2025</span>-03-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:03:<span class="hljs-number">26</span> root ERROR test4: Traceback (most recent call last):<br>  File <span class="hljs-string">"d:\vscode\python\PisaApp\test4.py"</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h3><ul><li><p>zipfile主要封装了和zip压缩包相关的功能。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> zipfile<br><br>f=zipfile.ZipFile(<span class="hljs-string">'log/test.zip'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-comment"># 创建压缩包。</span><br>f.write(<span class="hljs-string">'test1.py'</span>)<br>f.write(<span class="hljs-string">'test2.py'</span>)<br>f.close()<br><span class="hljs-comment">#  在log目录下生成了一个text.zip文件。</span><br><br><span class="hljs-keyword">import</span> zipfile<br><br>f=zipfile.ZipFile(<span class="hljs-string">"log/test.zip"</span>,<span class="hljs-string">"r"</span>) <span class="hljs-comment"># 打开压缩包</span><br>f.extractall(<span class="hljs-string">"log/"</span>) <span class="hljs-comment"># 解压到指定目录</span><br>f.close() <span class="hljs-comment"># 关闭压缩包</span><br><span class="hljs-comment"># 在log目录下生成test1.py和test2.py文件。</span><br><br><span class="hljs-comment"># 一个一个的解奉压缩：</span><br>f=zipfile.ZipFile(<span class="hljs-string">"log/test.zip"</span>,<span class="hljs-string">"r"</span>) <span class="hljs-comment"># 打开压缩包</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> f.namelist():<br>    f.extract(name,<span class="hljs-string">"log/see"</span>) <span class="hljs-comment"># 解压文件到指定目录</span><br>f.close() <span class="hljs-comment"># 关闭压缩包</span><br>运行结果：<span class="hljs-comment"># 将二个文件自动解压到了log目录下的see目录中，目录没有会自动创建。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><ul><li>完成文件夹的处理和命令的执行，常用的几个功能：</li></ul><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py">os.system() <span class="hljs-comment">#运行shell命令，直接显示</span><br>os.popen().read() <span class="hljs-comment">#运行shell命令，获取执行结果</span><br>os.getcwd()<span class="hljs-comment">#获取当前工作目录，即当前python脚本工作目录的路径</span><br>os.chdir()<span class="hljs-comment">#改变当前脚本工作目录，相当于shell下的cd </span><br><span class="hljs-comment">#与路径相关的os操作，都是os.path模块下的函数和方法</span><br>os.path.exists()<span class="hljs-comment"># 判断一个路径是否存在，路径可以是文件夹和文件</span><br>os.path.isdir()<span class="hljs-comment"># 判断文件夹是否存在，比上面命令更精细明确</span><br>os.path.isfile()<span class="hljs-comment"># 判断文件是否存在，比上面命令更精细明确</span><br>os.path.abspath()<span class="hljs-comment"># 返回一个文件的绝对路径</span><br>os.path.split(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)<span class="hljs-comment"># 将文件路径切割成文件夹和文件名</span><br>运行结果：(<span class="hljs-string">'d:\\vscode\\python\\PisaApp'</span>, <span class="hljs-string">'test8.py'</span>)<br><span class="hljs-built_in">print</span>(os.path.dirname(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)) <span class="hljs-comment"># 只返回文件夹</span><br>运行结果：d:\vscode\python\PisaApp<br><span class="hljs-built_in">print</span>(os.path.basename(<span class="hljs-string">r"d:\vscode\python\PisaApp\test8.py"</span>)) <span class="hljs-comment">#只返回文件</span><br>运行结果：test8.py<br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">r"d:\vscode"</span>,<span class="hljs-string">"python"</span>,<span class="hljs-string">"test.py"</span>))<span class="hljs-comment"># 拼接路径</span><br>运行结果：d:\vscode\python\test.py<br></code></pre></td></tr></tbody></table></figure><h3 id="SYS模块"><a href="#SYS模块" class="headerlink" title="SYS模块"></a>SYS模块</h3><ul><li><p>所有和python解释器相关的都在sys模块</p></li><li><pre><code class="language-py">sys.argv # 可以接收到命令行参数import sysprint(sys.argv[0])运行结果：d:\vscode\python\PisaApp\test8.py # 第一个参数指程序本身。sys.exit()    #程序退出import syswhile True:    print("ljx")    sys.exit(0)    #这里只是一个描述，告诉操作系统返回了0表示正常退出    运行结果：ljx # 打印一次就退出    sys.versionimport sysprint(sys.version)运行结果：# 输出当前解释器的环境版本说明3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]sys.path  #python用来搜索模块的，又称python环境变量，import时会去这里面找import sysprint(sys.path)运行结果：['d:\\vscode\\python\\PisaApp', 'D:\\Programs\\Python\\Python312\\python312.zip', 'D:\\Programs\\Python\\Python312\\DLLs', 'D:\\Programs\\Python\\Python312\\Lib', 'D:\\Programs\\Python\\Python312', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\win32', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\win32\\lib', 'D:\\Programs\\Python\\Python312\\Lib\\site-packages\\Pythonwin']sys.path.append()    # 可以附加上需要用到的模块，放到python环境变量中去sys.platformprint(sys.platform)输出结果：win32 # 描述不准确，知道是win系统就行<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br>+ <br><br>+ <br><br><span class="hljs-meta">## socket</span><br><br>+ socket英文翻译过来是插座意思，它本身不是一个协议，是一个套接字，操作系统为了方便大家直接使用TCP协议而存在的一个抽象层，它把复杂的tcp/ip协议隐藏在接口后面。<br><br>  ```py<br>  <span class="hljs-meta"># socket服务器端</span><br>  import socket<br>  <br>  <span class="hljs-keyword">server</span>=socket.socket()<br>  <span class="hljs-meta"># 绑定地址和端口</span><br>  <span class="hljs-keyword">server</span>.bind((<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">8080</span>))<br>  <span class="hljs-keyword">server</span>.listen()<br>  <span class="hljs-meta"># 循环阻塞等待客户端连接</span><br>  <span class="hljs-keyword">while</span> True:<br>      <span class="hljs-keyword">client</span>,addr=<span class="hljs-keyword">server</span>.accept() <br>      <span class="hljs-meta">#client为客户端对象，表示与客户端建立了一个独立的通道，addr为客户端地址。 </span><br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">'客户端地址:'</span>,addr)<br>      <span class="hljs-meta"># 接收客户端数据</span><br>      data=<span class="hljs-keyword">client</span>.recv(<span class="hljs-number">1024</span>)<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">'客户端数据:'</span>,data.decode())<br>      <span class="hljs-meta"># 发送数据给客户端</span><br>      <span class="hljs-keyword">client</span>.send(b<span class="hljs-string">'hello'</span>)<br>      <span class="hljs-meta"># 关闭客户端连接</span><br>      <span class="hljs-keyword">client</span>.close()<br>  <br>  <br>  <span class="hljs-meta"># socket客户端</span><br>  import socket<br>  <br>  <span class="hljs-keyword">client</span>=socket.socket()<br>  <span class="hljs-meta"># 绑定地址和端口</span><br>  <span class="hljs-keyword">client</span>.connect((<span class="hljs-string">'127.0.0.1'</span>,<span class="hljs-number">8080</span>))<br>  <span class="hljs-meta"># 发送的数据为字节类型。有二种方法：</span><br>  <span class="hljs-meta"># client.send(b'Hello,Server!')</span><br>  <span class="hljs-keyword">client</span>.send(<span class="hljs-string">'Hello,Server!'</span>.encode(<span class="hljs-string">'utf-8'</span>))<br>  <span class="hljs-keyword">client</span>.close()<br>  <span class="hljs-meta"># 运行方法：先启动服务器，再运行客户端。</span><br>  运行结果：当客户端运行完后，服务端会显示客户端的IP地址和发送过来的数据。<br>  <span class="hljs-meta"># 注意：服务端的rece方法是阻塞的，当客户发送的数据小于1024时是不会立即显示结果，但当客户端关闭连接时会显示出结果。</span><br></code></pre></td></tr></tbody></table></figure></code></pre></li></ul><h2 id="html-css-javascript关系"><a href="#html-css-javascript关系" class="headerlink" title="html/css/javascript关系"></a>html/css/javascript关系</h2><ul><li><p>Html是骨骼，css是皮肤，javaScript是肌肉（能动起来），三者之间的关系可以简单理解为m-v-c</p></li><li><p>Html语法规则：</p></li><li><ul><li>各种标签：<ol><li>h系列标签：h1~h6</li><li>a超链接标签：用于负责引入网页跳转链接。内面包含有href属性，后接值为链接地址；有target属性，用于链接展示的方式，值__blank是在新窗口展示，值_self在当前窗口展示。</li><li>img图片标签：用于负责引入图片，内包含src属性，值为图片路径的链接地址。还有height等属性。</li><li>video视频标签：用于引入视频。内含src属性，值为视频链接地址。</li><li>table表标签，内有tr行标签，行标签内有td标签，存放单元格。数据抓取的时候，要注意Elements和页面源代码有区别。会渲染多出一个tbody标签。</li><li>form表单标签，内有action属性，是服务的地址，最终提交表单的地方。默认是get提交，它的特点是在url上能够看到请求的所有参数，如果不希望看到，可通过method=”post”的属性和值来更换成post提交。</li><li>input输入标签，出现在form表单内，接收用户输入。有type、name等属性。</li><li>div和span标签，这二个标签又称为素标签，与上面标签会实现一定功能不同，这二个标签没有任何功能，可塑性强，必须搭配css来使用，能修改成任意的样式，也是用得最多的地方，其中div是块级标签默认独占一行能换行，span是行级标签默认不独占一行，不能换行。随着h5的发展，又衍生出更详细的section、article、footer等素标签。</li><li>在html中想要换行的话，有二个方案：<ol><li>可以选择一些自己独占的标签</li><li>单纯的使用&lt;br/&gt;换行标签或专用于换行的段落标签&lt;p&gt;&lt;/p&gt;</li></ol></li></ol></li></ul></li><li><p>CSS又称为层叠样式表，能让页面好看，语法规则：属性：值；属性：值1 值2 值3；</p></li><li><ul><li><p>作用CSS有三种方式</p><ol><li><p>可以直接在标签上给出style，在style中给出样式内容，这时候这个style就是这个标签的属性。</p></li><li><p>可以在html中使用&lt;style&gt;标签，可以写在head标签内面或外面，通过选择器去选择你页面上某个标签，给某个标签添加样式。如果标签内有class的类属性，可以直接使用class类属性值来添加样式。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">css选择器：<br>标签选择器：<br>    <span class="hljs-comment"># 选择标签</span><br>    标签{<br>            <br>        }<br>    类选择器<br>        <span class="hljs-comment"># 选择页面中class="xxx"的标签</span><br>        .xxx{<br>            <br>        }<br></code></pre></td></tr></tbody></table></figure></li></ol></li></ul></li><li><p>网页里面 使用的编程语言是 <code>JavaScript</code> ，简称 <code>js</code>，目前主流浏览器已经基本支持ES6版本</p></li><li><p>js代码可以包含在网页中，发明 js 的目的，就是放在网页中，让网页 <code>动</code> 起来，称为一个交互式的应用程序，而不仅仅式展示文章类的信息</p></li><li><p>js 是解释性的编程语言，由js解释器解释执行</p></li><li><p>现代的浏览器 包括 Chrome、火狐、Edge、Safri 都内置了js解释器，解释执行 js 代码</p></li><li><p>js 语言不仅仅只在浏览器中使用做前端开发，js语言已经走出了浏览器，用于其他领域，比如：后端服务开发、实时通讯、移动App开发（React Native）、桌面应用程序开发（Electron）等等</p><p>比如 <code>Node.js</code> 就是一个独立的js解释器（就像Python解释器一样），可以运行任何用js代码编写的应用程序</p></li><li><p>js 为什么能让网页实现动态的功能？因为 浏览器给了网页中的js 几个重要的能力：</p></li><li><ul><li>获取网页的内容</li><li>更改网页的内容</li><li>当某个事件发生时得到通知</li><li>和服务端进行通讯</li></ul></li><li><p>我们常见的包含js执行引擎的软件： 一个是 <code>浏览器</code> 、另外一个是 <code>node.js</code></p><ol><li><p>浏览器：</p><p>打开浏览器，按F12，打开 <code>开发者工具栏（英文叫 DevTools）</code> 界面，然后点击 <code>控制台（Console）</code></p><p>这 Console 就是一个 js的 交互式代码输入界面。我们编写网页的时候，要执行功能的js代码，不可能让用户手动敲，而是放到网页里面。这包含两种方式： <code>HTML内嵌js代码</code> 和 <code>HTML引用外部js代码文件</code>网页内嵌的js代码 应该放在标签 <code>script</code> 中，成为一个 <code>script</code> 元素。包含js代码的 script元素， 通常可以放在html的 <code>head</code> 或者 <code>body</code> 元素里面。</p><p>我们知道 CSS 可以嵌入 html，也可以独立在html外面，同样，我们还可以把js内容放到另外一个文件，比如 my.js ，然后html里面声明引用它</p></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//数据类型</span><br>数字类型：整数和小数，在<span class="hljs-variable constant_">JS</span>解释器内部都是存储为“双精度浮点数”，在 <span class="hljs-title class_">JavaScript</span> 解释器看来，整数 和 小数 都是一样的，都是 数字类型，这和很多其他编程语言（<span class="hljs-title class_">Java</span>、<span class="hljs-title class_">Python</span>、C 等等）不同。<br><span class="hljs-comment">//表达式</span><br>带 加减乘除 运算符的，能够产生出一个结果数据的一段代码，术语叫做表达式。我们可以用 <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> 将表达式的结果输出到界面上。<br><span class="hljs-comment">//js语句结尾可以加分号也可以不加</span><br>因为即使你不加分号，js引擎执行时会自动加上分号<br><span class="hljs-comment">//变量和注释</span><br>我们把 js 语言中数据的名字, 称之为 变量名 ， 有时也简称 变量。所以 js 中的变量，就是 数据的名字。<br>定义变量使用 关键字 <span class="hljs-keyword">let</span> 或者 <span class="hljs-keyword">var</span> ，变量名 和 数据 之间 用 等号 连接。注意：在js 中 变量名是大小写敏感的。js 定义变量时 可以不指定初始值。<br>变量的值发生变化有两种情况：一是变量名 对应新的数据，这种情况也被称之为 变量重新赋值；二是变量数据 本身发生了变化，表现在js中 数组 和 <span class="hljs-title class_">Objects</span> 是可变数据类型，当变量对应的数据是可变数据类型，可以通过变量名改变其内容。<br>js 的注释有 单行注释 和 多行注释 <span class="hljs-number">2</span>种：<br>单行注释 以 <span class="hljs-comment">// 开头，后面的内容都是注释</span><br>多行注释 以 <span class="hljs-comment">/* 注释内容 */</span><br><span class="hljs-comment">//字符串数据</span><br>js中， 一个字符串数据的类型是 字符串（<span class="hljs-title class_">String</span>）<br>字符串定义前后的引号，只是告诉解释器，引号内部 的内容就是一个字符串对象的内容。而引号本身并不是字符串的内容。<br>字符串还可以 用 单引号 、双引号 、 反引号，其中反引号(backticks)引起来的称之为 模板字符串 ， 可以 直接写内容有多行 的字符串。如果不使用反引号定义字符串， 通常只能在字符串中 使用 \n 转义符表示换行。<br>字符串拼接：js引擎发现 字符串和其它类型的数据用+号连接，就会先把 其它类型的数据先转化为 对应的字符串，然后再拼接。<br>字符串就是由一个个 元素 - 字符 组成的。像这种由一个个 元素依次组成的字符串， js 语言里面，把这种特性的数据称之为 sequence，翻译成中文就是序列。字符串就是一种序列。<br>序列里面的元素都是有索引的。 所谓索引就是元素的下标，字符串元素的索引是从 <span class="hljs-number">0</span> 开始，而不是从<span class="hljs-number">1</span> 开始。<br>获取字符串长度：字符串对象有个属性 length 可以用来获取字符串的长度，也就是获取字符串中字符的个数。<br><span class="hljs-comment">//定义函数</span><br>定义一个名字 对应多个语句操作， 称之为定义函数，所以：定义函数 就好像是给 一段代码 起了个名字。<br><span class="hljs-keyword">function</span> 是关键字 表示定义一个函数，后面是函数的名字，紧接着后面需要一个括号 ，这个括号中间，根据需要还可以有 参数，最后函数里面要执行的所有代码 放在一个花括号中，表示这个函数名字代表的具体动作是什么，称之为函数体。<br><span class="hljs-comment">//调用函数</span><br>调用函数的时候，如果 传如的参数值个数 比定义参数的个数少，有的参数没有传值，js引擎会自动传入一个 <span class="hljs-literal">undefined</span> 值。调用函数的时候，如果 传如的参数值个数 比定义参数的个数多，多余的参数会在执行函数时被丢弃。<br><span class="hljs-comment">//参数缺省值</span><br>没有特别指定的情况下, 函数的参数的缺省值就是 <span class="hljs-literal">undefined</span> ，如果你调用的时候没有给某个参数传值，其值就是 <span class="hljs-literal">undefined</span><br><span class="hljs-comment">//变量的有效范围</span><br>变量的有效范围有<span class="hljs-number">3</span>种：全局 <span class="hljs-title class_">Global</span> scope；函数内部 <span class="hljs-title class_">Function</span> scope；代码块 <span class="hljs-title class_">Block</span> scope<br>定义在所有函数外部的变量，称之为 全局变量 。全局变量的有效范围是整个代码文件。函数内部代码 可以访问 全局变量的。<br>定义在某个函数内部的变量，称之为 局部变量 。函数的 参数变量 也是 局部变量，局部变量有效范围只能是该函数内部。<br>在 <span class="hljs-title class_">ES6</span>（<span class="hljs-number">2015</span>）之前，<span class="hljs-title class_">JavaScript</span> 只有 <span class="hljs-title class_">Global</span> <span class="hljs-title class_">Scope</span> 和 <span class="hljs-title class_">Function</span> <span class="hljs-title class_">Scope</span>。<span class="hljs-title class_">ES6</span> 引入了两个重要的新 <span class="hljs-title class_">JavaScript</span> 关键字： <span class="hljs-keyword">let</span> 和 <span class="hljs-keyword">const</span><br>这两个关键字在 <span class="hljs-title class_">JavaScript</span> 中提供了 代码块作用域 。{ } 花括号代码块内声明的变量不能从块外访问，如果要在代码块外访问只能通过<span class="hljs-keyword">return</span>返回的值来使用。<br><span class="hljs-comment">//var vs let</span><br><span class="hljs-keyword">var</span> 和 <span class="hljs-keyword">let</span> 都可以定义一个变量.<span class="hljs-property">let</span> 定义的变量如果在块内, 有效范围只能在本代码块内.<br>而 <span class="hljs-keyword">var</span> 定义的变量如果在块内, 其有效范围却可以是整个函数<br><span class="hljs-comment">//一些内置函数</span><br>输入框 - prompt 函数，以让浏览器弹出一个对话框，提示让用户输入单行文本信息<br>提示框 - alert 函数，可以让浏览器弹出一个对话框，提示用户一段信息<br>确认框 - confirm 函数，可以让浏览器弹出一个对话框，让用户确认一段信息，并选择是或者否<br><span class="hljs-built_in">parseInt</span>、<span class="hljs-built_in">parseFloat</span>，可以使用 <span class="hljs-built_in">parseInt</span> 函数，把字符串表示的数字转化为 整数，<br>可以使用 <span class="hljs-built_in">parseFloat</span> 函数，把字符串表示的数字转化为 数字（整数或小数）<br><span class="hljs-comment">//判断语句</span><br>布尔数据只有两种取值： <span class="hljs-literal">true</span> 和 <span class="hljs-literal">false</span><br>运算结果是布尔值的表达式 ，就是 布尔表达式。<br>是否相等：用 === <span class="hljs-number">3</span>个等号连接两个比较对象，== <span class="hljs-number">2</span>个等号连接两个比较对象，判断是否相等<br>这种 <span class="hljs-number">2</span>个等号比较 叫 松散相等比较（<span class="hljs-title class_">Loose</span> <span class="hljs-title class_">Equality</span> <span class="hljs-title class_">Comparison</span>） ，<br>而 <span class="hljs-number">3</span>等号比较 称之为 严格相等比较（<span class="hljs-title class_">Strict</span> <span class="hljs-title class_">Equality</span> <span class="hljs-title class_">Comparison</span>）<br>是否不相等：!== 和 !=<br>!== 的比较 称之为 严格不相等比较（ <span class="hljs-title class_">Strict</span> inequality <span class="hljs-title class_">Comparison</span>）<br>!= 的比较 称之为 松散不相等比较（ <span class="hljs-title class_">Loose</span> inequality <span class="hljs-title class_">Comparison</span>）<br>表达式逻辑操作：布尔表达式 主要有<span class="hljs-number">3</span> 种逻辑操作 ：<br>且（and） 、 或（or） 、 非（not） ， 分别对应 &amp;&amp; 、 || 、 ! <span class="hljs-number">3</span>种逻辑操作符<br>如果 ! 、 &amp;&amp; 和 || 一起使用， 优先级是 ! &gt; &amp;&amp; &gt; ||，就是先计算 ! ， 再计算 &amp;&amp; 部分， 最后再计算 ||<br>以上布尔表达式操作的结果<span class="hljs-literal">true</span>和<span class="hljs-literal">false</span>主要是用在判断语句中<br>判断语句是以 <span class="hljs-keyword">if</span> 关键字开头,<span class="hljs-keyword">if</span>后面的逻辑表达式一定要用括号括起来,<span class="hljs-keyword">if</span> 对应的后续执行代码如果只有一行，可以省略花括号<br><span class="hljs-keyword">else</span> 表示在 <span class="hljs-keyword">if</span> 后面的条件不成立时，要做一些事。<br><span class="hljs-keyword">if</span> ... <span class="hljs-keyword">else</span> 构成了一种 非此即彼 的判断关系。<br>有的时候，情况更加复杂，还需要更多的判断，js中可以 使用更多的 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 。<br>注意 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 和 <span class="hljs-keyword">else</span> 的区别是 ：<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 后面会有一个 条件表达式， 而 <span class="hljs-keyword">else</span> 没有<br><span class="hljs-keyword">if</span> 语句后面也可以没有<span class="hljs-keyword">else</span> 或者 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><br><span class="hljs-comment">//条件赋值:</span><br><span class="hljs-keyword">var</span> fee = miles &gt; <span class="hljs-number">3</span> ? miles*<span class="hljs-number">15</span> : miles*<span class="hljs-number">20</span><br>如果条件评估为真，则冒号左侧的值将分配给变量。 如果条件评估为假，则冒号右侧的条件将分配给变量。<br><span class="hljs-comment">//对象和属性</span><br>js中 对象（<span class="hljs-title class_">Object</span>） 可以和现实世界中的对象 概念对应<br>就是包含了一组 属性（<span class="hljs-title class_">Property</span>） 的数据， 属性可以是包含其它属性的对象。<br><span class="hljs-number">1.</span>创建对象： 使用字面标记,创建一个 <span class="hljs-title class_">Object</span> 类型的数据 有多种方法，最常见的就是直接 js语言 字面标记（literal notation） 构建<br><span class="hljs-keyword">var</span> myCar = {<br>    <span class="hljs-string">'brand'</span>   : <span class="hljs-string">'奔驰'</span>,<br>    <span class="hljs-string">'country'</span> : <span class="hljs-string">'德国'</span>,<br>    <span class="hljs-string">'price'</span>   : <span class="hljs-number">300000</span><br>}<br>这里面的 brand/country/price 都是对象的 属性（英文叫 properties ）。<br>属性之间用逗号隔开，最后一个属性后面可以不用加逗号。<br>有时，我们也把 属性名 称之为 对象的 key（键）<br>访问对象的属性，语法是 对象.属性,或者 对象[<span class="hljs-string">'属性名'</span>],这种写法常用于属性名在写代码时不确定，是变量的情况<br>动态更改属性:添加属性,myCar.<span class="hljs-property">year</span> = <span class="hljs-string">'2021-3-3'</span> 或者 myCar[<span class="hljs-string">'year'</span>] =  <span class="hljs-string">'2021-3-3'</span><br>修改属性：如果赋值语句前面的的属性名已经存在，会覆盖原来的属性值<br>删除属性：如果你要删除对象中一个属性，可以使用 操作符 <span class="hljs-keyword">delete</span><br>比如：<span class="hljs-keyword">delete</span> myCar.<span class="hljs-property">year</span> 或者 <span class="hljs-keyword">delete</span> myCar[<span class="hljs-string">'year'</span>]<br>函数作为对象属性：对象的属性也可以是函数，比如<br><span class="hljs-keyword">var</span> myCar = {<br>    brand   : <span class="hljs-string">'奔驰'</span>,<br>    country : <span class="hljs-string">'德国'</span>,<br>    price   : <span class="hljs-number">300000</span>,<br>    showInfo : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">country</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span>)<br>    }<br>}<br>对象的函数属性，通常也被叫做对象的 方法（英文叫 method ），对象 的方法其实可以看成是对象所拥有的函数。<br>调用对象的方法，语法是 所属对象.属性()<br>在 <span class="hljs-title class_">JavaScript</span> 中， <span class="hljs-variable language_">this</span> 关键字 代表了 当前执行环境，术语是<span class="hljs-title class_">Context</span>，上下文的意思。<br>就是指 调用这个方法 所通过的那个对象 ，也就是 . 前面的对象<br>通过 myCar.<span class="hljs-title function_">showInfo</span>() 这行代码调用的showInfo，里面的 <span class="hljs-variable language_">this</span>就是 myCar 对象<br><span class="hljs-number">2.</span>创建对象：使用构造函数<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand, country, price</span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">country</span> = country<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price<br>}<br><span class="hljs-keyword">var</span> myCar1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'凯美瑞2020'</span>, <span class="hljs-string">'日本'</span>, <span class="hljs-number">200000</span>);<br><span class="hljs-keyword">var</span> myCar2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'特斯拉Model 3'</span>, <span class="hljs-string">'美国'</span>, <span class="hljs-number">300000</span>);<br>这里的 <span class="hljs-title class_">Car</span> 就是一个构造函数。<br>构造函数其实本质上就是一个函数。任何函数都可以当作构造函数来使用。<br>只是，用来构造的函数里面，通常会 为将来所要构造对象 设置一些属性。<br>函数里面的 <span class="hljs-variable language_">this</span> 就代表了要构建的对象，<br>使用 <span class="hljs-keyword">new</span> 操作符 后面调用构造函数，并传入参数，这样构建的对象就会拥有这些属性<br>通常，我们可以说，myCar1、myCar2 就是一个 <span class="hljs-title class_">Car</span> 类型的 对象 ， 或者 对象实例<br>原型 和 原型链：<br>内置构造函数 <span class="hljs-title class_">Object</span>，js 有个内置的构造函数 <span class="hljs-title class_">Object</span>，<span class="hljs-title class_">Object</span> 翻译成中文，也叫 对象，为方便区分，我直接用 英文 <span class="hljs-title class_">Object</span> 称呼它，不给他起中文名<br>直接 字面标记语法<br><span class="hljs-keyword">var</span> myCar = {<br>    brand   : <span class="hljs-string">'奔驰'</span>,<br>    country : <span class="hljs-string">'德国'</span><br>}<br>实质上是js引擎对这样的写法会自动调用<span class="hljs-title class_">Object</span>构造函数<br><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>myCar.<span class="hljs-property">brand</span> = <span class="hljs-string">'奔驰'</span><br>myCar.<span class="hljs-property">country</span> = <span class="hljs-string">'德国'</span><br>所以，所有 用 字面标记 创建的对象 都是 <span class="hljs-title class_">Object</span> 类型的 对象实例。<br>函数本身也是对象，也可以为其动态的添加属性<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>){<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'in func1'</span>)<br>}<br>func1.<span class="hljs-property">name</span> = <span class="hljs-string">'func1'</span><br>func1.<span class="hljs-property">desc</span> = <span class="hljs-string">'func1 函数的作用是...'</span><br>使用原型创建对象：内置函数 <span class="hljs-title class_">Object</span> 有个 create 方法（函数对象也可以有自己的方法属性）可以用它直接创建对象。<br>对象会 继承（inherit） 原型链 对象 里面的属性。如果对象自身属性和 原型链上的属性 同名，使用哪个，按原型链次序，首先会优先使用自身属性<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>，原型链最后一环，其实：js中所有的对象 的原型链 最后都是终结于 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>，所以，js 所有的对象都可以访问 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 里面的属性<br>myCar1.<span class="hljs-title function_">toString</span>()<br>myCar1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'owner'</span>)<br>myCar1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'type'</span>)<br>toString 和 hasOwnProperty 都是 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 里面的属性<br>toString 是把对象转化为字符串表示的，对象可以自己添加该属性方法，重新实现该方法。在打印结果和字符串格式化拼接时有用。<br>hasOwnProperty 是用来判断参数 是否是 对象自身的属性<br>对象常见操作：<br>检查对象是否有某个属性，可以使用 hasOwnProperty<br>得到对象所有属性，<span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span> 方法可以返回 对象的 所有属性名 一个数组<br>得到对象所有属性和值，<span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span> 方法可以返回 对象的 所有属性和值 到一个数组，方便我们遍历<br><span class="hljs-comment">//数组</span><br>数组的概念：js 有内置的构造函数 <span class="hljs-title class_">Array</span> 。构造出的对象被称为 数组对象 ，或者直接简称 数组，里面存储的数据，通常被称之为数组的 元素<br>索引：可以用元素 索引 的方式取出里面的元素<br>切片 slice：js 中的 字符串 和 数组 ，都有 slice 方法可以进行切片<br>改变数组内容：和我们前面学过的其它数据类型不同，数组对象有个特点，它的内容是 可以变化的<br>末尾添加 push，push方法就会改变数组的内容，在后面添加一个元素。<br>末尾取出元素 pop，如果我们要从数组 末尾取出元素 一个元素，就可以使用 pop 方法。pop 方法的返回值 是 取出来的元素<br>开头取出元素 shift<br>如果我们要从数组 开头取出元素 一个元素，就可以使用 shift 方法。shift 方法的返回值 是 取出来的元素，注意，取出后，该元素就从数组中删除了。<br>指定位置删除 splice，splice 方法可以 删除 数组的一段内容<br>指定位置替换 splice，splice 方法也可以 替换 数组的一段内容。替换就是 删除后再插入内容， splice从第<span class="hljs-number">3</span>个开始，以后的参数都是要插入的元素。这种写法称之为 切片赋值<br>指定位置插入 splice，如果我们 不是要在后面 添加一个元素， 而是在 指定位置插入一个元素怎么办？还是可以使用 splice 方法，第<span class="hljs-number">2</span>个参数 删除个数 设置为 <span class="hljs-number">0</span><br>数组元素倒过来 reverse：reverse方法将数组元素倒过来<br>获取元素索引 indexOf，indexOf 方法返回 参数对象 在数组 中的位置，也就是索引<br>检查是否包含 includes：数组的 includes 方法 返回数组中是否包含参数指定的数据，返回值为 <span class="hljs-literal">true</span> 表示存在，<span class="hljs-literal">false</span> 表示不存在<br>清空数组<br>方法<span class="hljs-number">1</span> ：变量赋值<br>如果我们是想让某个变量对应的数组为空，可以这样：<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1 = [];<br>方法<span class="hljs-number">2</span> ：设置数组长度<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>设置数组长度为<span class="hljs-number">0</span>，这样一个数组里面的内容就会被清空<br>方法<span class="hljs-number">3</span> ：使用splice<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>];<br>arr1.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, arr1.<span class="hljs-property">length</span>)<br>拼接字符串 join：join 就是用参数里面的字符串连接数组里面的元素，返回值就是拼接后的字符串<br>多个变量同时赋值<br>我们可以像下面这样把 数组 中的元素直接赋值给变量<br><span class="hljs-keyword">var</span> x1, x2, x3, x4<br>[x1, x2, x3, x4] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x1, x2, x3, x4)<br>这种方式的术语叫： 解构赋值（<span class="hljs-title class_">Destructuring</span> assignment ）解构赋值时，如果变量的个数 多于 等号右边的 值个数，有的变量值就是 <span class="hljs-literal">undefined</span>。<br><span class="hljs-keyword">const</span> 定义变量：<span class="hljs-keyword">const</span> 定义的变量，必须在定义时就赋值，后续不能重新赋值，也就是说： <span class="hljs-keyword">const</span> 变量指向的对象 定义后就不能改变，但是<span class="hljs-keyword">const</span>定义的变量 指向的对象内容变化是可以的<br>map方法：对数组中的每个元素进行同样的处理，产生另外一个数组，参数是一个函数对象，就是对每个元素的处理函数<br><span class="hljs-comment">//字符串、数字对象</span><br>实际上，几乎所有的js数据类型，原型链最终都是 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ，所以几乎所有的js数据类型的实例，都可以说是一个 对象，它们都可以使用 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 的属性方法，和自身原型的属性方法。<br>而下面的定义：<br><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">356</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">'您好'</span><br>它们是 primitive （ 原语 ）数据， 不是对象数据，primitive 数据 没有 属性，底层实现 往往就是 直接对应 存储在内存的 数据，所以非常高效。<br>primitive数据是不能改变的。<br>字符串对象，字符串对象 <span class="hljs-title class_">String</span> 有如下常用的属性方法<br>length，返回字符串对象的长度<br>indexOf<br>字符串的 indexOf 方法 和 数组的 indexOf 方法类似，它用来在字符串中查找 参数字符串，并返回该 参数字符串 在其中 第一个 出现的位置索引，如果字符串对象里面 没有 要查找的参数字符串，就会返回 -<span class="hljs-number">1</span>，indexOf 方法 的第二个参数，用来指定 查找起始位置 <br>切片 slice<br>split：split 方法以参数字符串为分割符 ，将字符串 切割为多个 字符串，作为元素存入一个数组，并返回这个数组。分隔符本身在切割后，会被丢弃掉，所以切割后的字符串中不会有分隔符。<br>trim、trimStart、trimEnd<br>trim 方法可以 删除 字符串前面和后面的空白字符，比如空格、tab符， 以及行终结符， 比如回车、换行等等<br>trimStart 方法 将 字符串前面 (左边) 的空格删除，但是不会删除字符串中间和右边的空格<br>trimEnd 方法 将 字符串后面 (右边) 的空格删除，但是不会删除字符串中间和左边的空格<br>replace 也是常用的方法，用来 替换 字符串里面 第一个 指定的 子字符串 为另一个 字符串<br>新版本的浏览器 支持 replaceAll 方法。replaceAll 方法，用来 替换 字符串里面 所有指定的 子字符串 为另一个 字符串<br>startsWith 和 endsWith<br>startsWith 方法检查字符串是否以参数指定的字符串 开头，如果是，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>endsWith 方法检查字符串是否以指定的字符串 结尾，如果是，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>字符串模板:就是在字符串使用 反引号 ，然后占位符使用 ${} ,里面直接放入对应的数据对象。<br>转义符:\n 就是一个转义字符，表示一个换行字符,用 \t 表示tab字符,用 \x41 表示 <span class="hljs-variable constant_">ASCII</span>编码为<span class="hljs-number">0x41</span>的字符（也就是字符 A），用 \u767d 表示 unicode编码为<span class="hljs-number">0x768d</span>的字符（也就是汉字 白）<br>也可以 使用反引号 ，在字符前面加上一个 <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span> ，表示字符串内容是raw string， 无需转义，像这样<br>path = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`c:\windows\temp`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path)<br>数字对象<br>数字对象<span class="hljs-title class_">Number</span> 有如下常用的属性方法<br><span class="hljs-built_in">parseInt</span>、<span class="hljs-built_in">parseFloat</span><br>可以使用 <span class="hljs-title class_">Number</span> 的 <span class="hljs-built_in">parseInt</span> 方法，把字符串表示的数字转化为 整数，<br>可以使用 <span class="hljs-title class_">Number</span> 的 <span class="hljs-built_in">parseFloat</span> 方法，把字符串表示的数字转化为 数字（整数或小数）<br>toString<br>可以使用 <span class="hljs-title class_">Number</span> 的 toString 方法，把字符串表示的数字转化为 整数<br><span class="hljs-comment">//循环</span><br>js 中有<span class="hljs-number">3</span>种类型的循环: <span class="hljs-keyword">while</span>循环 、 <span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>循环 和 <span class="hljs-keyword">for</span> 循环<br><span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span> 循环 肯定要先执行一次循环体内代码， 然后再判断是否继续循环的条件。<br>而 <span class="hljs-keyword">while</span> 循环 是 一开始就要先判断循环条件是否成立， 成立后再执行循环体代码。<br><span class="hljs-keyword">for</span> 循环更适合 循环执行某段代码 指定次数<br><span class="hljs-keyword">for</span> 循环的 后面那个括号里面有<span class="hljs-number">3</span>个语句组成<br><span class="hljs-keyword">for</span> (循环前执行代码; 循环继续与否判定表达式; 单次循环后执行代码) {<br>  <span class="hljs-comment">// 循环体代码</span><br>}<br>循环前执行代码：是 整个 <span class="hljs-keyword">for</span>循环前 要执行的代码，只执行<span class="hljs-number">1</span>次。<br>循环继续与否判定表达式：是每次循环前用来判定是否继续执行本次循环的表达式。<br>单次循环后执行代码：是每次循环后 要执行的一次语句，常用来执行 循环次数标记变量 的值变化<br>遍历数组<br>可以这样遍历数组，使用 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">of</span> 写法：这种写法适合遍历可遍历对象，比如 字符串<span class="hljs-title class_">String</span>、数组<span class="hljs-title class_">Array</span>、<span class="hljs-title class_">TypedArray</span>, <span class="hljs-title class_">Map</span>, <span class="hljs-title class_">Set</span> 等等。每次循环，都会依次，取出 <span class="hljs-keyword">of</span> 后面的数组里面的对象，赋值给 <span class="hljs-keyword">of</span> 前面定义的变量，执行循环体里面的代码<br>遍历对象<br>如果我们需要遍历一个对象里面的所有属性和值，怎么办？<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span> 方法可以返回 对象的属性和值 到一个数组，方便我们遍历，然后使用 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">of</span> 遍历数组<br><span class="hljs-keyword">break</span> 终止循环<br>解释器执行到 循环内的 <span class="hljs-keyword">break</span> 语句，就会从循环退出。<br><span class="hljs-keyword">continue</span>：只结束当前这一轮循环，后面还要继续循环的执行。<br><br><span class="hljs-comment">//类和继承</span><br>类型是 具有共同特征（属性、行为）的对象 的 特性 的定义。是特征的集合<br>js中对象种类的共同特性 的提取定义， 是 通过 原型对象（包括构造函数） 实现的。<br>定义类使用关键字 <span class="hljs-keyword">class</span> 后面加 类的名称。紧跟类名 后面的花括号里面的所有内容就是 类定义，是该类的所有 属性（方法）的定义。<br>从定义的类来 创建对象 也是使用 <span class="hljs-keyword">new</span> 操作符，后面加上类名和括号，括号里面的参数是传递给 类定义里面 名为 constructor 的方法的 。constructor 被称之为构造函数， 作用类似前面讲的独立构造函数。<br>这个方法在 使用 <span class="hljs-keyword">new</span> 创建这个类 对应的 对象时，会被解释器自动调用 ，并且传入<span class="hljs-keyword">new</span> 语句里面的参数。<br>类里面定义的函数（包括constructor） 可以叫类的方法， 都是 不需要 <span class="hljs-keyword">function</span> 关键字 声明的<br>前面，我们说过 构造函数 也可以看作类型， 构造产生的对象 ，就是 这个构造函数类型的实例。<br>类的继承关系<br>通常我们把被继承的类称之为 父类 或者 基类 或者 超类<br>把继承类称之为 子类 或者 派生类。<br>类的继承关系可以通过关键字 extend<br>子类会自动拥有父类的一切属性和方法，子类和父类不同的地方，可以重新定义<br>子类 实例化时，如果构造函数里面行为 和 父类不完全一样，这时候，就需要 重定义 constructor 函数 。<br>可以直接使用关键字 <span class="hljs-variable language_">super</span> 直接调用父类的constructor代码<br>注意 <span class="hljs-variable language_">super</span>不仅仅可以代表调用父类的构造函数方法，也可以调用父类的其他方法<br><span class="hljs-comment">//错误对象</span><br>js 还有其他的错误类型， 都是继承自 <span class="hljs-title class_">Error</span> 类型，代表各种不同类型的错误。<br>抛出错误<br>抛出错误, 使用关键字 <span class="hljs-keyword">throw</span> ，后面加一个错误对象，这里是新构建一个对象，直接使用 <span class="hljs-title class_">Error</span> 构造函数创建。<br>执行完 <span class="hljs-keyword">throw</span> 抛出异常的代码后， 后续的代码不会再执行<br>捕获错误<br>使用 <span class="hljs-keyword">try</span>... <span class="hljs-keyword">catch</span> ... 这样的语法来捕获和处理错误。<br><span class="hljs-keyword">try</span> 下面缩进的花括号里面的代码可以看成是 监控区 中的代码。<br><span class="hljs-keyword">catch</span> 引导的代码段 就是对 错误 的一种处理。<br><span class="hljs-keyword">try</span> ... <span class="hljs-keyword">catch</span> 后面还可以跟一个 <span class="hljs-keyword">finally</span> 代码块。<br><span class="hljs-keyword">finally</span> 代码块的代码， 不管<span class="hljs-keyword">try</span> 里面有无错误抛出，都要执行的。<br><span class="hljs-comment">//剩余参数</span><br>函数参数的 个数是不确定的，前面加 <span class="hljs-number">3</span>个点 的参数，称之为 剩余参数（rest parameters） 。<br>展开语法：在调用函数时，对于剩余参数时的传递，可以使用三个点操作符 ...，这就是 展开语法(<span class="hljs-title class_">Spread</span> syntax) <br><span class="hljs-comment">//回调、匿名函数、this</span><br><span class="hljs-comment">// 注册事件回调函数</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#go'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, salaryStats );<br>所以 salaryStats 这种 先定义，后面在某个时候被调用的函数，叫 回调函数<br>和 <span class="hljs-title class_">Python</span>、<span class="hljs-title class_">Java</span> 等语言不同，js 的执行引擎设计是 异步架构<br>这里的 异步 是什么意思呢？<br>就是 碰到阻塞性的调用，比如 定时等待、网络操作、磁盘<span class="hljs-variable constant_">IO</span>等等， js引擎都不会停止后面代码的执行来 等 这些操作完成。<br>这种异步的架构设计，设计模式里面 叫做 reactor 模式<br>系统底层实现基本都是一个 主循环处理各种事件，比如 网络socket收到数据、文件读取数据返回、定时器超时 等等。然后调用相应的 用户代码进行处理。碰到阻塞性的操作，不会等，而是记录好操作完成的回调代码，继续执行后面的用户代码。用户代码都执行完了，就返回主循环，处理下一个需要处理的事件。这种架构， 特别适合 <span class="hljs-variable constant_">IO</span> bound（也就是 高<span class="hljs-variable constant_">IO</span>，低<span class="hljs-variable constant_">CPU</span>） 的软件系统，典型的就是网站服务系统。因为它能高效的利用<span class="hljs-variable constant_">CPU</span>。<br>这个好像 操作系统多线程 调度的概念。操作系统可以让处于执行阻塞操作（读文件，等待网络消息）的线程让出<span class="hljs-variable constant_">CPU</span>执行权，让其它线程占据<span class="hljs-variable constant_">CPU</span>执行代码。这样大大减少了<span class="hljs-variable constant_">CPU</span>闲置 ，这是 操作系统 对 多个线程 的 调度<br>而异步的软件架构，是程序自身（比如js引擎）实现的 单线程 自身的内部代码 整理和调度。<br>相比 操作系统多线程方式，它的效率更高，因为，多线程调度涉及到 操作系统调用，导致 <span class="hljs-variable constant_">CPU</span>的执行模式切换，是要额外耗费资源的。而且，没有多线程操作共享资源的同步问题。因为实际上，这是单线程<br>匿名函数：使用 匿名函数 避免这种起名字的麻烦<br>匿名函数如果 单独定义在非参数位置，并且不赋值给变量，需要加上括号<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>){<br>  <span class="hljs-keyword">return</span> a + <span class="hljs-number">100</span>;<br>})<br>箭头函数<br><span class="hljs-title class_">ES6</span> 引入了 箭头函数 这种新的定义匿名函数的语法，更加精简<br>a =&gt; { <br>  <span class="hljs-keyword">return</span> a + <span class="hljs-number">100</span>;<br>}<br>如果 箭头函数 体内 只有一行代码，并且是返回一个值，可以省略 <span class="hljs-keyword">return</span> 和 花括号<br>a =&gt; a + <span class="hljs-number">100</span><br>回调函数中的<span class="hljs-variable language_">this</span>：<br>通过哪个对象调用了这个函数，函数里面的 <span class="hljs-variable language_">this</span> 对应的是就是这个对象<br>箭头函数中的<span class="hljs-variable language_">this</span>：箭头函数中的<span class="hljs-variable language_">this</span>比较特殊，它对应的 是 包含该箭头函数 的函数的执行环境<br><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="JS前端"><a href="#JS前端" class="headerlink" title="JS前端"></a>JS前端</h2><ul><li><p>怎么用 js 语言实现 <code>浏览器相关</code> 的 操作呢？浏览器运行环境 提供了 丰富了 js语言编程接口 ， 称之为 <code>Web API</code> 接口。</p></li><li><p>浏览器内置window对象：</p><ul><li><p>对应的是一个 <code>Window</code> 类型的对象，它代表了 js 运行的这个浏览器窗口环境。由于它代表的就是整个浏览器js运行环境，所以这个对象的属性方法可以直接在js代码中使用，不需要加上 <code>window.</code> 作为前缀，比如，我们前面学过的 <code>prompt、alert、confirm</code> 其实就是 window的方法</p></li><li><p>history、location：<code>history</code> 对应 就是 当前浏览器的 浏览历史对象</p></li><li><pre><code class="language-js">// 返回上次浏览地址，等于点击浏览器的返回按钮history.back();// 也是 返回上次浏览地址history.go(-1);// 前进到返回前面的地址，等于点击浏览器的前进按钮history.forward();<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><br>+ `<span class="hljs-keyword">location</span>` 对应 就是 当前浏览器的 地址对象<br><br>  ```js<br>  <span class="hljs-comment">// 设置当前浏览地址</span><br>  <span class="hljs-keyword">location</span>.href = '/main.html'<br>  <span class="hljs-comment">// 重新加载网页，等于刷新网页</span><br>  <span class="hljs-keyword">location</span>.reload()<br></code></pre></td></tr></tbody></table></figure></code></pre></li><li><p><code>localStorage</code> 可以看作一个 本地键值对数据库，它是当前网站的 前端存储，关闭浏览器窗口后也不会丢失数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存入/修改 数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myCat'</span>, <span class="hljs-string">'Tom'</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">const</span> cat = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myCat'</span>);<br><br><span class="hljs-comment">// 清除localStorage 数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>sessionStorage</code> 也是一个 本地键值对数据库，它也是当前网站的 前端存储，和 <code>localStorage</code> 的差别是， 它的数据是和session相关的。关闭浏览器窗口后，数据就会丢掉。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 清除 sessionStorage 数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-comment">// 存入/修改 数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myCat'</span>, <span class="hljs-string">'Tom'</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">const</span> cat = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myCat'</span>);<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>close()</code> 方法可以 关闭当前窗口</p></li><li><p><code>open()</code> 方法可以 打开一个新的窗口</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 打开新空窗口</span><br><span class="hljs-title function_">open</span>()<br><br><span class="hljs-comment">// 打开新窗口，访问指定url</span><br><span class="hljs-title function_">open</span>(<span class="hljs-string">'https://www.byhy.net'</span>)<br><br><span class="hljs-comment">// 直接本窗口打开访问指定url</span><br><span class="hljs-title function_">open</span>(<span class="hljs-string">'https://www.byhy.net'</span>, <span class="hljs-string">'_self'</span>)<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>DOM 文档对象模型:</p><ul><li><p>浏览器加载网页（根据html文档和一些代码） 后， 会在浏览器内部（内存中）创建一个文档对象模型 (document object model) 简称 <code>DOM</code> 对象 ， 对应 树状的 文档结构。每个html元素以及每段字符串，都会对应DOM对象的一个 <code>节点（node）</code>,它们的上下层关系和html文档对应。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tex">有如下一些DOM 相关的术语：<br><br>这个树状文档的 根节点（root node） 是 HTML节点<br><br>每个html元素 都对应一个 元素节点（Element node）<br><br>有的元素节点，有其 子节点（Child node） ，相对而言，它就是其子节点的 父节点（Parent node）<br><br>某个元素节点 分支下面所有的子节点、子节点的子节点，等等， 都是它的 后代节点（Descendant node）<br><br>相同父节点的节点 之间是 兄弟节点（Sibling nodes） 的关系<br><br>只包含一段文本字符串的节点是 文本节点（Text node）<br>特别要注意的是名词 元素（Element） 和 节点（Node） 的区别<br><br>任何 DOM对象都是一个 节点 ， 包括 元素节点、 注释节点、 文本节点、属性节点<br>节点类型节点值<br>ELEMENT<span class="hljs-built_in">_</span>NODE1<br>ATTRIBUTE<span class="hljs-built_in">_</span>NODE2<br>TEXT<span class="hljs-built_in">_</span>NODE3<br>CDATA<span class="hljs-built_in">_</span>SECTION<span class="hljs-built_in">_</span>NODE4<br>PROCESSING<span class="hljs-built_in">_</span>INSTRUCTION<span class="hljs-built_in">_</span>NODE7<br>COMMENT<span class="hljs-built_in">_</span>NODE8<br>DOCUMENT<span class="hljs-built_in">_</span>NODE9<br>DOCUMENT<span class="hljs-built_in">_</span>TYPE<span class="hljs-built_in">_</span>NODE10<br>DOCUMENT<span class="hljs-built_in">_</span>FRAGMENT<span class="hljs-built_in">_</span>NODE11<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>元素（也叫元素节点） 只是其中一种 节点，它们是对应一个html元素的， 比如 body、p、span、div 这些节点。</p></li><li><p>其它的，比如注释节点、文本节点 就不是 元素节点</p></li><li><p>整个DOM对象， 可以通过 js引擎内置对象 <code>window.document</code> 或者直接 <code>document</code> 访问到。</p></li><li><p>DOM对象中每个节点对象 都是可以通过 document对象 的一些内置方法获取到。</p></li></ul></li><li><p>网页程序示例</p><ul><li><p>现代的网站不仅仅只是富文本信息的呈现，可以 网页聊天、邮件交互、甚至可以在网页上打游戏</p><p>所以现在很多网页，其实 就是一个真正的 <code>应用程序</code> ，而不是传统意义上的 <code>网页</code> 了。</p></li><li><p>网页成为应用程序 的关键 就是 js 语言对网页内容的操作能力，主要就是： 得知网页事件、获取网页内容，改变网页内容</p></li><li><p>获取元素对象：网页应用程序，要管理界面，其实就是管理界面的一个个元素对应 的 DOM 对象。而要控制这些对象（获取信息、修改信息）， 首先得能在代码中 <code>获取这些DOM对象</code> ，然后才能调用它们的方法对其进行控制。选择对象，最灵活的方法就是使用 <code>querySelector</code> 、 <code>querySelectorAll</code> 方法，参数是 CSS 选择表达式</p></li><li><p><code>querySelector</code> 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 <code>querySelectorAll</code> 方法</p></li><li><p>事件和处理：什么时候网页 应该 执行我们写的代码？通常是某个事件发生的时候，比如用户输入数据后，按回车、 点击某个按钮、鼠标移动到某个元素上、等等。那么怎么告知浏览器，当某个事件发生，回调我们的代码呢？使用 DOM 对象的 <code>addEventListener</code> 方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;    <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">salaryStats</span>(<span class="hljs-params">event</span>){<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'执行salaryStats'</span>) <br>  }<br><br>  <span class="hljs-comment">// 注册事件回调函数</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#go'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, salaryStats );<br>  &lt;/script&gt;<br>其中 注册事件回调函数的代码 ，在 id 为 go 的元素上，使用 addEventListener 方法，注册了点击的事件， 当这种事件发生的时候，就回调执行函数 salaryStats 来处理这个事件。<br>salaryStats定义的时候，知道，浏览器回调自己的时候，会传入一个 <span class="hljs-title class_">MouseEvent</span>（鼠标事件）类型的对象。<br>事件类型 除了鼠标事件外，还有 键盘事件，滚轮事件、拖拽事件、剪贴板事件 等等。<br></code></pre></td></tr></tbody></table></figure></li><li><p>获取网页内容：主要就是要通过DOM 对象的 <strong>属性</strong>。不同类型的html元素，对应的DOM 对象的类型是不同的</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> 对应的DOM对象类型是 HTMLAnchorElement<br><span class="hljs-selector-tag">p</span> 对应的DOM对象类型是 HTMLParagraphElement<br><span class="hljs-selector-tag">textarea</span> 对应的DOM对象类型是 HTMLTextAreaElement<br><span class="hljs-selector-tag">button</span> 对应的DOM对象类型是 HTMLButtonElement<br><br>document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">'#salary'</span>)<span class="hljs-selector-class">.value</span><br>从HTMLTextAreaElement的属性表得知，textarea文本框里面的内容 对应的是属性 value<br></code></pre></td></tr></tbody></table></figure><p>等等</p></li><li><p>改变网页的内容：和获取网页内容一样，要改变网页内容，首先要获取 对应的 DOM对象，然后通过对象的属性方法，改变其内容。通常有如下几类</p><ul><li><p>添加元素：可以给某个节点添加新节点，比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>)<br>  .<span class="hljs-title function_">insertAdjacentHTML</span>(<span class="hljs-string">"beforeend"</span>, <span class="hljs-string">"&lt;p id='test1'&gt;薪资20K以上的有：xxx、yyy&lt;/p&gt;"</span>)<br>insertAdjacentHTML 方法就是在<span class="hljs-variable constant_">DOM</span> 对象的某个位置插入新的html节点。<br>第<span class="hljs-number">2</span>个参数 就是要插入的节点对应的<span class="hljs-variable constant_">HTML</span> 内容<br>第<span class="hljs-number">1</span>个参数 指定插入节点的位置，这里 beforeend 就是 指 插入节点作为 当前节点的 最后一个子节点<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除元素：要删除元素，可以 先获取该元素，然后调用remove方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"test1"</span>).<span class="hljs-title function_">remove</span>()<br>还可以这样删除：<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myDiv"</span>).<span class="hljs-property">outerHTML</span>=<span class="hljs-string">""</span>;<br>支持这种方式的浏览器更广泛，包括<span class="hljs-variable constant_">IE</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>改变元素内容和属性：改变元素内容和属性 ， 同样也是通过DOM对象的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置 id 为 salary的textarea 里面的内容 </span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">value</span> = <span class="hljs-string">`</span><br><span class="hljs-string">薛蟠     4560 25</span><br><span class="hljs-string">薛蝌     4460 25</span><br><span class="hljs-string">`</span><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">value</span> = <span class="hljs-string">''</span><br><br><span class="hljs-comment">// 改变 id为result元素的内部文本</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#result'</span>).<span class="hljs-property">innerText</span> = <span class="hljs-string">'薪资20K以上的有：xxx、yyy'</span><br><br><span class="hljs-comment">// 改变id为result元素的文本颜色为红色</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#result'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span><br><br><span class="hljs-comment">// 改变button按钮文本</span><br><span class="hljs-keyword">let</span> addOneBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'button'</span>)<br>addOneBtn.<span class="hljs-property">innerText</span> = addOneBtn.<span class="hljs-property">innerText</span> === <span class="hljs-string">'隐藏'</span> ? <span class="hljs-string">'添加'</span> : <span class="hljs-string">'隐藏'</span>;<br><br>那么到底一个元素对应的<span class="hljs-variable constant_">DOM</span>对象有哪些属性方法呢？<br>还是要看<span class="hljs-variable constant_">DOM</span>对象的 类型<br>不同类型的<span class="hljs-variable constant_">HTML</span>元素对应的 <span class="hljs-title class_">HTMLElement</span> 对象不同， 属性也会有差异<br></code></pre></td></tr></tbody></table></figure></li><li><p>控制元素是否显示：</p></li><li><p>控制元素是否显示，可以根据元素的CSS样式里面的 <code>display</code> 属性 ，当 <code>display</code> 的值为 <code>none</code> ，元素不显示</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pnEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.paginator'</span>)<br><span class="hljs-keyword">if</span>(pd.<span class="hljs-property">pagecount</span> === <span class="hljs-number">0</span>){<br>  pnEle.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">'none'</span><br>  <span class="hljs-keyword">return</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>其它能力：浏览器 Web API编程接口还提供了其它能力，比如：和服务器通信能力包括HTTP/WebSocket等，浏览器端存储能力包括Local Storage, Session Storage, Cookie, IndexedDB等等，本地文件访问能力，定位能力等等，完整的编程接口，<a href="https://developer.mozilla.org/en-US/docs/Web/API">点击参考这里</a>，这些js编程接口的API 提供了底层能力，我们运用好它们，就可以开发各种功能的网页应用程序</p></li></ul></li></ul></li><li><p>元素通用属性</p><ul><li><p>继承关系：要用js代码改变界面元素展示的内容、样式， 需要先获取该元素对应的 DOM 对象， 然后再通过调用对象的属性或者方法。不同类型的HTML元素对应的 DOM 对象类型不同， 属性、方法 也会有差异。但是所有的 HTML元素对象 都有相同的继承关系：</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">EventTarget &lt;- Node &lt;- Element &lt;- HTMLElement <br></code></pre></td></tr></tbody></table></figure><p>我们知道，js对象可以使用其祖先类型的属性/方法，所以所有的HTML元素，不管是 p、div、span、button ， 他们对应的对象，都可以使用 EventTarget、Node、Element、HTMLElement 这些祖先类型的属性和方法，也就是页面元素DOM对象 <strong>通用</strong> 的属性和方法。</p></li></ul></li><li><p>EventTarget：<a href="https://developer.mozilla.org//en-US/docs/Web/API/EventTarget">EventTarget</a>类型提供了如下方法：</p><ul><li><p>addEventListener()：用来注册处理 该对象的事件 的处理函数。</p></li><li><p>removeEventListener()：这是 类型 EventTarget 的方法，用来取消 注册处理 该对象的事件 的处理函数。</p></li></ul></li><li><p>Node：<a href="https://developer.mozilla.org//en-US/docs/Web/API/Node">Node</a>类型提供了如下属性和方法：</p><ul><li><p>获取所有子节点：<code>childNodes</code>属性可以 获取元素的所有子节点对象，获取的子节点是所有的DOM子节点， 包括 html元素、文本、注释。返回的NodeList 类型，类似数组，可以使用for of 遍历， 里面的对象就是各自节点对应的类型</p></li><li><p>textContent：用来 获取 元素内部所有的文本内容，包括不可见的部分。这个属性也可以用来 设置 元素内部 文本内容</p></li><li><p>获取父元素节点：该属性返回这个Node的父HTML元素</p></li></ul></li><li><p>内置对象document：内置对象 <code>document</code> 的类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">Document</a> ， 继承关系如下，所以 <code>EventTarget</code> 和 <code>Node</code> 的属性方法，比如 <code>addEventListener()</code> , <code>childNodes</code> 等等 ， 对 document都是适用的。</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">EventTarget &lt;- Node &lt;- Document<br></code></pre></td></tr></tbody></table></figure><ul><li><p>产生元素对象：<code>createElement</code> 方法可以产生元素对象。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target'</span>&gt;</span>原来的元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#target'</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> new1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span><br><span class="language-javascript">  new1.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素1'</span>;</span><br><span class="language-javascript">  p.<span class="hljs-title function_">after</span>(new1);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>寻找内部元素：寻找内部元素，最灵活的方法就是通过 document对象的 <code>querySelector</code> 、 <code>querySelectorAll</code> 方法，参数是 CSS 选择表达式，来选择元素。如果，没有找到符合条件的元素，返回 <code>null</code>，<code>querySelector</code> 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 <code>querySelectorAll</code> 方法，返回的是一个类似数组的对象<a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a>，里面存放了所有符合条件的 DOM 对象。通过 document 调用 querySelector/querySelectorAll 是在整个DOM 里面选择元素。如果要在某个 DOM 元素 的 内部范围内选择，就可以调用这个 元素 DOM 对象的 querySelector/querySelectorAll 方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'div'</span>).<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'span'</span>)<br></code></pre></td></tr></tbody></table></figure><p>除了css表达式选择元素，还可以直接根据元素的 <code>id</code> 、 <code>name属性</code> 、 <code>标签名</code> 、 <code>class属性</code> 选择元素</p><p>比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据id选择，返回单个元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"myDiv"</span>)<br><br><span class="hljs-comment">// 根据name属性选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">"btn"</span>)<br><br><span class="hljs-comment">// 根据标签名选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">"input"</span>)<br><br><span class="hljs-comment">// 根据class属性选择，返回的是一组元素对象</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">"btn"</span>)<br></code></pre></td></tr></tbody></table></figure><p>注意返回的一组对象时，是放在一个类似 数组的 对象 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection">HTMLCollection</a> 中，就像数组一样，可以直接通过索引访问对应的元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">"input"</span>)[<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>Element：我们常用的属性和方法大都是来自 <a href="https://developer.mozilla.org//en-US/docs/Web/API/Element">Element</a> 类型的。</p></li><li><p>id：<code>id</code> 属性可以获取/设置 该元素的id属性。</p></li><li><p>children 只读：可以获取该元素的所有子元素，返回的是对象是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection">HTMLCollection</a> 类型，这个类型 功能类似 数组，里面存放的是 html元素对象，可以使用 <code>for of</code> 遍历， 也可以使用索引获取其中的元素。</p></li><li><p>innerHTML、outerHTML：<code>innerHTML</code> 可以用来获取一个元素对象 <code>内部</code> HTML文本；<code>outerHTML</code> 可以用来获取一个元素对象 <code>全部</code> HTML文本。</p></li><li><p>获取内部元素：如果我们只要在某个元素的内部获取元素，通用的针对某个元素调用这些方法即可。同样，如果没有找到符合条件的元素，querySelector 返回 <code>null</code>。</p></li><li><p>获取上级元素：<code>closest()</code> 方法获取符合条件的 <code>最接近</code> 的上级元素，参数是一个css选择表达式。如果自身也匹配，则返回本元素自身，因为自身更接近自身。如果没有匹配的元素，则返回null</p></li><li><p>添加元素：Element方法中，有好几个用来添加节点。after() / before() / append()，<code>after</code> 是给当前元素节点，添加一些 <code>后续弟弟节点</code> ，参数可以是1个或者 多个节点对象，参数可以是 元素对象 （添加后成为html元素） 或者 字符串（添加后成为文本节点）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target'</span>&gt;</span>原来的元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/body&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'target'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> new1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  new1.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素1'</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> new2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"p"</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  new2.<span class="hljs-property">textContent</span> = <span class="hljs-string">'新元素2'</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  p.<span class="hljs-title function_">after</span>(new1,new2,<span class="hljs-string">'abc'</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><p>相反，<code>before</code> 是给当前元素节点，添加一些 <code>前置哥哥节点</code>,<code>append</code> 是给当前元素节点，添加一些 <code>子节点</code> ，</p><ul><li><p>insertAdjacentHTML()：使用 after() / before() / append()，必须先使用 <code>document.createElement()</code> 创建一个元素对象然后再调用新对象的方法，创建内容。写起来比较麻烦。可以使用 insertAdjacentHTML` 方法直接写元素对应的html文本内容。比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p&gt;薪资统计&lt;/p&gt;<br><br>&lt;script&gt;<br>  let pEle = `<br>      &lt;br&gt;&lt;br&gt;<br>      &lt;p&gt;小张: &lt;mark&gt;15000&lt;/mark&gt;&lt;/p&gt;<br>      &lt;p&gt;小李: &lt;mark&gt;18000&lt;/mark&gt;&lt;/p&gt;<br>`<br>  document.querySelector('p')<br>  .insertAdjacentHTML("beforeend", pEle)<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p><code>insertAdjacentHTML</code> 方法就是在DOM 对象的 <code>某个位置</code> 插入新的html节点。</p><ul><li><p>第2个参数 就是要插入的节点对应的HTML文本</p></li><li><p>第1个参数 指定插入节点的位置</p></li><li><p><code>afterbegin</code></p><p>插入内容 作为 当前节点的 <code>第一个子节点</code></p></li><li><p><code>beforeend</code></p><p>插入内容 作为 当前节点的 <code>最后一个子节点</code></p></li><li><p><code>beforebegin</code></p><p>插入内容 作为 当前节点的 <code>前一个哥哥节点</code></p></li><li><p><code>afterend</code></p><p>插入内容 作为 当前节点的 <code>下一个弟弟节点</code></p></li></ul></li></ul></li><li><p>删除元素:<code>remove()</code> 方法用来删除元素自身。</p></li><li><p>替换元素：可以使用 <code>outerHTML</code> 、 <code>innerHTML</code> 属性替换元素。也可以使用 <code>replaceWith</code> 方法替换元素</p></li><li><p>获取元素属性：<code>getAttribute()</code> 可以用来获取元素的属性， <code>getAttribute()</code> 返回值都是字符串的形式，有的属性，也可以直接通过 <code>元素对象.属性</code> 的方式获取元素的属性，但是这种方式只能获取元素的标准属性， 不能获取自定义非标准属性的值，而且有的属性获取的结果和 <code>getAttribute()</code> 不一样，返回值不一定是字符串，比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">style</span> <span class="hljs-comment">// 得到的值 类似 Object类型</span><br>a.<span class="hljs-property">href</span>  <span class="hljs-comment">// 得到的值是全路径</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>设置元素属性：<code>setAttribute()</code> 可以用来设置元素的属性，参数 都是字符串的形式，也可以直接通过 <code>元素对象.属性</code> 的方式设置元素的属性，而且有的设置方式和 setAttribute()不一样，因为 <code>元素对象.属性</code> 的方式值不都是字符串，比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'green'</span><br></code></pre></td></tr></tbody></table></figure><p>style 属性其实不是 <code>Element</code> 类型里面的，是 <code>HtmlElement</code> 类型里面的</p></li><li><p>删除元素属性：<code>removeAttribute()</code> 用来删除元素的属性</p></li><li><p>class属性：class属性操作， 除了前面讲的通用方法，还可以这样操作：className<code>className</code> 可以用来，获取和设置元素的class属性，之所以不直接用 <code>class</code> 作为属性名，是为了避免和 js 的关键字 class 冲突,<code>className</code> 是对元素 <code>class属性整体</code> 当作一个字符串操作的。如果想单独操作某个class ，不改变其它class属性，推荐使用 <code>classList</code> 属性，<code>classList</code> 属性对应一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList">DOMTokenList</a> 类型， 有一些方便操作属性值的方法，比较常用的是：<code>contains</code> 方法、<code>remove</code> 方法、<code>add</code> 方法。</p></li><li><p>HtmlElement：有如下常用属性方法</p></li><li><p>innerText、outerText：HtmlElement 的 <code>innerText</code> 和 Node 的 <code>textContent</code> 属性都可以 <code>获取/设置</code> 元素内部的文本内容区别是：innerText 展示的是该元素对应的可以呈现在界面上的文本内容；textContent 展示的是元素内部所有的文本内容，包括不可见的部分</p></li><li><p>style：style属性的值是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration">CSSStyleDeclaration</a> 类型， 类似 Object类型， 可以通过这个对象的属性来 获取、设置 元素的样式</p></li><li><p>focus()：focus方法可以让该元素获取输入焦点，前提是这种元素可以获取输入焦点</p></li><li><p>click()：click 方法 模拟鼠标点击该元素</p></li><li><p>元素自身属性：前面学习了HTML元素通用的属性和方法，不同类型的HTML元素对应的 DOM 对象类型不同，属性也会有差异。这里我们学习一些常用HTML元素对象 <strong>自身</strong> 的属性方法，注意：下面介绍的元素属性，如果没有特别标记为 <code>只读</code> ， 就是 <code>既可读、也可写</code></p><ul><li><p><code>a</code>： 对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement">HTMLAnchorElement</a>。常用属性有： hash host hostname href origin port protocol search</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">'https://www.byhy.net:80/py/lang/basic/09?name=byhy&amp;pagenum=23#pop'</span> <br>   target=<span class="hljs-string">'_blank'</span>&gt;<br>  测试连接<br>&lt;/a&gt;<br><br>&lt;br&gt;&lt;br&gt;<br>脚本运行结果如下<br>&lt;pre style=<span class="hljs-string">'font-size:1rem'</span>&gt;&lt;/pre&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> pre = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'pre'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  pre.<span class="hljs-property">innerText</span> = <span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.hash     = <span class="hljs-subst">${a.hash}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.host     = <span class="hljs-subst">${a.host}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.hostname = <span class="hljs-subst">${a.hostname}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.href     = <span class="hljs-subst">${a.href}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.origin   = <span class="hljs-subst">${a.origin }</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.port     = <span class="hljs-subst">${a.port}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.protocol = <span class="hljs-subst">${a.protocol}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">a.search   = <span class="hljs-subst">${a.search}</span></span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">`</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>button：对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement">HTMLButtonElement</a>，常用属性有：disabled，是个bool值，表示该按钮是否被禁用，禁用为true，可用为false</p></li><li><p>img：对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement</a>，常用属性有：alt，对应 img 元素的 alt属性， 当图片显示失败时（比如url错误），在图片位置显示的文本内容；height，对应 img 元素的 高度，数字为单位，表示像素；width，对应 img 元素的 宽度，数字为单位，表示像素；src，对应 img 元素的 的url地址</p></li><li><p>input：对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement">HTMLInputElement</a>，常用的通用属性和方法有：value属性对应输入框里面的文本；name属性；type属性；disabled是个bool值，表示该按钮是否被禁用，禁用为true，可用为false</p></li><li><p>input - text，email，password，number：类型是 text，email，password，number 等这些输入框input，有如下属性：maxLength/minLength，最多和最少输入的字符数量；placeholder；readOnly；size；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，</p><p>参数 replacement 指定用来替换的字符串，参数 start, end 是可选参数，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。</p></li><li><p>input - number：类型是 number 的数字输入框, 除了上述属性外，还有下面的属性，max、min，max指定了 输入框 可输入数字最大值，超过该值时会有错误提示，min指定了 输入框 可输入数字最小值，小于该值时会有错误提示，点击增加箭头，不会超过该数值；step一个数字，表示输入框数字的增减单位。</p></li><li><p>input - radio，checkbox：checked，该属性值为bool类型，表示是否选中；defaultChecked，该属性值为bool类型，表示缺省（页面刚加载完成时）是否选中；</p></li><li><p>textarea<code>：对应的DOM对象类型是 对应的DOM对象类型是 [HTMLTextAreaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement)，常用属性有：value，返回/设置 文本框内的输入内容；rows/cols，</code>rows<code>、</code>cols<code>属性分别指定 输入框的行数和列数；disabled，返回/设置 是否禁用文本框，被禁用后，就不能输入内容了；maxLength/minLength，也就是最多和最少输入的字符数量；placeholder；wrap，返回/设置 一行文字超过文本框宽度时 如何显示，取值为off，一行文字超过文本框宽度时，不换行， textarea元素出现水平滚动条，soft，一行文字超过文本框宽度时，剩余内容 折到下一行显示，这是缺省值，hard，设置该值时，必须同时指定</code>cols` 属性这样，一行文字超过文本框宽度时，浏览器自动插入换行符 (CR+LF)，剩余内容 折到下一行显示；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，参数 replacement 指定用来替换的字符串，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。</p></li><li><p>select 和 option：<code>select</code> 对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement">HTMLSelectElement</a>，<code>option</code> 对应的DOM对象类型是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement">HTMLOptionElement</a>，<code>HTMLSelectElement</code> 常用属性、方法有：options 只读，返回 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionsCollection">HTMLOptionsCollection</a> 对象， 里面存放了所有的option对应的 HTMLOptionElement 对象；value，返回/设置 第一个选定 option 元素的value属性，值为 空字符串 表示未选择任何元素；selectedIndex，返回/设置 第一个选定 option 元素的索引数字，值为 -1 表示未选择任何元素；disabled，返回/设置 是否禁用选择框，被禁用后，就不能选择了；type 只读，返回 表示支持多选与否的字符串。 当该select有multiple属性时，返回“select-multiple”， 否则，返回“select-one”；add(item, before)，添加选项，有两个参数，item，新增 HTMLOptionElement 对象 或者 HTMLOptGroupElement 对象，before，表示在哪个索引对应的选项前插入，值为数字，插入到index对应的位置上，该参数可选，如果没有传入值，或者为一个不存在的index，则新选项会插入到最末尾；remove(index)，删除选项，参数index表示要删除选项的位置索引，值为数字；<code>HTMLOptionElement</code> 常用属性、方法有：value，返回/设置 该 option 元素的value属性；text，返回/设置 该 option 元素的 选项文本内容，selected，返回/设置 该 option 元素是否被选择，是为 true，否为 false；index 只读，返回 该 option 元素的索引值。</p></li></ul></li><li><p>事件处理：addEventListener，可以告知浏览器，当某个事件发生时，执行哪个函数进行处理。除了使用 <code>addEventListener</code> 指定 事件处理函数，还可以使用 元素对应 DOM 对象的事件属性 指定 事件处理函数，事件属性名是 <code>on</code>开头，后面加事件名称，比如： <code>onkeydown</code> 、 <code>onclick</code> 等等。还可以直接在 <code>元素属性中设置事件处理</code>这叫html 内联定义 - 不推荐，这样破坏了html界面和js代码的分离，不方便维护</p></li><li><p>事件针对的元素：针对哪个元素dom对象调用 addEventListener 方法， 就是在这个元素的范围内注册事件处理函数。非这个元素内发生的 注册事件 ，不会触发调用。</p></li><li><p>代码在html中的位置：很多人喜欢把js内嵌的代码都集中放在head里面，在head中的js代码在网页内容（也就是body中的内容）渲染前，会被先执行。这样 DOM 里面内容还没有创建， 还没有body节点，所以会报错。为解决这个问题，可以定义load事件，因为页面资源完成全部加载，包括页面HTML所有DOM对象产生，界面渲染完成，引用的外部js、css、图片加载完成 等等，会发出load事件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>});<br><span class="hljs-comment">//参数event 就是 load事件对象,如果不需要处理该对象，可以忽略，像这样:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>});<br><span class="hljs-comment">//也可以使用 window对象的onload属性:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {<br>  <span class="hljs-comment">// 执行代码</span><br>};<br></code></pre></td></tr></tbody></table></figure></li><li><p>事件对象和类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#salary'</span>).<span class="hljs-property">onkeydown</span> = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span>{<br>  <span class="hljs-comment">// 处理代码</span><br>}<br><span class="hljs-comment">//这个里面的 event 参数对应的就是，事件发生时，浏览器传入回调我们的函数时，传入的 事件对象,不同的用户操作触发的事件对应的事件对象的类型不同,比如我们上面的是键盘事件，对应的就是 键盘事件（KeyboardEvent） 对象类型如果是鼠标按钮点击操作，对应的就是 鼠标事件（MouseEvent） 对象类型。不同类型的对象，其属性、方法 不同比如 上例中，我们是 键盘事件，传入的是键盘事件对象，它有属性：</span><br>ctrlKey<br>如果事件发生时，ctrl键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br>altKey<br>如果事件发生时，alt键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br><span class="hljs-title class_">Shift</span><br>如果事件发生时，shift键按下，值为<span class="hljs-literal">true</span>，否则为<span class="hljs-literal">false</span><br><br>key<br>返回 事件发生时，按下按键的字符串表示，比如<br><br><span class="hljs-title class_">Enter</span> 对应回车键<br><br><span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span> 对应数字键 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span><br><br>a、b、c、d 对应字母键 a、b、c、d<br><br>A、B、C、D 对应字母键 A、B、C、D<br><br>等等，大家可以通过 在代码中加上<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">key</span>)<br>查看你的按键对应的到底是什么key属性的值<br>事件对象类型 有很多，除了 键盘事件、鼠标按钮事件 外，还有 滚轮事件（<span class="hljs-title class_">WheelEvent</span>）、拖拽事件（<span class="hljs-title class_">DragEvent</span>）、游戏触控板事件（<span class="hljs-title class_">GamepadEvent</span>） 等等。<br><br><span class="hljs-comment">//还有的事件不是用户操作触发的，比如 页面加载完成事件、网址hash更改事件（HashChangeEvent）、websocket网络消息事件、 存储事件 等等</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>事件处理顺序：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">浏览器创建一个 click 事件对象,这个事件对象会先从 浏览器<span class="hljs-variable constant_">DOM</span> 顶层的 <span class="hljs-variable language_">window</span> 对象一直 传递下去，直到 触发事件的对象的父对象 ，这个过程称之为 capture <span class="hljs-title class_">Phase</span>（捕获阶段）。这个路径上，如果有任何<span class="hljs-variable constant_">DOM</span>对象注册了点击处理事件，就会按照从上到下的先后顺序，依次被调用。<br>然后，这个事件对象 到达触发事件的td对象，这个过程称之为 target phase（目标阶段）<br>然后，这个事件对象 再从触发事件的td对象，一直传递到顶层的<span class="hljs-variable language_">window</span>对象，这个过程称之为 bubbling <span class="hljs-title class_">Phase</span>（冒泡阶段）<br>注意， click 事件是会 冒泡传播 的， 但是也有些类型的事件（比如，blur、focus）是不会冒泡的，到target 位置就结束了。要声明注册的处理函数是在 捕获阶段 触发执行 ，应该这样<br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码}, <span class="hljs-literal">true</span>)<br>第<span class="hljs-number">3</span>个参数如果是boolean 并且设置为<span class="hljs-literal">true</span> ，就表示是 <span class="hljs-title class_">Capture</span> <span class="hljs-title class_">Phase</span>触发行。要声明注册的处理函数是在 非捕获阶段（target phase 和 bubbling <span class="hljs-title class_">Phase</span>）触发执行 ，应该没有第<span class="hljs-number">3</span>个参数，或者第<span class="hljs-number">3</span>个参数为<span class="hljs-literal">false</span>，如下：<br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码})<br><span class="hljs-comment">// 或者这样</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {这里是处理代码}, <span class="hljs-literal">false</span>)<br></code></pre></td></tr></tbody></table></figure></li><li><p>事件对象 target属性 / this：当我们实现事件处理函数的时候，传入的参数对象就是 触发的事件对象，这里我们用变量名 <code>e</code> 指代它，这个事件对象的属性中 有两个要注意的：<code>e.target</code> 指代了 真正触发事件的那个DOM对象，而<code>e.currentTarget</code> 指代了当前 正在处理事件的DOM对象， 也就是当前处理函数 注册对应那个对象。在处理函数中，也可以使用 <code>this</code> ，等价于 <code>event.currentTarget</code></p></li></ul><h3 id="jQuter"><a href="#jQuter" class="headerlink" title="jQuter"></a>jQuter</h3><ul><li><p><code>jQuery</code> 是一个非常流行的 js库，方便我们进行 web 前端开发。主要的用途有： 操作DOM对象、事件处理 、和服务端通信、常用功能库、动画效果。特别是早期前端开发，当时 js语言 和 浏览器 Web API 功能比较少，使用jQuery提供的库，可以大大提高开发人员的效率，几乎是web前端开发必不可少的库。后来 js语言本身 和 浏览器 Web API 不断完善 ，现在通常可以不需要 jQuery，但是仍有大量的第三方库 和 现有项目的代码 依赖 jQuery，所以还是有必要学习的。</p></li><li><p>jQuery的安装：开发环境下，要使用 jQuery 库，可以在本地服务创建一个库目录，然后把 jQuery 库 从 <a href="https://jquery.com/download/">官网下载地址</a>下载本地库目录中。还可以直接使用 <code>靠谱的</code> js库 公共cdn推荐如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">jsdelivr<br><span class="hljs-number">3.6</span><span class="hljs-number">.0</span> 版本的jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js</span><br><br>由于目前 <span class="hljs-number">3.6</span><span class="hljs-number">.0</span> 就是最新版，可以简化写为<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js</span><br><br>cdnjs<br>jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js</span><br><br>字节跳动公共库cdn<br>jQuery库url为：<br><span class="hljs-attr">https</span>:<span class="hljs-comment">//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js</span><br>大家可以把 jQuery 库的url地址 添加到你的网页head中，比如<br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><span class="hljs-comment">//注意：公共cdn有时会突然宕机，所以正式产品部署时，还是下载部署到自己的网站上，或者自己购买的CDN云服务上（比如 阿里云CDN+OSS）</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>选择元素和事件处理：html中 引入jQuery 库链接后，就可以使用该库了，先看一下jQuery 如何选择元素并进行事件处理。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'b1'</span>&gt;</span>测试按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'b2'</span>&gt;</span>测试按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">jQuery</span>(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;body&gt;<br><span class="hljs-comment">//其中 jQuery 本身就是一个构造函数， 里面的参数是css 选择器,jQuery('button') 返回的就是一个 jQuery 对象。这个对象类似js的数组，里面包含了所有参数 css 选择器 选中的DOM对象。jQuery 对象的 on 方法，用来定义事件处理,第一个参数就是事件名称，第二个参数是回调函数,还有一种简便写法，如下</span><br><span class="hljs-title function_">jQuery</span>(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">click</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })<br><span class="hljs-comment">//如果返回的对象选择到了多个元素对象， 不需要循环定义每个元素对象的事件处理，而是可以一起定义。</span><br><span class="hljs-comment">//jQuery 还有一个简化的别名就是一个字符 $ 所以上面的代码也可以简写为</span><br>$(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按钮被点击'</span>) })<br><span class="hljs-comment">//当然也可以注册处理其他类型事件，比如</span><br>&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>按ctrl+回车 试试<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></span><br><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  $(<span class="hljs-string">'textarea'</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">'keydown'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) { </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">ctrlKey</span> &amp;&amp; e.<span class="hljs-property">key</span>===<span class="hljs-string">'Enter'</span>)    </span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'按下了ctrl+回车'</span>) </span></span><br><span class="language-javascript"><span class="language-xml">  })</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;body&gt;<br></code></pre></td></tr></tbody></table></figure></li><li><p>元素操作：</p><ul><li><p>添加元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'content1'</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target1'</span>&gt;</span>原来的元素1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'content2'</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'target2'</span>&gt;</span>原来的元素2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="hljs-comment">//然后打开控制台，分别执行如下代码，看看html内容的变化,下面是添加子元素的示例</span><br><span class="hljs-comment">// 这样创建一个html元素对象 </span><br><span class="hljs-keyword">var</span> ele1 = $( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> );<br><br><span class="hljs-comment">// 添加到 div#content1 ，作为最后一个子元素</span><br>ele1.<span class="hljs-title function_">appendTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 当然也可以这样写</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> ).<span class="hljs-title function_">appendTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 添加到 #content1 ，作为第一个子元素</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素2&lt;/p&gt;"</span> ).<span class="hljs-title function_">prependTo</span>( <span class="hljs-string">"#content1"</span> );<br><br><span class="hljs-comment">// 插入到 #target2 前面，作为哥哥节点</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素3&lt;/p&gt;"</span> ).<span class="hljs-title function_">insertBefore</span>( <span class="hljs-string">"#target2"</span> );<br><br><span class="hljs-comment">// 插入到 #target2 后面，作为弟弟节点</span><br>$( <span class="hljs-string">"&lt;p&gt;新元素4&lt;/p&gt;"</span> ).<span class="hljs-title function_">insertAfter</span>( <span class="hljs-string">"#target2"</span> );<br><span class="hljs-comment">//还可以这样</span><br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">append</span>( <span class="hljs-string">"&lt;p&gt;新元素1&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">prepend</span>( <span class="hljs-string">"&lt;p&gt;新元素2&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">before</span>( <span class="hljs-string">"&lt;p&gt;新元素3&lt;/p&gt;"</span> );<br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">after</span>( <span class="hljs-string">"&lt;p&gt;新元素4&lt;/p&gt;"</span> );<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//删除元素方法很简单，先选中，然后调用 remove 方法，比如：</span><br>$( <span class="hljs-string">"#content1"</span> ).<span class="hljs-title function_">remove</span>()<br></code></pre></td></tr></tbody></table></figure></li><li><p>替换元素内容</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//先选中，然后调用 html 方法，更新元素内部的html，比如：</span><br>$( <span class="hljs-string">"#content2"</span> ).<span class="hljs-title function_">html</span>(<span class="hljs-string">`&lt;p id='target3'&gt;新元素2222&lt;/p&gt;`</span>)<br><span class="hljs-comment">//类似 浏览器内置的 元素对象的 innerHTML 方法</span><br><br><span class="hljs-comment">//调用 text 方法，更新元素内部的文本内容，比如：</span><br>$( <span class="hljs-string">"#target2"</span> ).<span class="hljs-title function_">text</span>(<span class="hljs-string">`新元素22222`</span>)<br><span class="hljs-comment">//类似 浏览器内置的 元素对象的 innerText 方法</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>元素值操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//调用 val() 方法，可以获取或者设置一些元素的值，比如 input、select、textarea类似 HtmlElement 的 value 属性的作用,比如:</span><br><span class="hljs-comment">// 获取 id 为 username 的元素的值</span><br><span class="hljs-keyword">let</span> username = $(<span class="hljs-string">'#username'</span>).<span class="hljs-title function_">val</span>()<br><br><span class="hljs-comment">// 设置 id 为 username 的元素的值</span><br>$(<span class="hljs-string">'#username'</span>).<span class="hljs-title function_">val</span>(<span class="hljs-string">'byhy'</span>)<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>元素属性操作：</p><ul><li><p>获取元素属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//attr() 可以用来获取元素的属性，类似浏览器内置的 元素对象的getAttribute() 方法,返回值都是字符串的形式,如下：</span><br>&lt;a id=<span class="hljs-string">"hey"</span> <br>  style=<span class="hljs-string">'color:green;font-size: 2rem;'</span>  <br>  href=<span class="hljs-string">"/"</span> <br>  <span class="hljs-keyword">class</span>=<span class="hljs-string">'nav nav-item'</span><br>  attr1=<span class="hljs-string">'自定义属性'</span>&gt;<br>  一个链接<br>&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> a = $(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'id'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'style'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'href'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'class'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'attr1'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>设置元素属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//attr() 如果提供第2个参数，就是用来设置元素的属性，类似浏览器内置的 元素对象的setAttribute() 方法,比如</span><br>&lt;a id=<span class="hljs-string">"hey"</span> style=<span class="hljs-string">'color:green'</span>  href=<span class="hljs-string">"/"</span> attr1=<span class="hljs-string">'自定义属性'</span>&gt;一个链接&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> a = $(<span class="hljs-string">'a'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'id'</span>, <span class="hljs-string">'new-hey'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'style'</span> , <span class="hljs-string">'color:blue'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'href'</span>, <span class="hljs-string">'https://www.byhy.net'</span>)</span></span><br><span class="language-javascript"><span class="language-xml">a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">'attr1'</span>, <span class="hljs-string">'自定义属性2'</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>删除元素属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//removeAttr()方法 用来删除元素的属性,类似浏览器内置的 元素对象的removeAttribute() 方法,比如</span><br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'id'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'style'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'href'</span>)<br>a.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">'attr1'</span>)<br></code></pre></td></tr></tbody></table></figure></li><li><p>style设置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//css()方法 用来设置元素的style里面的某个样式属性,比如</span><br>a.<span class="hljs-title function_">css</span>(<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>)<br><br><span class="hljs-comment">//如果是点击某个元素，就设置这个被点击元素的style属性，可以这样写</span><br>&lt;a id=<span class="hljs-string">"hey"</span> <br>  style=<span class="hljs-string">'color:green;font-size: 2rem;'</span>  <br>  href=<span class="hljs-string">"#"</span>&gt;<br>  一个链接<br>&lt;/a&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  $(<span class="hljs-string">'a'</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span></span><br><span class="language-javascript"><span class="language-xml">    $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  });</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="hljs-comment">// $(this) 代表了 触发这个点击事件的 对象，并且封装为一个JQuery对象，这样可以方便的使用JQuery对象更便捷方法。否则，如果我们只用 this，就得这样写</span><br>$(<span class="hljs-string">'.a'</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">"red"</span><br>});<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>和服务端通讯：</p><ul><li><p>XHR/AJAX：用户访问网页，包括网页里面内嵌的 CSS/js/图片 等等资源，通常是浏览器直接获取的，这种获取请求的HTTP被称之为 <strong>同步请求</strong>；而浏览器执行网页包含的js代码的过程，有时js代码还要到服务端 提交、获取数据， 这样的请求被称之为 <strong>异步请求</strong>，异步请求，典型的出现在前后端分离的web系统中。浏览器的js环境内置了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 类型，简称 `XHR，可以这样创建一个 XHR 对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">//XHR 对象 有属性方法，支持 浏览器页面代码 和 服务端之间的通信。这种使用 XMLHttpRequest 对象 和 服务端之间的 通信技术，是一种异步的通信方式。而且开始的那几年，这种方式传输数据，使用的序列化方法主要是 XML， 所以又被称之为 AJAX (Asynchronous JavaScript And XML) 方式。使用 浏览器原生的 XMLHttpRequest 对象收发消息，可以点击这里了解。缺点是：写起来比较麻烦，所以目前并不推荐使用。现在比较多的用法是： 使用 jQuery库 ，或者 ES6引入的 fetch API,这里介绍 使用 jQuery库 和服务端通信</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>前后端API接口：当我们的js代码要服务端异步通信时，HTTP请求访问的服务端要获取的 不是像 HTML/CSS/JS 这样的静态文件资源，往往是要求服务端程序进行数据库操作后，再进行代码处理，返回的数据。这样的异步请求，往往被称为 <code>API请求</code>提供这种服务的后端，被称为 <code>API 服务端</code>这种服务接口，被称为 <code>API 接口</code> 。 该接口由系统设计者设计定义，通常会提供接口说明文档，针对该接口测试服务端实现、客户端实现，就是 大家经常听说的 <code>API接口测试</code>。</p><p>后端实现对 静态文件的访问服务 和 动态API请求服务，往往不是一个程序。</p><p>比如，静态文件是 nginx 提供的服务，API则是单独开发的业务服务程序</p><p>系统设计者在设计 API 接口消息时， 规定的 API 消息的 URL 路径会有明显的特征，比如都是以 <code>/api</code> 开头这样，后端可以配置哪些url访问请求是针对API接口的，转发为API服务。live Server有代理配置项，可以设置转发规则如下配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"liveServer.settings.proxy"</span>: {<br>  <span class="hljs-string">"enable"</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">"baseUri"</span>: <span class="hljs-string">"/api"</span>,<br>  <span class="hljs-string">"proxyUri"</span>: <span class="hljs-string">"http://127.0.0.1:80/api"</span><br>}<br><span class="hljs-comment">//其中 baseUri 就是配置什么样的请求是要转发给API服务的,这里 /api ， 就是把 /api 开头的 http请求 都转给 bysms系统处理，因为 bysms系统服务的IP和端口 是 127.0.0.1:80 ，所以 proxyUri 的值为 http://127.0.0.1:80/api ，也可以写成 http://127.0.0.1/api,注意： http://127.0.0.1:80/api 后面的部分 /api 不能少，否则如果是 http://127.0.0.1:80 ， 发送的url /api/customer ，到了 服务后端 就变成了 /customer</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>jQuery构建请求消息：可以使用jQuery库里面的 <a href="https://api.jquery.com/jquery.ajax/#jQuery-ajax-settings">ajax()方法</a> 和服务端进行HTTP消息的收放。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//请求方法：典型的ajax()方法，接收一个settings参数，该参数是一个PlainObject类型， 可以把它当作 Object 来用，可以在里面设定 XHR（AJAX）请求的数据 ， 包括 请求方法、url、消息头和消息体，比如，要发送 get 请求，可以使用这样的代码</span><br>$.<span class="hljs-title function_">ajax</span>({  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>,        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>,  <br>})<br><span class="hljs-comment">//这里settings参数包含了两个键值对数据：type 是 HTTP方法，比如 GET,POST,PUT,DELETE,HEAD 等等url 是 请求的url地址，比如这里就是 /api/mgr/signin ，注意：这里url没有前面的 http://IP:端口 这部分，表示前面的这部分和当前网页前面的这部分相同。下面是是POST请求的一个代码示例</span><br>$.<span class="hljs-title function_">ajax</span>({  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>, <br>  <span class="hljs-attr">data</span>: {<br>    <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>,<br>  }<br>})<br><span class="hljs-comment">//这里 data 是请求消息体，如果请求的方法是get、post，还有简便写法，如下</span><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/mgr/signin'</span>)<br><br>$.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/mgr/signin'</span>,<br>      {<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span><br>      }<br>)<br><br><span class="hljs-comment">// 或者</span><br>$.<span class="hljs-title function_">get</span>({        <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>,  <br>})<br><br>$.<span class="hljs-title function_">post</span>({     <br>  url : <span class="hljs-string">'/api/mgr/signin'</span>, <br>  <span class="hljs-attr">data</span>: {<br>    <span class="hljs-attr">username</span>:<span class="hljs-string">'byhy'</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>,<br>  }<br>})<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>url 和 url参数：可以使用浏览器内置的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams">URLSearchParams</a> 类型。URLSearchParams对象的方法 <code>toString</code> ,可以将对象序列化为 urlencoded 格式，比如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> queryStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>({<span class="hljs-attr">code</span>:<span class="hljs-string">'6000001'</span>, <span class="hljs-attr">time</span>:<span class="hljs-string">'2022-02-23'</span> }).<span class="hljs-title function_">toString</span>()<br><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">`http://localhost/api/stock?<span class="hljs-subst">${queryStr}</span>`</span>)<br><br><span class="hljs-comment">//也可以使用 jQuery 的 param 方法</span><br><span class="hljs-keyword">var</span> queryStr = $.<span class="hljs-title function_">param</span>({<span class="hljs-attr">code</span>:<span class="hljs-string">'6000001'</span>, <span class="hljs-attr">time</span>:<span class="hljs-string">'2022-02-23'</span> })<br><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">`http://localhost/api/stock?<span class="hljs-subst">${queryStr}</span>`</span>)<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>消息头：jQuery 发送http请求要定制一些消息头，可以通过ajax方法的settings参数里面的 <code>headers</code> 属性设置，如下</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({  <br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/something'</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>, <br>  <span class="hljs-attr">headers</span>: {<span class="hljs-string">"X-Test-Header"</span>: <span class="hljs-string">"test-value"</span>}<br>})<br></code></pre></td></tr></tbody></table></figure></li><li><h4 id="contentType"><a href="#contentType" class="headerlink" title="contentType"></a>contentType</h4><p>ajax方法的参数对象 contentType 设置消息头 contentType 的值</p><p>缺省为： <code>application/x-www-form-urlencoded; charset=UTF-8</code></p><p>可以改为其它的，比如</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,       <br>  contentType : <span class="hljs-string">'application/json'</span>, <br>  <span class="hljs-attr">data</span>: JSON.<span class="hljs-title function_ invoke__">stringify</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'abc'</span>}),<br>})<br></code></pre></td></tr></tbody></table></figure></li><li><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>jQuery的请求消息体都是参数对象 settings的 <code>data</code> 属性中设置的，该属性的值可以是一个 Object 或者 字符串，urlencode 格式，消息体也可以是 urlencode 格式，同样可以使用 URLSearchParams 或者 jQuery的 param 方法。其实，如果使用jQuery发送请求， data参数如果是 Object，缺省行为就是转化为 urlencode格式，所以可以直接传对象，如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-comment">// 提交的网址</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://localhost/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,        <br>  <span class="hljs-attr">data</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'88888888'</span> }<br>})<br></code></pre></td></tr></tbody></table></figure></li><li><h4 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h4><p>现在的API接口消息体 很多是JSON格式的字符串。</p><p>可以使用浏览器js内置对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a></p><p>JSON 的方法 <code>stringify</code> 可以序列化 js对象 为 JSON格式的字符串</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">$.<span class="hljs-title function_ invoke__">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>,       <br>  contentType : <span class="hljs-string">'application/json'</span>, <br>  <span class="hljs-attr">data</span>: JSON.<span class="hljs-title function_ invoke__">stringify</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">'byhy'</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">'88888888'</span>}),<br>})<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>jQuery 解析响应消息：解析响应消息的前提是能正确获取到响应消息，如果使用的是jQuery， settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，可以在回调函数的第3个参数 <a href="https://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a> 对象获取响应消息的信息，这个jqXHR 类型 是 XMLHTTPRequest 的扩展类型，封装了一些便捷方法。</p></li><li><p>消息头</p></li></ul><pre><code class="hljs"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-comment">// 获取状态码</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textStatus);<br>    <span class="hljs-comment">// 获取所有消息头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getAllResponseHeaders</span>());<br>    <span class="hljs-comment">// 获取某个消息头</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">"content-length"</span>));<br>  },<br><br>  <span class="hljs-comment">// 错误  </span><br>  <span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">xhr, textStatus, errorThrown </span>){<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">${xhr.status}</span> \n<span class="hljs-subst">${textStatus}</span> \n<span class="hljs-subst">${errorThrown }</span>`</span>)<br>  }<br>})<br><span class="hljs-comment">//success 请求响应成功后的回调函数,所谓成功就是返回响应消息，回调函数被传入3个参数：</span><br>data 从服务端返回的数据<br>textStatus 返回的状态文本描述<br>xhr 这是 <span class="hljs-title class_">XMLHttpRequest</span>的扩展类型jqXHR的对象<br>error 请求响应失败后的回调函数<br><span class="hljs-comment">//回调函数被传入3个参数：</span><br>xhr 这是 <span class="hljs-title class_">XMLHttpRequest</span>的扩展类型jqXHR的对象<br>textStatus 返回的错误状态文本描述<br>比如：<span class="hljs-string">"timeout"</span>, <span class="hljs-string">"error"</span>, <span class="hljs-string">"abort"</span>, 等等 <span class="hljs-string">"parsererror"</span><br>errorThrown 异常对象文本<br>比如：<span class="hljs-string">"Not Found"</span> 或者 <span class="hljs-string">"Internal Server Error."</span><br><br></code></pre></td></tr></tbody></table></figure></code></pre><ul><li><p>消息体解析：如果使用的是jQuery，ajax 参数 settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，回调函数的第1个参数 data 包含了响应的消息体数据。jQuery 会根据响应消息信息（比如 content-type 消息头）猜测对应的数据类型，从而进行相应的处理。比如下面的示例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//登录成功后， 服务端返回的响应的 消息头 content-type : application/json 指明了 响应的消息体是json格式，jQuery 会自动反序列化为 js中对应的数据对象， 传递给 data参数。</span><br><span class="hljs-comment">//如果明确知道响应消息体数据格式， 应该设置 ajax 参数 settings 的 dataType 属性说明这个data的类型,比如 设置为 json，</span><br>$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/signin'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'POST'</span>, <br>  <span class="hljs-attr">data</span>: <span class="hljs-string">'username=byhy&amp;password=88888888'</span>,<br><br>  <span class="hljs-comment">// 响应消息格式 预设为 json, </span><br>  <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>, <br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//dataType 属性值还可以是,</span><br>xml<br>返回 <span class="hljs-variable constant_">XML</span> 对象<br><br>html<br>返回 <span class="hljs-variable constant_">HTML</span> 字符串<br><br>text<br>返回消息体字符串<br></code></pre></td></tr></tbody></table></figure></li><li><p>SESSION机制：采用session机制的系统设计，通常session号是认证成功后， 服务端是通过 HTTP的响应头 <code>Set-Cookie</code> 把产生的 sessionid 告诉客户端的。<code>Set-Cookie</code> 是设定服务端要存放在客户端的Cooked数据，这些数据，浏览器会自动保存。后续访问该网站的其它请求，浏览器会自动在HTTP的请求头 <code>Cookie</code> 中携带保存的所有cookie数据。所以，只要已经调用登录接口，获取了sessionid，后续的请求代码，不需要我们自己的代码里面设置。比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>({<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">'/api/mgr/customers?action=list_customer&amp;pagesize=5&amp;pagenum=1'</span>,        <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>, <br><br>  <span class="hljs-comment">// 响应消息格式 预设为 json, </span><br>  <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>, <br><br>  <span class="hljs-comment">// 正确返回</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data, textStatus, xhr</span>) { <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  }<br>})<br><span class="hljs-comment">//如果我们没有登录成功，就执行上面的代码，服务端就会要求认证了。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="Web请求过程剖析"><a href="#Web请求过程剖析" class="headerlink" title="Web请求过程剖析"></a>Web请求过程剖析</h2><ul><li><ul><li>服务器渲染：在服务器那边直接把数据和html整合在一起，统一返回给浏览器，在页面源代码中能看到数据。</li><li>客户端渲染：第一次请求只要一个html骨架。第二次请求拿到数据，进行数据展示，在页面源代码中，看不到的数据。</li></ul></li></ul><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><ul><li><ul><li>分为两块：<ol><li>请求<ol><li>请求行：有请求方式、请求url地址、协议。</li><li>请求头：放一些服务器要使用的附加信息。</li><li>请求体：一般放一些请求参数。</li></ol></li><li>响应<ol><li>状态行：有协议、状态码（200成功，302和307临时转移至新url，404找不到该页面，500服务器内部错误，503服务器不可用，一般是被反爬）。</li><li>响应头：放一些客户端要使用的附加信息。</li><li>响应体：服务器返回的真正客户端要用到的内容（HTML、json）等。</li></ol></li></ol></li><li>请求头中最常见的一些重要内容（爬虫需要）<ol><li>User-Agent：请求载体的身份标识（用啥发送的请求）</li><li>Referer：防盗链（这次请求是从哪个页面来的?反爬会用到）</li><li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li></ol></li><li>响应头中一些重要内容<ol><li>cookie：本地字符串数据信息（用户登录信息，反爬的token）</li><li>各种神奇的莫名其妙的字符串（这个需要经验，一般都是token字样，防止各种攻击和反爬）</li></ol></li><li>请求方式<ol><li>GET：链接地址信息内面直接在？后面带上参数，多个参数用&amp;隔开。如果要将参数进行封装，可以放在一个字典中，通过请求的params参数进行传递。</li><li>POST：链接地址信息内面不带参数。参数传递有二种方式：一是表单参数，form-data，它是字典形式，使用requests.post(url,data=字典参数)发送请求；二是json参数，也是字典形式，使用requests.post(url,json=字典参数)发送请求。</li></ol></li><li>模拟登录的二种方式<ol><li>cookie+session鉴权机制<ol><li>cookie是由web服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户访问到服务器，都会带上该服务器的cookie信息。一般cookie都是有有效期的，只在浏览器上保存一段规定的时间，一旦超过规定的时间，该cookie就会被系统清除。</li><li>session将数据存储在服务器中，服务器会为每个用户创建一条session，用户访问服务器的时候需要拿着sessionid去表明自己的身份。</li><li>一般常见于项目没有做前后端分离，通过参数是否是表单形式或者第一次请求地址域名和第二登录请求发送的地址域名是一样的来判断分析。</li><li>返回的时候，在响应头的set-cookie字段中。</li></ol></li><li>基于Token的鉴权机制：当客户端使用用户和密码登录认证后，如果服器鉴权成功，就会生成token返回给客户端，客户端后续发送请求时需要携带token，服务器判断token有效性后才会返回数据。一般常见于前后端分离的项目（通过是否是json参数或者第一次请求时的地址域名和第二次登录请求的地址域名不一样来判断分析）。返回的时候，在响应体中。</li></ol></li></ul></li></ul><h2 id="requests入门"><a href="#requests入门" class="headerlink" title="requests入门"></a>requests入门</h2><p>python系统自带有from url.request import urlopen模块，能实现网页请求，但使用第三方库requests模块使得网页请求更加简化，特别是在处理一些请求头上面特别简单。</p><p>用pip下载requests模块：pip install requests，实现urllib.request模块的功能，用requests模块发送请求，获取数据</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">"https://www.baidu.com"</span><br>headers = {<br>    <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"</span><br>}  <span class="hljs-comment"># 一般网站都有防爬机制，需要加上User-Agent键，伪装成浏览器发送请求。</span><br>resp = requests.get(url, headers=headers)<br>resp = requests.get(url)<span class="hljs-comment"># 返回一个Response对象和响应码</span><br><span class="hljs-built_in">print</span>(resp)<br>resp.close()<br>运行结果：<br>&lt;Response [<span class="hljs-number">200</span>]&gt;<br><span class="hljs-comment"># resp作为Response的对象，有很多属性和方法，其中属性content获取网页的字节流，text获取网页的字符串。json方法返回json格式的数据并转换成python的一种类型的数据。</span><br><span class="hljs-comment"># json是一种轻量级的数据交换格式,可以用来传输数据。爬回来的数据使用json格式会使可读性更好。</span><br><span class="hljs-comment"># 爬完记得用close()方法关闭response对象,防止资源泄露,当再次爬取时也会出现报错异常现象。</span><br><span class="hljs-comment"># request.get(url,verify=False) 忽略SSL证书验证,防止报错，Flase表示去掉安全验证。</span><br><span class="hljs-comment"># 响应头中的Referrer Policy: 防止跨站请求伪造(Cross-Site Request Forgery,CSRF)攻击,也就是网页的防爬机制,这时可以考虑在请求头中加入浏览器的User-Agent字段。</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>构建请求url参数：url参数的格式，有个术语叫 <code>urlencoded</code> 格式。使用Requests发送HTTP请求，url里面的参数，通常可以直接写在url里面，但是有的时候，我们的url参数里面有些特殊字符，比如 参数的值就包含了 &amp; 这个符号，那么我们可以把这些参数放到一个字典里面，然后把字典对象传递给 Requests请求方法的 params 参数。</p></li><li><p>构建请求头消息：每个消息头也就是一种 键值对的格式存放数据，Requests发送这样的数据，只需要将这些键值对的数据填入一个字典。然后使用post或get方法的时候，指定参数 headers 的值为这个字典就可以了。</p></li><li><p>构建请求体消息：http 的 消息体就是一串字节，里面包含了一些信息。这些信息可能是文本，比如html网页作为消息体，也可能是视频、音频等信息。最常见的消息体格式当然是 表示网页内容的 HTML。Web API接口中，消息体基本都是文本，文本的格式主要是这3种： urlencoded ，json ， XML。注意：消息体采用什么格式，是由 开发人员设计的决定的。Requests库的post方法，参数data指明了，消息体中的数据是什么。如果传入的是字符串类型，Requests 会使用缺省编码 <code>latin-1</code> 编码为字节串放到http消息体中，发送出去。编程语言都有现成的库处理解析 XML、json 这样的数据格式，我们直接拿来使用，而自己定义的格式就难以表达这样复杂的数据格式，而且还要自己写代码在发送前进行格式转化，接收后进行格式解析，非常麻烦。urlencoded 格式消息体就是一种 键值对的格式存放数据，Requests发送这样的数据，当然可以直接把这种格式的字符串传入到data参数里面。json 格式消息体：json 格式 当前被 Web API 接口广泛采用。json 是一种表示数据的语法格式。 它和Python 表示数据的语法非常像。它的优点是：比xml更加简洁、清晰， 所以程序处理起来效率也更高。可以使用json库的dumps方法，构建一个json 格式的字符串，如下</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests,json<br><br>payload = {<br>    <span class="hljs-string">"Overall"</span>:<span class="hljs-string">"良好"</span>,<br>    <span class="hljs-string">"Progress"</span>:<span class="hljs-string">"30%"</span>,<br>    <span class="hljs-string">"Problems"</span>:[<br>        {<br>            <span class="hljs-string">"No"</span> : <span class="hljs-number">1</span>,<br>            <span class="hljs-string">"desc"</span>: <span class="hljs-string">"问题1...."</span><br>        },<br>        {<br>            <span class="hljs-string">"No"</span> : <span class="hljs-number">2</span>,<br>            <span class="hljs-string">"desc"</span>: <span class="hljs-string">"问题2...."</span><br>        },<br>    ]<br>}<br><br>r = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data=json.dumps(payload))<br><span class="hljs-comment"># 这里是将python数据类型对象转换成json字符串格式，叫序列化。</span><br><span class="hljs-comment"># 也可以将 数据对象 直接 传递给post方法的 json参数，如下</span><br>r = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, json=payload)<br><span class="hljs-comment"># 这里是由json参数实际上是由request模块调用了json类进行了json序列化处理。</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>检查http响应</p><ul><li><p>检查 HTTP 响应 的状态码，直接 通过 reponse对象的 <code>status_code</code> 属性获取</p></li><li><p>要检查 HTTP 响应 的消息头，直接 通过 reponse对象的 <code>headers</code> 属性获取，response.headers 对象的类型 是 继承自 Dict 字典 类型的一个 类。我们也可以像操作字典一样操作它，比如取出一个元素的值</p></li><li><p>检查响应消息体，要获取响应的消息体的文本内容，直接通过response对象 的 <code>text</code> 属性即可获取，那么，requests是 以什么编码格式 把HTTP响应消息体中的 字节串 解码 为 字符串的呢？requests 会根据响应消息头（比如 Content-Type）对编码格式做推测。但是有时候，服务端并不一定会在消息头中指定编码格式，这时， requests的推测可能有误，需要我们指定编码格式。可以通过这样的方式指定：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>response = requests.get(<span class="hljs-string">'http://mirrors.sohu.com/'</span>)<br>response.encoding=<span class="hljs-string">'utf8'</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></tbody></table></figure><p>如果我们要直接获取消息体中的字节串内容，可以使用 <code>content</code> 属性，比如：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br>response = requests.get(<span class="hljs-string">'http://mirrors.sohu.com/'</span>)<br><span class="hljs-built_in">print</span>(response.content)<br><span class="hljs-comment"># 返回的内容既可以是字符串格式:text，也可以是字节串格式:content,两者之间通过encode和decode进行转换，decode默认以UTF-8的编码形式进行转码，也可以手动指定解码所采用的编码形式来进行解码。</span><br></code></pre></td></tr></tbody></table></figure><p>当然，如果可以直接对 获取的字节串 bytes对象进行解码，如：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">'utf8'</span>))<br></code></pre></td></tr></tbody></table></figure><p>API 响应的消息体格式，通常以json居多。为了 <code>方便处理 响应消息中json 格式的数据</code> ，我们通常应该把 json 格式的字符串 转化为 python 中的数据对象。怎么转化？ 前面我们学习过 json库，可以直接使用 json库里面的 <code>loads</code> 函数， 把 json 格式的字符串 转化为 数据对象</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests,json<br>response = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data={<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>})<br><br>obj = json.loads(response.content.decode(<span class="hljs-string">'utf8'</span>))<br><span class="hljs-built_in">print</span>(obj)<br><span class="hljs-comment"># 这种方式称为反序列化。</span><br></code></pre></td></tr></tbody></table></figure><hr><p>requests库为我们提供了更方便的方法，可以使用 Response对象的 json方法，如下：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">response = requests.post(<span class="hljs-string">"http://httpbin.org/post"</span>, data={<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>})<br>obj = response.json()<br><span class="hljs-built_in">print</span>(obj)<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>HTTP 协议规定了， 网站服务端放HTTP响应中 消息头 <code>Set-Cookie</code> 里面的数据， 叫做 cookie 数据， 浏览器客户端 必须保存下来。而且后续访问该网站，必须在 HTTP的请求头 <code>Cookie</code> 中携带保存的所有cookie数据。</p><p>我们在Python代码中如果接收到服务端HTTP响应， 就能构建请求头，完全可以自己处理cookie。但requests库给我们提供一个 <code>Session</code> 类 。通过这个类，无需我们操心， requests库自动帮我们保存服务端返回的 cookie数据， HTTP请求自动在消息头中放入 cookie 数据。如下示例：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 打印HTTP响应消息的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printResponse</span>(<span class="hljs-params">response</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'\n\n-------- HTTP response * begin -------'</span>)<br>    <span class="hljs-built_in">print</span>(response.status_code)<br><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> response.headers.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'<span class="hljs-subst">{k}</span>: <span class="hljs-subst">{v}</span>'</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">''</span>)<br><br>    <span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">'utf8'</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'-------- HTTP response * end -------\n\n'</span>)<br><br><br><span class="hljs-comment"># 创建 Session 对象</span><br>s = requests.Session()<br><br><span class="hljs-comment"># 通过 Session 对象 发送请求</span><br>response = s.post(<span class="hljs-string">"http://127.0.0.1/api/mgr/signin"</span>,<br>       data={<br>           <span class="hljs-string">'username'</span>: <span class="hljs-string">'byhy'</span>,<br>           <span class="hljs-string">'password'</span>: <span class="hljs-string">'88888888'</span><br>       })<br><br>printResponse(response)<br><br><span class="hljs-comment"># 通过 Session 对象 发送请求</span><br>response = s.get(<span class="hljs-string">"http://127.0.0.1/api/mgr/customers"</span>,<br>      params={<br>          <span class="hljs-string">'action'</span>    :  <span class="hljs-string">'list_customer'</span>,<br>          <span class="hljs-string">'pagesize'</span>  :  <span class="hljs-number">10</span>,<br>          <span class="hljs-string">'pagenum'</span>   :  <span class="hljs-number">1</span>,<br>          <span class="hljs-string">'keywords'</span>  :  <span class="hljs-string">''</span>,<br>      })<br><br>printResponse(response)<br></code></pre></td></tr></tbody></table></figure><p>如果Session对象所有的请求都通过设置的代理进行，可以这样使用：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br>proxies = {<span class="hljs-string">'http'</span>: <span class="hljs-string">'http://127.0.0.1:8888'</span>}<br><br>s = requests.session()<br><br>s.proxies.update(proxies)<br><br>s.get(<span class="hljs-string">"http://www.example.com"</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>三种解析方式：1、re解析；2、bs4解析、3、xpath解析。其中re解析最快，xpath现在最流行，bs4解析最方便，但性能最低。三种方式可以混用，完全以结果做导向，只要能拿到结果，用哪种方案并不重要。</p><ul><li><p>正则表达式：优点：速度快，效率高，准确性高。缺点：上手有点难度。</p></li><li><p>正则表达式的语法：使用元字符进行排列组合用来匹配字符串。</p></li><li><p>元字符：具有固定含义的特殊符号，常用元字符：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1</span>.匹配除换行符以外的任意字符<br><span class="hljs-number">2</span>\w匹配字母或数字或下划线<br><span class="hljs-number">3</span>\s匹配任意的空白符<br><span class="hljs-number">4.</span>\d匹配数字<br><span class="hljs-number">5.</span>\n匹配一个换行符<br><span class="hljs-number">6.</span>\t匹配一个制表符<br><span class="hljs-number">7.</span><br><span class="hljs-number">8.</span>^匹配字符串的开始<br><span class="hljs-number">9.</span>$匹配字符串的结束<br><span class="hljs-number">10.</span><br><span class="hljs-number">11.</span>\W匹配非字母或数字或下划线<br><span class="hljs-number">12.</span>\S匹配非空白符<br><span class="hljs-number">13.</span>\D匹配非数字<br><span class="hljs-number">14.</span>a|b匹配a或者b<br><span class="hljs-number">15.</span>()匹配括号内的表达式，也表示一个组<br><span class="hljs-number">16.</span>[]匹配字符组中的字符<br><span class="hljs-number">17.</span>[^]匹配除了字符组中字符的所有字符<br></code></pre></td></tr></tbody></table></figure></li><li><p>量词，控制前面的元字符出现的次数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span>*重复零次或更多次<br><span class="hljs-number">2.</span>+重复一次或更多次<br><span class="hljs-number">3.</span>?重复零次或一次<br><span class="hljs-number">4.</span>{n}重复n次<br><span class="hljs-number">5.</span>{n,}重复n次或更多次<br><span class="hljs-number">6.</span>{n,m}重复n到m次<br></code></pre></td></tr></tbody></table></figure></li><li><p>贪婪配置和惰性匹配，这是爬虫用得最多的就是这个惰性匹配</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span>.*贪婪匹配<br><span class="hljs-number">2.</span>.*?惰性匹配<br></code></pre></td></tr></tbody></table></figure></li><li><p>re模块，python内置的模块。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># findall，匹配字符串中所有符合正则的内容，返回的是列表。</span><br><span class="hljs-keyword">import</span> re<br>lst=re.findall(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)<span class="hljs-comment"># 建议第一个参数前加上r</span><br><span class="hljs-built_in">print</span>(lst)<br>运行结果：<br>[<span class="hljs-string">'13574048'</span>, <span class="hljs-string">'668'</span>, <span class="hljs-string">'10086'</span>]<br><br><span class="hljs-comment"># finditer，匹配字符串中所有符合正则的内容，反回的是迭代器，从迭代器中拿到内容要.group()</span><br><span class="hljs-keyword">import</span> re<br>lst=re.finditer(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">match</span>.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><span class="hljs-number">668</span><br><span class="hljs-number">10086</span><br><span class="hljs-comment"># 使用返回迭代器的效率要比使用列表高得多。</span><br><br><span class="hljs-comment"># 使用search，找到一个结果就返回，返回的是match对象，拿数据用.group()</span><br><span class="hljs-keyword">import</span> re<br>lst=re.search(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'我的电话是：13574048sina668，电话是10086'</span>)<br><span class="hljs-built_in">print</span>(lst.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><br><span class="hljs-comment">#match,从头开始匹配，第一个不符合就会报错，找到第一个就会返回。</span><br><span class="hljs-keyword">import</span> re<br>lst=re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r'\d+'</span>,<span class="hljs-string">'13574048sina668，电话是10086'</span>)<br><span class="hljs-built_in">print</span>(lst.group())<br>运行结果：<br><span class="hljs-number">13574048</span><br><br><span class="hljs-comment"># 预加载正则表达式，方便多次调用。</span><br><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br>obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r"&lt;div class='.*?&gt;&lt;span id='.*?'&gt;.*?&lt;/span&gt;&lt;/div&gt;"</span>,re.S)<br>ret=obj.findall(s)<br><span class="hljs-built_in">print</span>(ret)<br>运行结果：<br>[<span class="hljs-string">"&lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;"</span>, <span class="hljs-string">"&lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;"</span>]<br><br><span class="hljs-comment"># (?P&lt;分组名字&gt;正则)可以单独从正则匹配的内容中进一步提取内容。</span><br><span class="hljs-keyword">import</span> re<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br>obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r"&lt;div class='.*?&gt;&lt;span id='(?P&lt;id&gt;.*?)'&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;"</span>,re.S)<br><span class="hljs-comment"># re.S中，S是一个标志符，让.能匹配换行符。使用?P&lt;id&gt;的目的是使迭代器循环调用时通过.group(分组名)输出结果。</span><br>ret=obj.findall(s)<br><span class="hljs-built_in">print</span>(ret)  <br>运行结果：<br>[(<span class="hljs-string">'1'</span>, <span class="hljs-string">'李继晓'</span>), (<span class="hljs-string">'2'</span>, <span class="hljs-string">'小李飞刀'</span>)]<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>bs4解析：通过标签和属性去定位页面上的内容。</p></li><li><p>用法：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># pip install bs4</span><br><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> requests<br>s=<span class="hljs-string">"""" </span><br><span class="hljs-string">    &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">"""</span><br><span class="hljs-comment"># 1.将页面源代码交给Beautifulsoup进行处理，生成bs对象。</span><br>soup=BeautifulSoup(s,<span class="hljs-string">"html.parser"</span>)<span class="hljs-comment"># 指定html解析器，明确指出将返回结果转换成html格式，不加这个参数也不会报错，但会出现警告，并将返回结果转换成html来处理。</span><br><span class="hljs-comment"># 2.从bs对象中查找数据,find_all(标签，属性=值)。</span><br>resule=soup.find_all(<span class="hljs-string">'div'</span>,class_=<span class="hljs-string">'jay'</span>)<br><span class="hljs-built_in">print</span>(resule)<span class="hljs-comment"># 返回的是列表，但列表的内容格式是html格式，可继续使用fina_all(标签，属性=值)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(result[<span class="hljs-number">0</span>]))<span class="hljs-comment"># 注意列表的元素类型为&lt;class 'bs4.element.Tag'&gt;</span><br>result1=result[<span class="hljs-number">0</span>].find_all(<span class="hljs-string">'span'</span>) <br><span class="hljs-built_in">print</span>(result1)<br>result2=result1[<span class="hljs-number">0</span>].text <span class="hljs-comment"># 通过text最后取标签的结果。</span><br>result3=result1[<span class="hljs-number">0</span>].get(<span class="hljs-string">"id"</span>) <span class="hljs-comment"># 通过get能取到标签内的指定属性的值</span><br><span class="hljs-built_in">print</span>(result2)<br><span class="hljs-built_in">print</span>(result3)<br>运行结果：<br>[&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"jay"</span>&gt;&lt;span <span class="hljs-built_in">id</span>=<span class="hljs-string">"1"</span>&gt;李继晓&lt;/span&gt;&lt;/div&gt;]<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'bs4.element.Tag'</span>&gt;<br>[&lt;span <span class="hljs-built_in">id</span>=<span class="hljs-string">"1"</span>&gt;李继晓&lt;/span&gt;]<br>李继晓<br><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>xpath：是在xml文档中搜索内容的一门语言</p></li><li><p>html是xml的一个子集，xpath将标签当作一个结点处理，标签内的标签称为子结点，标签外的标签称为父结点。</p></li><li><p>使用xpath需要安装lxml模块：pip install lxml</p></li><li><p>使用方法：</p><p>选取节点：使用路径表达式来选择XML文档中的节点或者节点集。这些路径表达式和我们在常规的电脑系统中看到的表达式非常相似</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选择</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td></tr><tr><td>.</td><td>选择当前节点</td></tr><tr><td>..</td><td>选择当前节点的父节点</td></tr><tr><td>@</td><td>选择属性</td></tr></tbody></table><p>条件过滤：查找某个特定的的节点或包含某个指定的值的节点，被嵌在方括号中</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/ul/li[1]</td><td>选择属于ul子元素的第一个li元素</td></tr><tr><td>/ul/li[last()]</td><td>选择属于ul子元素的最后一个li元素</td></tr><tr><td>/ul/li[last()-1]</td><td>选择属于ul子元素的倒数第二个li元素</td></tr><tr><td>/ul/li[position()&lt;3]</td><td>选取最前面的两个属于ul元素的子元素的li元素</td></tr><tr><td>//div[@attr]</td><td>选取所有拥有名为attr属性的div元素</td></tr><tr><td>//div[@attr=‘leng’]</td><td>选取所有div元素，且这些元素拥有值为leng的attr属性</td></tr></tbody></table><p>选择未知节点：通配符可用来选取未知的XML元素</p><table><thead><tr><th>通配符</th><th>描述/结果</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点</td></tr><tr><td>@*</td><td>匹配任何属性节点</td></tr><tr><td>/div/*</td><td>选取div元素的所有子元素</td></tr><tr><td>//*</td><td>选取文档中的所有元素</td></tr><tr><td>html/node()/a/@*</td><td>选择html下面任意节点下的a节点的所有属性</td></tr><tr><td>//div[@*]</td><td>选取所有带有属性的div元素</td></tr><tr><td>//li[contains(@attr,100)]</td><td>选取属性为attr，并且值为100的所有元素。contains属于模糊匹配</td></tr><tr><td>//*[contains(text(),’当’)]</td><td>选择所有元素中文本中包含有“当”字符的元素</td></tr></tbody></table><p>获取数据：1、获取文本数据，选取节点后要获取节点中的文本内容，使用text()方法；2、获取属性值，@属性</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>/div/ul/li/span/text()</td><td>获取span标签中的文本内容</td></tr><tr><td>/div//li/a/@herf</td><td>获取a标签中的herf属性</td></tr></tbody></table><p>以上就是xpath的语法内容，在运用到Python抓取时要先转换为XML，如下示例</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># from lxml import etree  导入etree模块，lxml库是专门用来解析XML文档的库</span><br><span class="hljs-comment"># tree=etree.XML()创建etree对象</span><br><span class="hljs-comment"># tree.xpath()调用xpath方法</span><br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>s=<span class="hljs-string">"""</span><br><span class="hljs-string">&lt;root&gt;</span><br><span class="hljs-string">    &lt;book&gt;</span><br><span class="hljs-string">        &lt;title&gt;Python&lt;/title&gt;</span><br><span class="hljs-string">        &lt;author&gt;Guido van Rossum&lt;/author&gt;</span><br><span class="hljs-string">        &lt;year&gt;1991&lt;/year&gt;</span><br><span class="hljs-string">    &lt;/book&gt;</span><br><span class="hljs-string">    &lt;book&gt;</span><br><span class="hljs-string">        &lt;title&gt;Java&lt;/title&gt;</span><br><span class="hljs-string">        &lt;author&gt;James Gosling&lt;/author&gt;</span><br><span class="hljs-string">        &lt;year&gt;</span><br><span class="hljs-string">        &lt;a href="https://www.java.com"&gt;2000&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="https://www.oracle.com"&gt;2005&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="https://www.openjdk.java.net"&gt;2011&lt;/a&gt;</span><br><span class="hljs-string">            &lt;a href="maodian"&gt;锚点&lt;/a&gt;</span><br><span class="hljs-string">            &lt;title&gt;Python&lt;/title&gt;</span><br><span class="hljs-string">        &lt;/year&gt;</span><br><span class="hljs-string">    &lt;/book&gt;</span><br><span class="hljs-string">&lt;/root&gt;</span><br><span class="hljs-string">"""</span><br>tree=etree.XML(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(tree))<br>result=tree.xpath(<span class="hljs-string">'/root'</span>)<span class="hljs-comment"># /表示层级关系，第一个/是根节点，返回一个结点的迭代器</span><br>result1=tree.xpath(<span class="hljs-string">'/root/book/title/text()'</span>)<span class="hljs-comment">#text()返回结点内容。</span><br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(result1)<br>result2=tree.xpath(<span class="hljs-string">"//title/text()"</span>)<span class="hljs-comment"># //后代结点。</span><br><span class="hljs-built_in">print</span>(result2)<br>result3=tree.xpath(<span class="hljs-string">"/root/book/*/title/text()"</span>)<span class="hljs-comment"># 任意的节点，通配符。</span><br><span class="hljs-built_in">print</span>(result3)<br>result4=tree.xpath(<span class="hljs-string">"/root/book/year/a[1]/text()"</span>)<span class="hljs-comment"># 通过索引拿到第一个内容。</span><br><span class="hljs-built_in">print</span>(result4)<br>result5=tree.xpath(<span class="hljs-string">"/root/book/year/a[@href='maodian']/text()"</span>) <span class="hljs-comment"># 通过[@取属性=值]来取到内容</span><br><span class="hljs-built_in">print</span>(result5)<br>result6=tree.xpath(<span class="hljs-string">"/root/book/year/a[1]/@href"</span>)<span class="hljs-comment"># 通过@属性，取到标签内的属性值。</span><br><span class="hljs-built_in">print</span>(result6)<br>输出结果：<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'lxml.etree._Element'</span>&gt;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'lxml.etree._Element'</span>&gt;<br>[&lt;Element root at <span class="hljs-number">0x1bf98c6a8c0</span>&gt;]<br>[<span class="hljs-string">'Python'</span>, <span class="hljs-string">'Java'</span>]<br>[<span class="hljs-string">'Python'</span>, <span class="hljs-string">'Java'</span>, <span class="hljs-string">'Python'</span>]<br>[<span class="hljs-string">'Python'</span>]<br>[<span class="hljs-string">'2000'</span>]<br>[<span class="hljs-string">'锚点'</span>]<br>[<span class="hljs-string">'https://www.java.com'</span>]<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="requests进阶"><a href="#requests进阶" class="headerlink" title="requests进阶"></a>requests进阶</h2><ul><li><p>当网站需要用户名和密码进行登录时：</p></li><li><p>登录后会得到cookie，当再次请求网站其它url时，就会带着cookie去请求，不需要再次输入登录名有密码，这时候写代码就得把登录和cookie这两操作连起来，这时候就可以使用session。</p></li><li><p>session意思是会话，可以认为是一连串的请求，在这个过程中cookie不会丢失。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br>session=requests.session()<span class="hljs-comment">#可获取session对象</span><br>data={<br>    <span class="hljs-string">"loginName"</span>:<span class="hljs-string">"13574048668"</span>,<br>    <span class="hljs-string">"passwrod"</span>:<span class="hljs-string">"741209"</span><br>}<br><span class="hljs-comment"># 1.登录</span><br>url=<span class="hljs-string">"http://zhcxapp.hnrcc.bank/hnhccp/"</span><br>resp=session.post(url,data=data)<span class="hljs-comment"># 通过session对象进行数据提交。</span><br><span class="hljs-built_in">print</span>(resp.text)<span class="hljs-comment"># 显示返回数据</span><br><span class="hljs-built_in">print</span>(resp.cookies)<span class="hljs-comment"># 显示cokkies内容</span><br><span class="hljs-comment"># 2.拿登录进去后的其它url链接数据</span><br><span class="hljs-comment"># 刚才哪个session中是有cookie的，不要使用requests.get()请求，否则拿不到数据。</span><br>resp1=session.get(<span class="hljs-string">"http://zhcxapp.hnrcc.bank/hnhccp/file?id=123"</span>)<br><span class="hljs-built_in">print</span>(resp1.json())<span class="hljs-comment"># 这里返回的数据一般是json格式的，不使用test而使用json会显示得更友好些。</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>代理是通过第三方的一个机器去发送请求，用法：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs py">  <span class="hljs-keyword">import</span> requests<br>  <span class="hljs-comment"># 从https://www.zdaye.com/free/站点找哪些透明或者普匿的ip地址:端口，放在一个字典中。</span><br>  proxies={<br>    <span class="hljs-string">'http'</span>: <span class="hljs-string">'111.1.61.47:3128'</span>,<br>    <span class="hljs-string">'https'</span>: <span class="hljs-string">'119.3.113.151:9094'</span><br>  }<br>  url=<span class="hljs-string">"http://www.baidu.com"</span><br>  resp=requests.get(url,proxies=proxies)<span class="hljs-comment"># 调用代理参数</span><br>  <span class="hljs-built_in">print</span>(resp)<br>  运行结果：<br>&lt;Response [<span class="hljs-number">200</span>]&gt;<br><br><span class="hljs-comment">## 多线程</span><br><br>+ 操作系统每次运行一个程序的时侯，都会给这个程序准备一块内存，存放程序执行过程中的变量，这个内存区域可以称为进程。在进程内面有一个或多个线程，来帮助我们工作。所在进程与线程的关系是：<br><br>+ 进程是资源单位，线程是执行单位。程序运行的时候必须创建线程去执行。好比一个公司，公司是资源单位，而公司运转的话必须要有员工，员工就是线程，公司的一个项目需要多个人去完成的时候，多个人就是多线程。如果线程没有了，进程也就没用了。<br><br>+ 每一个进程至少需要一个线程，CPU在工作的时候，调度的是一个线程。启动每一个程序，默认都会有一个主线程。<br><br>+ 实现多线程的二种方法：<br><br>  ```py<br>  <span class="hljs-number">1.</span> 第一种方法，创建线程实例对象方式运行：<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<span class="hljs-comment"># 线程类</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>():<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f"my_func"</span>,i)<br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t1 = Thread(target=my_func) <span class="hljs-comment"># 创建一个线程对象，并给线程安排任务</span><br>      t1.start()<span class="hljs-comment"># 开始执行该线程，实质是给多线程对象加了一个可以开始工作状态，具体执行时间由CPU决定</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">f"main!"</span>,i)<br>  运行结果描述：主线程运行到t.start()后，就会有二条线程同时在运行，my_func函数和主入口函数main交互输出结果。<br>  <br>  <span class="hljs-number">2.</span>自己定义一个类，继承线程类，重写线程类的run()方法：<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 当线程被执行的时候，被执行的就是run()</span><br>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>              <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程"</span>,i)<br>  <br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t=MyThread()<br>      <span class="hljs-comment"># t.run()这里调用的是函数的run()方法，实际运行时还是单线程</span><br>      t.start()<span class="hljs-comment"># 这样调用同上面一样，是给多线程添加了可以开始工作的状态，实现了多线程运行</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主线程!"</span>,i)<br>          <br>  <span class="hljs-comment"># 注意：线程传的参数必须是元组</span><br>  <span class="hljs-number">1.</span>创建实例对象方法<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">name</span>):<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f"my_func"</span>,i,name)<br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t1 = Thread(target=my_func,args=(<span class="hljs-string">"李继晓"</span>,)) <span class="hljs-comment"># 参数是元组，只有一个参数时要用,区分</span><br>      t1.start()<br>      t1 = Thread(target=my_func,args=(<span class="hljs-string">"小李飞刀"</span>,)) <br>      t1.start()<br>  <span class="hljs-number">2.</span>定义一个类，继续父类方法<br>  <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<span class="hljs-comment"># 在构造函数中传递参数</span><br>          <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 需要调用父类 Thread 的初始化方法，不调用的话某些情况下会出现问题</span><br>          <span class="hljs-variable language_">self</span>.name = name<br>  <br>      <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>              <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子线程 <span class="hljs-subst">{self.name}</span>"</span>, i)<br>  <br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>      t = MyThread(<span class="hljs-string">"李继晓"</span>)<br>      t.start()<br>      t1 = MyThread(<span class="hljs-string">"小李飞刀"</span>)<br>      t1.start()<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul><li><p>相对于线程，多进程使用较少，因为开辟进程所消耗的内存资源要比线程大得多。</p></li><li><p>创建方法与创建子线程的二种方法相似:</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span> 第一种方法，创建进程实例对象方式运行：<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子进程"</span>,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    p=Process(target=my_func)<br>    p.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主进程!"</span>,i)<br>        <br><span class="hljs-number">2.</span>自己定义一个类，继承线程类，重写线程类的run()方法：<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcess</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 当线程被执行的时候，被执行的就是run()</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"子进程"</span>,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    p=MyThread()<br>    <span class="hljs-comment"># p.run()这里调用的是函数的run()方法，实际运行时还是单进程</span><br>    p.start()<span class="hljs-comment"># 这样调用同上面一样，是给多进程添加了可以开始工作的状态，实现了多进程运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"主进程!"</span>,i)<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="线程池和进程池"><a href="#线程池和进程池" class="headerlink" title="线程池和进程池"></a>线程池和进程池</h2><ul><li><p>线程池：一次性开辟一些线程，我们用户直接给线程池子提交任务，线程任务的调度交给线程池来完成。</p></li><li><p>方法：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor <span class="hljs-comment">#创建线程池</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor <span class="hljs-comment">#创建进程池</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        <span class="hljs-built_in">print</span>(name,i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 创建线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">50</span>) <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-comment"># 向线程池提交任务</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<span class="hljs-comment"># 制定任务完成的次数</span><br>            executor.submit(fun, <span class="hljs-string">f"在运行线程<span class="hljs-subst">{i}</span>"</span>)<br>            <span class="hljs-comment"># 等待线程池中的任务全部执行完毕，才继续执行（守护）</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"线程池执行完毕"</span>)<br><span class="hljs-comment"># 该段代码会运行100个线程对象（任务的次数），每个线程都运行fun函数，统一交给线程池来调度运行，而线程池由50个线程来分配运行，一直到运行完成后才会打印出执行完毕的结果。</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li><p>一般情况下，sleep(3)方法、input()方法、网络请求返回数据之前、程序处于IO操作的时候，线程会处于阻塞状态，阻塞状态下，CPU是不为我工作的。为解决这种问题，引入了协程。</p></li><li><p>协程：当程序遇见了阻塞操作的时候，可以选择性地切换到其它任务上，让CPU继续为我工作，实现充分地将CPU绑定在我的程序上面。</p></li><li><p>在微观上，协程是一个任务一个任务的进行切换，切换条件就是会产生阻塞的操作；在宏观上，我们看到的其实是多个任务一起在执行，所以协程就是多任务异步操作。都是在单线程条件下发生。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> asyncio<span class="hljs-comment"># 导入异步模块</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<span class="hljs-comment"># 加上async后，这个函数变成了异步函数，需要用异步模块的run()方法调用</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world!"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    asyncio.run(test()) <span class="hljs-comment"># run()运行事件循环，test()将在事件循环中并发执行</span><br>    --------------------------------------------------------------------------<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world1!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world2!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, world3!"</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    tasks = [asyncio.create_task(test1()), asyncio.create_task(test2()), asyncio.create_task(test3())]<br>    <span class="hljs-keyword">await</span> asyncio.wait(tasks)<span class="hljs-comment"># 等待所有任务完成</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># asyncio.create_task() 函数会将协程包装成任务对象，并安排它们在事件循环中并发执行。</span><br>    asyncio.run(main()) <span class="hljs-comment"># asyncio.run() 会运行事件循环，直到 asyncio.wait(main()) 完成</span><br>运行结果：<br>Hello, world1!<br>Hello, world2!<br>Hello, world3!<br>[Done] exited <span class="hljs-keyword">with</span> code=<span class="hljs-number">0</span> <span class="hljs-keyword">in</span> <span class="hljs-number">4.334</span> seconds<br></code></pre></td></tr></tbody></table></figure></li><li><p>await的含义：是Python异步编程中的核心关键字，主要含义和作用如下：</p><ol><li><p><strong>执行权让出机制</strong></p><ol><li><p>表示”等待这个异步操作完成”</p></li><li><p>会让出当前协程的执行权，使事件循环可以执行其他任务</p></li><li><p>不会阻塞整个线程，仅暂停当前协程</p></li></ol></li><li><p>使用限制</p><ol><li><p>必须用在<code>async def</code>定义的异步函数内面使用</p></li><li><p>后面必须跟一个”可等待对象”（Awaitable），如：</p><ol><li>协程（coroutine）</li><li>任务（Task）</li><li>Future对象</li></ol></li></ol></li><li><p><strong>典型应用场景</strong></p><ol><li>网络请求（HTTP/TCP）</li><li>文件IO操作</li><li>数据库查询</li><li>睡眠延迟（<code>await asyncio.sleep(1)</code>）</li></ol></li><li><p><strong>注意事项</strong></p><ol><li>忘记写<code>await</code>会导致协程不执行（常见错误）</li><li>在错误位置使用会报错：<code>SyntaxError: 'await' outside async function</code></li><li>合理使用可以大幅提升I/O密集型程序的并发性能</li></ol></li></ol></li><li><p>异步http请求aiohttp模块</p></li><li><ul><li><p>requests.get()是同步的代码，异步操作要改成aiohttp。安装方法：pip install aiohttp。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_webpage</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<span class="hljs-comment"># 相当于是同步的requests，前面加async是语法规定</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(session))<span class="hljs-comment"># 返回的是异步对象</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">'http://www.baidu.com/'</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response))<span class="hljs-comment"># 返回的是异步的对象的结果</span><br>            <span class="hljs-comment"># with open('test.txt', 'w', encoding='utf-8') as f:</span><br>            <span class="hljs-comment">#     f.write(await response.text())  注意异步是text()，同步是text,细微差别，写取内容是异步的，要加上await挂起。</span><br>            运行结果：<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'aiohttp.client.ClientSession'</span>&gt;<br>            &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'aiohttp.client_reqrep.ClientResponse'</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>在链接非常多的情况下，多任务异步比同步下载要快得多，实践过程中，抓取4000多个小说的链接内容，同步花了26分钟左右，而同步仅用时56秒就完成了。</p></li></ul><h2 id="m3u8解析"><a href="#m3u8解析" class="headerlink" title="m3u8解析"></a>m3u8解析</h2><ul><li>m3u8是一个文本文件，本身并不是媒体文件，里面是以<a href="https://zhida.zhihu.com/search?content_id=441131229&amp;content_type=Answer&amp;match_order=1&amp;q=UTF-8&amp;zhida_source=entity">UTF-8</a>格式记录的音频视频资源，以及这些资源的播放地址。m3u8相当于视频音频资源的种子文件。</li><li>M3U8 文件是一个UTF-8编码的文本文件，所以用任何文本工具都能打开，但是如果用文本打开，你会发现里面记录的都是视频或者音频资源的访问路径。基于M3U8文件格式播放，你需要专门支持流媒体播放的播放器。可能有人发现.M3U文件也是这样的，是的，.M3U和 .M3U8文件的唯一区别就是一个是UTF8编码过的。</li><li>视频播放过程：现在的视频网站采用的是<a href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B5%81%E5%AA%92%E4%BD%93%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&amp;zhida_source=entity">流媒体传输协议</a>，就是将一段视频切成无数个小段，这几个小段就是<a href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=ts&amp;zhida_source=entity">ts</a>格式的视频文件，一段一段的网站上播放。一个视频播放的全过程如下：<ol><li>服务器采集编码传输视频到切片器</li><li>切片器对视频创建**<a href="https://zhida.zhihu.com/search?content_id=165170599&amp;content_type=Article&amp;match_order=1&amp;q=%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6&amp;zhida_source=entity">索引文件</a>，<strong>并且</strong>切割<strong>成</strong>n个ts文件**</li><li>这2个文件传输到http服务器上</li><li>网站/客户端根据<strong>索引文件</strong>查找http服务器上的<strong>ts文件</strong>，连续播放这n个ts文件，就可以了。</li></ol></li><li>索引文件非常重要，索引文件里面存储着ts文件的网络url链接，网站需要拿到索引文件，去按照url链接下载在http服务器中的ts文件。</li><li>索引文件就是m3u8文件。现在大部分视频网站传输都是采用这种方法，所以，也就是说，如果你在观看网页视频的时候，能够弄到加载该视频的m3u8文件，那么再配合一些工具，就能下载该视频了。</li><li>爬虫下载过程：<ol><li>拿到页面源代码</li><li>从源代码中提取到m3u8的url</li><li>下载m3u8</li><li>读取m3u8，获取ts下载链接，下载视频</li><li>合并视频</li></ol></li></ul><h2 id="初始化搜狗浏览器"><a href="#初始化搜狗浏览器" class="headerlink" title="初始化搜狗浏览器"></a>初始化搜狗浏览器</h2><ul><li>搜狗浏览器使用的是chromed内核，确定搜狗使用的是哪种版本后去下载对应版本的webdriver驱动，然后使用下面的代码：</li></ul><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.service <span class="hljs-keyword">import</span> Service<br><br><span class="hljs-comment"># 设置搜狗浏览器的路径</span><br>sogou_browser_path = <span class="hljs-string">r"D:\SogouExplorer\SogouExplorer.exe"</span><br>options = webdriver.ChromeOptions()<br>options.binary_location = sogou_browser_path<br><span class="hljs-comment"># 初始化浏览器驱动</span><br>driver = webdriver.Chrome(options=options,service=Service(<span class="hljs-string">r"D:\vscode\chromedriver.exe"</span>))<br><span class="hljs-comment"># 调用WebDriver 对象的get方法 可以让浏览器打开指定网址</span><br>driver.get(<span class="hljs-string">'http://zhcxapp.hnrcc.bank/hnhccp/'</span>)<br></code></pre></td></tr></tbody></table></figure><ul><li><p>浏览器内核版本查看地址：<a href="https://liulanmi.com/labs/core.html">https://liulanmi.com/labs/core.html</a></p></li><li><p>谷歌浏览器驱动版本下载地址：</p></li><li><ul><li>老版本地址：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a></li></ul></li><li><ul><li>新版本地址：<a href="https://registry.npmmirror.com/binary.html?path=chrome-for-testing/">https://registry.npmmirror.com/binary.html?path=chrome-for-testing/</a></li></ul></li><li><ul><li>统一浏览器内核版本：108.0.5359.95</li></ul></li><li><ul><li>人行Pisa能正常运行的内核版本：80.0.3987.87</li></ul></li><li><ul><li>Edge浏览器目前内核版本：134.0.0.0</li></ul></li><li><ul><li>谷歌浏览器目前内核版本：135.0.0.0</li></ul></li></ul><h2 id="selenium自动化"><a href="#selenium自动化" class="headerlink" title="selenium自动化"></a>selenium自动化</h2><ul><li>关于验证码：<ol><li>直接把浏览器内面的cookie拿出来直接用</li><li>手动编写验证码识别的功能（深度学习）</li><li>第三方打码平台（收费），超级鹰、图鉴</li></ol></li></ul><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 学习参考资料</span><br><span class="hljs-number">1.</span> 下载谷歌浏览器驱动<br>查看谷歌浏览器的版本 设置--&gt;帮助--&gt;关于Chrome<br><br>进入网站下载 https://npmmirror.com 选择 Selenium 镜像: https://npmmirror.com/mirrors/selenium/ 对应我们浏览器的版本下载Selenium版本<br>新建python工程 将下载解压后的exe文件拖入根目录下<br>案例 百度查询⬇<br><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>​<br><span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br>​<br>driver = webdriver.Chrome(<span class="hljs-string">"./chromedriver.exe"</span>)<br><span class="hljs-comment"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>html = driver.page_source  获取整个页面源代码数据<br>​<br>kw = driver.find_element(By.ID,<span class="hljs-string">"kw"</span>)<br>kw.send_keys(<span class="hljs-string">"丢丢"</span>)<br>​<br><span class="hljs-comment"># driver.find_element(By.CSS_SELECTOR,"#su").click()</span><br>su = driver.find_element(By.ID,<span class="hljs-string">"su"</span>).click()<br>su.click()<br><br><span class="hljs-comment"># driver对象的相关属性：</span><br><span class="hljs-number">1.</span>current_url：当前url地址<br><span class="hljs-number">2.</span>title：页面标题<br><span class="hljs-number">3.</span>page_source：页面html代码（渲染以后的）<br><span class="hljs-number">4.</span>window_handler：获取浏览器上所有的窗口句柄<br><span class="hljs-number">5.</span>current_window_handler：获取当前窗口句柄<br><span class="hljs-comment">#一.元素定位</span><br><span class="hljs-number">1.</span> 获取单个元素<br>driver.find_element(By.ID，<span class="hljs-string">"inputorigina”）</span><br><span class="hljs-string">driver.find_element(By.CSS_SELECTOR，"</span><span class="hljs-comment">#inputoriginal"）</span><br>driver.find_element(By.TAG_NAME，<span class="hljs-string">"div"</span>）<br>driver.find_element（By.NAME，<span class="hljs-string">"username"</span>)<br>driver.find_element(By.LINK_TEXT,“下一页”）<br>driver.find_element(By.XPATH,<span class="hljs-string">"//*[@id='kw']"</span>)  <span class="hljs-comment">#会以上一种就可以了，现在主流是xpath定位               </span><br><span class="hljs-number">2.</span> 如果找不到相应的元素会报错<br>selenium.common.exceptions.NosuchElementException: Message:no such element:Unable to 7ocate element:XX<br><span class="hljs-number">3.</span> 获取多个元素<br>driver.find_elements(By.ID，<span class="hljs-string">"inputoriginal”）</span><br><span class="hljs-string">driver.findelements(By.CSS_SELECTOR，“inputoriginal”）</span><br><span class="hljs-string">driver.find_elements(By.TAG_NAME,“div"</span>)<br>driver.findelements(By.NAME，“username”)<br>driver.find_elements(By.LINK_TEXT，<span class="hljs-string">"下一页”）</span><br><span class="hljs-string">4. 内容获取与操作</span><br><span class="hljs-string">    1. size 返回元素大小</span><br><span class="hljs-string">    2. text 获取元素的文本 &lt;div&gt;hello&lt;/div&gt;</span><br><span class="hljs-string">    3. title 获取页面的title</span><br><span class="hljs-string">    4. current_url 获取当前页面URL</span><br><span class="hljs-string">    5. get_attribute() 获取属性值&lt;a href="</span>www.baidu.com<span class="hljs-string">"&gt;&lt;/a&gt;</span><br><span class="hljs-string">    6. is_display() 判断元素是否可见</span><br><span class="hljs-string">    7. is_enabled() 判断元素是否可用</span><br><span class="hljs-string">    8. driver.page_source  获取整个页面数据</span><br><span class="hljs-string">    9. tagname 获取标签名</span><br><span class="hljs-string">10. parent 获取父级标签   </span><br><span class="hljs-string">11. click() 点击元素</span><br><span class="hljs-string">12. clear() 清空表单</span><br><span class="hljs-string">13. send_keys() 输入内容</span><br><span class="hljs-string"># 示例</span><br><span class="hljs-string">   from datetime import time</span><br><span class="hljs-string">            from selenium import webdriver</span><br><span class="hljs-string">            from selenium.webdriver.common.by import By</span><br><span class="hljs-string">            driver = webdriver.Chrome()</span><br><span class="hljs-string">            driver.get('http://www.baidu.com')         </span><br><span class="hljs-string">            time.sleep(10)</span><br><span class="hljs-string">            li_list=driver.find_elements(By.XPATH,'//ul[@class="</span>replylist<span class="hljs-string">"]/li')  </span><br><span class="hljs-string">            for item in li_list</span><br><span class="hljs-string">                 title=item.find_element(By.XPATH,'./div/[@class="</span>title<span class="hljs-string">"]/h1').text #通过xpath方式找到的元素对象，可以继续使用xpath语法在元素中继续搜索目标，最后显示出文本。</span><br><span class="hljs-string">             driver.quit()        </span><br><span class="hljs-string">5. 窗口操作</span><br><span class="hljs-string">    1. maximize_window() 窗口最大化</span><br><span class="hljs-string">    2. set_window_size(100,100) 浏览器大小 设置浏览器的宽高(像素点)</span><br><span class="hljs-string">    3. set_window_position(300,200) 浏览器位置 设置浏览器位置</span><br><span class="hljs-string">    4. back() 后退</span><br><span class="hljs-string">    5. forward() 前进</span><br><span class="hljs-string">    6. refresh() 刷新</span><br><span class="hljs-string">    7. close() 关闭浏览器按钮(关闭单个窗口)</span><br><span class="hljs-string">    8. quit() 关闭webDriver启动的窗口</span><br><span class="hljs-string">6. 访问有道翻译网站，输入单词，并获取翻译后的内容</span><br><span class="hljs-string">#encoding:utf-8</span><br><span class="hljs-string">from datetime import time</span><br><span class="hljs-string">​</span><br><span class="hljs-string">from selenium import webdriver</span><br><span class="hljs-string"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-string">from selenium.webdriver.common.by import By</span><br><span class="hljs-string">​</span><br><span class="hljs-string">driver = webdriver.Chrome("</span>./chromedriver.exe<span class="hljs-string">")</span><br><span class="hljs-string"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br><span class="hljs-string">driver.get("</span>https://fanyi.youdao.com/<span class="hljs-string">")</span><br><span class="hljs-string">time.sleep(4)</span><br><span class="hljs-string"># 获取输入框</span><br><span class="hljs-string">input = driver.find_element(By.ID,"</span>inputOriginal<span class="hljs-string">")</span><br><span class="hljs-string"># 输入内容</span><br><span class="hljs-string">input.send_keys("</span>hello<span class="hljs-string">")</span><br><span class="hljs-string"># 获取翻译按钮</span><br><span class="hljs-string">tbtn = driver.find_element(By.ID,"</span>transMachine<span class="hljs-string">")</span><br><span class="hljs-string"># 先获取遮挡的广告条 点击关闭按钮</span><br><span class="hljs-string">close_btn = driver.find_element(By.CSS_SELECTOR,"</span>.guide-con .guide-close<span class="hljs-string">")</span><br><span class="hljs-string">close_btn.click()</span><br><span class="hljs-string"># 点击翻译</span><br><span class="hljs-string">tbtn.click()</span><br><span class="hljs-string"># 获取翻译后的内容</span><br><span class="hljs-string">transTarget = driver.find_element(By.ID,"</span>transTarget<span class="hljs-string">")</span><br><span class="hljs-string">print(transTarget.text)</span><br><span class="hljs-string">7. 爬当当网书籍的数据</span><br><span class="hljs-string">#encoding:utf-8</span><br><span class="hljs-string">from datetime import time</span><br><span class="hljs-string">​</span><br><span class="hljs-string">from selenium import webdriver</span><br><span class="hljs-string"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-string">from selenium.webdriver.common.by import By</span><br><span class="hljs-string">​</span><br><span class="hljs-string">driver = webdriver.Chrome("</span>./chromedriver.exe<span class="hljs-string">")</span><br><span class="hljs-string">driver.implicitly_wait(30)  # 隐式等待30秒，针对webdriver元素对象的所有查询，全局有效。</span><br><span class="hljs-string"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br><span class="hljs-string">driver.get("</span>https://www.dangdang.com/<span class="hljs-string">")</span><br><span class="hljs-string">driver.maximize_window()</span><br><span class="hljs-string"># 获取输入框</span><br><span class="hljs-string">key = driver.find_element(By.ID,"</span>key_S<span class="hljs-string">")</span><br><span class="hljs-string">key.send_keys("</span>科幻<span class="hljs-string">")</span><br><span class="hljs-string"># 获取搜索框 点击搜索</span><br><span class="hljs-string">search = driver.find_element(By.CSS_SELECTOR,"</span><span class="hljs-comment">#form_search_new .button")</span><br>search.click()<br><span class="hljs-comment"># 获取商品标题及价格</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>  shoplist = driver.find_elements(By.CSS_SELECTOR,<span class="hljs-string">".shoplist li"</span>)<br>  <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> shoplist:<br>    <span class="hljs-built_in">print</span>(li.find_element(By.CSS_SELECTOR,<span class="hljs-string">"a"</span>).get_attribute(<span class="hljs-string">"title"</span>))<br>    <span class="hljs-built_in">print</span>(li.find_element(By.CSS_SELECTOR,<span class="hljs-string">".search_now_price"</span>).text)<br>​<br>  <span class="hljs-comment"># 获取下一页的按钮</span><br>  <span class="hljs-built_in">next</span> = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"下一页"</span>)<br>  <span class="hljs-built_in">next</span>.click()<br><span class="hljs-number">8.</span> 显式等待：显式等待某些情况下找不到时使用<br><span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverwait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-comment">#程序每0.5秒检查，是否满足：标题包含“百度一下”这个条件，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常</span><br>WebDriverwait（driver，<span class="hljs-number">15</span>).until（Ec.title_contains（“百度一下”）<br><span class="hljs-comment">#程序每0.5秒检查，是否满足：某定位的元素出现，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常</span><br>WebDriverwait(driver，<span class="hljs-number">15</span>）.until（Ec.visibility_of_element_located(By.CSS_SELECTOR，“XX”））<br><span class="hljs-number">9.</span> 隐式等待<br>implicitly_wait(time_to_wait)<br>设置时间单位为秒 例如<span class="hljs-number">30</span>秒 implicitly_wait(<span class="hljs-number">30</span>) 意思是超过<span class="hljs-number">30</span>秒没有定位到一个元素 程序就回抛出异常,期间会一直轮询查找定位元素<br><br>二. 鼠标及键盘操作:使用ActionChains类，导入：<span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-number">1.</span> 鼠标操作<br>    <span class="hljs-number">1.</span> context_click() 右击<br>    <span class="hljs-number">2.</span> double_click() 双击<br>    <span class="hljs-number">3.</span> drag_and_drop() 拖动，在一个位置按下鼠标，到另一个位置释放<br>    <span class="hljs-number">4.</span> move_to_element() 悬停，鼠标移动到某个节点<br>    <span class="hljs-number">5.</span> perform()    执行动作<br><span class="hljs-number">6.</span>click()  鼠标左击    <br><span class="hljs-number">7.</span>click_and_hold鼠标左键按下鼠标                                                               <span class="hljs-number">8.</span>move_by_offse鼠标相对当前位置进行移动<br><span class="hljs-number">9.</span>release()释放鼠标<br>                                                               driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>more = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"更多"</span>)<br><span class="hljs-comment"># 将鼠标移动到更多按钮</span><br>ActionChains(driver).move_to_element(more).perform()<br>案例 打开百度鼠标移动到更多位置<br><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-comment"># 调用环境变量指定的PhantomJS浏览器创建浏览器对象</span><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br>driver = webdriver.Chrome(<span class="hljs-string">"./chromedriver.exe"</span>)<br><span class="hljs-comment"># get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)</span><br>driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>more = driver.find_element(By.LINK_TEXT,<span class="hljs-string">"更多"</span>)<br><span class="hljs-comment"># 将鼠标移动到更多按钮</span><br>ActionChains(driver).move_to_element(more).perform()<br><span class="hljs-number">2.</span> 键盘操作<br>    <span class="hljs-number">1.</span> send_keys（Keys,BACK_SPACE）删除键（Backspace）<br>    <span class="hljs-number">2.</span> send_keys（Keys.SPACE）空格键（Space）<br>    <span class="hljs-number">3.</span> send_keys（Keys.TAB）制表键（Tab）<br>    <span class="hljs-number">4.</span> send_keys（Keys·ESCAPE）回退键（ESC）<br>    <span class="hljs-number">5.</span> send_keys（Keys·ENTER）回车键（Enter）<br>    <span class="hljs-number">6.</span> send_keys（Keys.CONTROL，<span class="hljs-string">'a'</span>）全选（Ctrl+A）<br>    <span class="hljs-number">7.</span> send_keys（Keys.CONTROL，<span class="hljs-string">'c'</span>）复制（Ctr1+C）<br><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<br>driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)<br>element = driver.find_element(By.ID,<span class="hljs-string">"kw"</span>)<br><span class="hljs-comment">#输入用户名</span><br>element.send_keys(<span class="hljs-string">"admin1"</span>)<br><span class="hljs-comment">#删除1</span><br>element.send_keys(Keys.BACK_SPACE)<br><span class="hljs-comment">#全选</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'a'</span>)<br><span class="hljs-comment">#复制</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'c'</span>)<br><span class="hljs-comment">#粘贴</span><br>element.send_keys(Keys.CONTROL,<span class="hljs-string">'v'</span>)<br>                                                                <br>三. 窗口滚动条<br>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载<br><span class="hljs-comment">#1.设置]avascritp脚本控制滚动条，（0:左边距；1000：上边距；单位像素）</span><br>js=<span class="hljs-string">"window.scro11To(0,1000)"</span><br>js=<span class="hljs-string">"window.scro11By(0,1000)"</span>    <span class="hljs-comment"># 向下滚动1000像素                                         </span><br>driver.execute_script(js）<span class="hljs-comment"># WebDriver调用js脚本方法</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>time.sleep(random.random()) <span class="hljs-comment"># 等待0-1秒</span><br>js=<span class="hljs-string">"window.scro11By(0,{})"</span>.<span class="hljs-built_in">format</span>(random.randint(<span class="hljs-number">100</span>,<span class="hljs-number">300</span>))  <span class="hljs-comment">#向下滚动100到300像素                   driver.execute_script(js)</span><br><span class="hljs-comment">#2. 使用selenium的滚动元素可见属性,定位到 【查看更多】 的元素</span><br>ele=driver.find_element(By.PATH,<span class="hljs-string">'//*[@class="mostlist"]'</span>) <br>time.sleep(<span class="hljs-number">2</span>)                      <br>res=ele.location_once_scrolled_into_view                      <br>    <span class="hljs-built_in">print</span>(res)<span class="hljs-comment"># 查看滚动之后的座标</span><br>ele.click()<span class="hljs-comment"># 点击滚动按钮                      </span><br>四. 窗口截图<br>自动化脚本是由程序去执行的，因此有时候打印的错误信息并不是十分明确。如果在执行出错的时候对当前窗口截图保存，那么通过图片就可以非常直观地看到出错的原因<br><span class="hljs-comment">#截取当前窗口</span><br>driver.get_screenshot_as_file(<span class="hljs-string">"./demo.png"</span>)<br>                      <br>五. 数据存储<br>将数据写入CSV文件<br><span class="hljs-comment">#读写CSV文件</span><br><span class="hljs-keyword">import</span> csv<br><span class="hljs-comment">#以写入方式打开文件，如果文件不存在则自动创建</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">"d:/test.csv"</span>,<span class="hljs-string">'w'</span>)<br><span class="hljs-comment">#获取csvwriter，用于写入csv格式数据</span><br>writer = csv.writer(f)<br><span class="hljs-comment">#写入数据</span><br>writer.writerow([<span class="hljs-string">"张三"</span>,<span class="hljs-string">"男"</span>,<span class="hljs-string">"1.7"</span>])<br><span class="hljs-comment">#关闭文件</span><br>f.c1ose()<br> 将数据写到MySql<br>安装模块<br>pip install pymysql<br><span class="hljs-keyword">import</span> pymysq1<br><span class="hljs-comment">#创建连接</span><br>conn = pymysql.connect(host=<span class="hljs-string">'127.0.0.1'</span>,port=<span class="hljs-number">3306</span>,user=<span class="hljs-string">'root'</span>,passwd=<span class="hljs-string">''</span>,db=<span class="hljs-string">'tkq1'</span>,charset=<span class="hljs-string">'utf8'</span>)<br><span class="hljs-comment">#创建游标</span><br>cursor = conn.cursor()<br><span class="hljs-comment">#执行SQL，并返回收影响行数</span><br>effect_row = cursor.execute(<span class="hljs-string">"select * from tb7"</span>)<br><span class="hljs-comment">#执行SQL，并返回受影响行数</span><br><span class="hljs-comment">#effect_row = cursor.execute("update tb7 set pass= 123’where nid= %s",(11,))</span><br><span class="hljs-comment">#执行SQL，并返回受影响行数，执行多次</span><br><span class="hljs-comment">#effect_row=cursor.executemanyC"insert into tb7(user,pass,icnese）values（s,%s,%s）”</span><br>[（“ui<span class="hljs-string">"，“ulpass”11111)，（“u2”，u2pass”，*22222”)]）</span><br><span class="hljs-string">#提交，不然无法保存新建或者修改的数据</span><br><span class="hljs-string">conn.commit()</span><br><span class="hljs-string">#关闭游标</span><br><span class="hljs-string">cursor.close()</span><br><span class="hljs-string">#关闭连接</span><br><span class="hljs-string">conn.close()</span><br><span class="hljs-string"> </span><br><span class="hljs-string">六. 数据分析网站</span><br><span class="hljs-string">    https://www.heywhale.com/home</span><br><span class="hljs-string">    https://kaggle.com/</span><br><span class="hljs-string"> </span><br><span class="hljs-string">七.无头浏览器语法</span><br><span class="hljs-string">chrome_options = webdriver.ChromeOptions()</span><br><span class="hljs-string">chrome_options.add_argument('--headless')</span><br><span class="hljs-string">chrome_options.add_argument('--disable-gpu')</span><br><span class="hljs-string">chrome_options.add_argument('--no-sandbox')</span><br><span class="hljs-string">chrome_options.add_argument('--disable-infobars') #禁止显示浏览器正在受到自动测试软件控制的通知</span><br><span class="hljs-string">chrome_options.add_experimental_option("</span>excludeSwitches<span class="hljs-string">",["</span>enable-automation<span class="hljs-string">"]) #排除启用自动化扩展程序的开关，可以防止被网站检测到使用了自动化工具，减少被反爬虫封锁的可能性</span><br><span class="hljs-string">chrome_options.add_experimental_option("</span>userAutomationExtension<span class="hljs-string">",False) #禁用自动化扩展程序，同样是为了避免被网站检测到使用了自动化工具</span><br></code></pre></td></tr></tbody></table></figure><ul><li>对于浏览器窗口的切换和窗口中的iframe切换的方法：</li></ul><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 初始化 WebDriver，这里以 Chrome 为例</span><br>driver = webdriver.Chrome()<br><br><span class="hljs-comment"># 手动登录后假设打开了两个窗口</span><br><span class="hljs-comment"># 等待页面加载完成</span><br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 切换到第1个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第1个窗口"</span>)<br><br><span class="hljs-comment"># 在第1个窗口中执行一些操作</span><br><span class="hljs-comment"># ...（省略具体操作代码）</span><br><br><span class="hljs-comment"># 切换到第2个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第2个窗口"</span>)<br><br><span class="hljs-comment"># 在第2个窗口中找到第1个 iframe 并切换到它</span><br>driver.switch_to.frame(driver.find_element(By.XPATH, <span class="hljs-string">'第1个 iframe 的 XPATH'</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第1个 iframe"</span>)<br><br><span class="hljs-comment"># 在第1个 iframe 中找到第2个嵌套的 iframe 并切换到它</span><br>driver.switch_to.frame(driver.find_element(By.XPATH, <span class="hljs-string">'第2个嵌套 iframe 的 XPATH'</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到了第2个嵌套的 iframe"</span>)<br><br><span class="hljs-comment"># 在嵌套的 iframe 中执行一些操作</span><br>element = driver.find_element(By.XPATH, <span class="hljs-string">'嵌套 iframe 中元素的 XPATH'</span>)<br>element.click()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"点击了嵌套 iframe 中的元素"</span>)<br><br><span class="hljs-comment"># 完成操作后，如果需要切换回最外层的窗口，可以使用以下代码</span><br>driver.switch_to.default_content()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换回了最外层的窗口"</span>)<br><br><span class="hljs-comment"># 如果需要切换回上一级的 iframe，可以使用以下代码</span><br>driver.switch_to.parent_frame()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换回了上一级的 iframe"</span>)<br><br><span class="hljs-comment"># 关闭浏览器</span><br>driver.quit()<br>---------------------<br><span class="hljs-comment"># 窗口切换</span><br><span class="hljs-comment"># 切换到第一个窗口</span><br>driver.switch_to.window(driver.window_handles[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到第一个窗口"</span>)<br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 假设在此处进行一些操作...</span><br><br><span class="hljs-comment"># 切换到第二个窗口</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(driver.window_handles) &gt; <span class="hljs-number">1</span>:<br>    driver.switch_to.window(driver.window_handles[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"切换到第二个窗口"</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"没有第二个窗口可以切换"</span>)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="Qt图形界面开发"><a href="#Qt图形界面开发" class="headerlink" title="Qt图形界面开发"></a>Qt图形界面开发</h2><ul><li><p>PyQt GUI 主要类的层次结构：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># QObject &lt;= QWidget （组件）</span><br><span class="hljs-comment">## QWidget &lt;= QFrame &lt;= QLabel</span><br><span class="hljs-comment">## QWidget &lt;= QDialog</span><br><span class="hljs-comment">## QWidget &lt;= QAbstracButtom (抽象的按钮)</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QPushButtom</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QCheckBox</span><br><span class="hljs-comment">### QAbstracButtom &lt;= QRadioButtom</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>一个简单的GUI图开界面：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br>app=QApplication(sys.argv) <span class="hljs-comment">#创建应用程序对象，在创建应用程序时需要一个列表对象，sys.argv可用于获取从命令行输入的参数列表</span><br>window=QWidget() <span class="hljs-comment">#窗口对象可以是QWidget、QFrame、QDialog类型。对一般小窗口使用QWidget类型即可</span><br>window.show() <span class="hljs-comment">#窗口默认是隐藏的，需要调用show函数才能展示</span><br>app.<span class="hljs-built_in">exec</span>() <span class="hljs-comment">#让应用程序进入主事件循环中</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>以面向对象方式实现PyQt GUI 程序：将图形窗口的定义封装成一个窗口类，实现统一调用的过程。可实现代码重用。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <span class="hljs-comment">#根据自己需要，也可以将QFrame和QDialog等窗口类作为父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment">#自定义一个窗口类构造函数</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>): <span class="hljs-comment">#该函数用于初始化窗口中的控件，会在构造函数中调用</span><br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<span class="hljs-comment">#模块中的主函数</span><br>    app = QApplication(sys.argv)<br>    win = MyWindow()<span class="hljs-comment">#实例化窗口对象</span><br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<span class="hljs-comment">#如果当前模块为主模块，则调用主函数启动窗口，加上这段代码是为在模块中方便自己调试代码，当这个模块不作为主模块而被其它模块调用时，以下代码块内容都不会运行</span><br>    main()<br></code></pre></td></tr></tbody></table></figure></li><li><p>处理事件：在Qt中对事件的处理机制采用的是信号和槽方式，用于对象之间的通信，是Qt库的核心机制。处理事件有三个要素</p><ul><li><p>事件：是用户界面上的控件进行的操作，如点击，键盘动作，又叫信号</p></li><li><p>事件源：事件发生的场所，指控件</p></li><li><p>事件处理程者：对控件动作进行响应处理的函数，一般是一个对象某个方法，又叫槽</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel,QPushButton <span class="hljs-comment">#基本控件位于PyQt6.QtWidgets模块</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <span class="hljs-comment">#根据自己需要，也可以将QFrame和QDialog等窗口类作为父类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)<span class="hljs-comment">#创建标签控件是成员变量，因为需要在其它函数中访问该控件。这里是在槽函数中访问该控件的</span><br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>        buttom=QPushButton(<span class="hljs-string">'OK'</span>,<span class="hljs-variable language_">self</span>)<br>        buttom.move(<span class="hljs-number">170</span>,<span class="hljs-number">160</span>)<br>        buttom.clicked.connect(<span class="hljs-variable language_">self</span>.click_success) <span class="hljs-comment">#chicked是一种信号，它是按钮的单击事件，click_success是槽，它是一个事件处理函数，注意在连接槽时，clicked和click_success后面都没有小括号。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">click_success</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#槽，它是一个事件处理函数</span><br>        sender = <span class="hljs-variable language_">self</span>.sender()<span class="hljs-comment">#sender()函数返回发送信号的对象(事件源)，这里就是按钮控件</span><br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Success!'</span>)<br>        <span class="hljs-built_in">print</span>(sender.text())<span class="hljs-comment">#打印按钮的文本</span><br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>鼠标事件：对于控件的事件，将控件信号与槽函数连接起来就可以了，但在处理鼠标或键盘事件时，我们只需要重写QWidget类的一些函数就可以了，因为鼠标和键盘的事件非常特殊，它是QWiget类自带的，本身就带有处理的函数。鼠标事件就是鼠标的信号，有以下三种，实现鼠标事件只需要重写该函数，如下：</p><ul><li><p>mousePressEvent(event) ，鼠标按下，处理鼠标按下时调用的函数，event参数表示鼠标事件对象，保存了鼠标事件的一些信息。</p></li><li><p>mouseReleaseEvent(event) ，鼠标松开（释放）</p></li><li><p>moueMoveEvent(event) ，鼠标移动</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>       <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mousePressEvent</span>(<span class="hljs-params">self, event</span>): <span class="hljs-comment">#重写鼠标按下函数，这也就是一个槽函数，响应鼠标按下的信号，鼠标的信号源就是这个窗口</span><br>        <span class="hljs-keyword">if</span> event.button() == Qt.MouseButton.LeftButton: <span class="hljs-comment">#鼠标事件对象event的button()函数返回用户按下的鼠标键</span><br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Left Button Clicked'</span>)<br><br>        <span class="hljs-keyword">elif</span> event.button()==Qt.MouseButton.RightButton:<br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Right Button Clicked'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'鼠标未知按下'</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mouseReleaseEvent</span>(<span class="hljs-params">self, event</span>): <span class="hljs-comment">#重写鼠标释放函数</span><br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Mouse Released'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>键盘事件：</p><ul><li><p>keyPressEvent(event)，在按下键盘时调用的函数，event参数表示键盘事件对象，保存了键盘事件的一些信息</p></li><li><p>keyReleaseEvent(event)，在释放键盘时调用的函数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QLabel<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        <span class="hljs-variable language_">self</span>.label = QLabel(<span class="hljs-string">'Hello PyQt6!'</span>, <span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.label.move(<span class="hljs-number">180</span>, <span class="hljs-number">120</span>)<br>       <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, event</span>): <br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Key Pressed'</span>)<br>        <span class="hljs-built_in">print</span>(event.key())  <span class="hljs-comment">#键盘事件对象的key方法能获取按下的键盘的ascII值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyReleaseEvent</span>(<span class="hljs-params">self, event</span>): <br>        <span class="hljs-variable language_">self</span>.label.setText(<span class="hljs-string">'Key Released'</span>)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>布局管理器：</p><ul><li><p>盒子布局管理器：QBoxLayout类，又分为二个子类QVBoxLayout，垂直布局；QHBoxLayout，水平布局</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication,QWidget,QHBoxLayout,QPushButton<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QWidget</span>):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.initUI()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.setGeometry(<span class="hljs-number">600</span>, <span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        <span class="hljs-variable language_">self</span>.setWindowTitle(<span class="hljs-string">'My Window'</span>)<br>        hboxLayout=QHBoxLayout(<span class="hljs-variable language_">self</span>)<br>        button1=QPushButton(<span class="hljs-string">'Button 1'</span>,<span class="hljs-variable language_">self</span>)<br>        button2=QPushButton(<span class="hljs-string">'Button 2'</span>,<span class="hljs-variable language_">self</span>)<br>        button3=QPushButton(<span class="hljs-string">'Button 3'</span>,<span class="hljs-variable language_">self</span>)<br>        hboxLayout.addWidget(button1)<br>        hboxLayout.addWidget(button2)<br>        hboxLayout.addWidget(button3)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    app = QApplication(sys.argv)<br>    win = MyWindow()<br>    win.show()<br>    app.<span class="hljs-built_in">exec</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure></li><li><p>网格布局管理器：QGridLayout类，由行列组成，我们可以将控件放在指定单元格中。</p></li><li><p>表单布局管理器：QFormLayout类，表单一般由两列（第1列是标签列，第2列是控件列）和若干行构成，在表单布局中添加控件是通过addRow函数实现。</p></li></ul></li><li><p>常用控件</p><ul><li>文本输入控件：单行输入控件，QLineEdit；多行输入控件,QTextEdit</li><li>单选按钮：QRadioButton类，单选按钮在同一组中是互斥的，通过QButtonGroup类可以进行分组，不同组间互不干扰。QButtonGroup类只是单选按钮容器，不属于控件类，不会有任何视觉展示，因此在进行布局管理时还需要使用相应的布局管理器。</li><li>复选框：QCheckBox类，实现多选功能，提供两种状态的开和关。</li><li>列表控件：QlistWidget，提供了一个选项列表供用户选择，给列表添加选项的函数有，addItem(str)，添加一个选项；addItems(list)，一次添加多个选项。</li><li>下拉列表控件：QComboBox类，当列表控件占用空间太大，你希望空间紧凑时，可以使用该控件。</li><li>表格控件：QTableWidget类，可以将一个列表的数据展现在表格控件中的一行中，当有大量数据需要展示和修改时，可使用该控件。</li></ul></li><li><p>界面设计工具：QTDesigner</p></li></ul><h2 id="常见的编码和加密"><a href="#常见的编码和加密" class="headerlink" title="常见的编码和加密"></a>常见的编码和加密</h2><ul><li><p>常见的编码有base64、unicode、urlencode编码，加密有MD5、SHA1、HMAC、DES、RSA等。</p><ul><li><p>base64：base64是一种基于64个可打印ASCLL字符对任意字节数据进行编码的算法，其在编码后具有一定意义的加密作用。在逆向过程中经常会碰到base64编码。在python中使用base64：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> base64<br><span class="hljs-built_in">print</span>(base64.b64encode(<span class="hljs-string">'msb'</span>.encode()))<br><span class="hljs-built_in">print</span>(base64.b64decode(<span class="hljs-string">'bXNi'</span>.encode()))<br></code></pre></td></tr></tbody></table></figure></li><li><p>unicode和urlencode：unicode是计算机中字符集、编码的一项业界标准，被称为统一码、万国码，表现形式一般以“\u” 或者 “&amp;#”开头。urlencode是URL编码，也称作百分号编码用于把URL中的符号进行转换。</p></li><li><p>MD5：MD5消息摘要算法（英文：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5加密算法是不可逆的，所以解密一般都是通过暴力穷举方法，以及网站的接口实现解密。python代码实现加密：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br>pwd = <span class="hljs-string">"123"</span><br><span class="hljs-comment"># 生成MD5对象</span><br>m = hashlib.md5()<br><span class="hljs-comment"># 对数据进行加密</span><br>m.update(pwd.encode(<span class="hljs-string">'utf-8'</span>))<br><span class="hljs-comment"># 获取密文</span><br>pwd = m.hexdigest()<br><span class="hljs-built_in">print</span>(pwd)<br></code></pre></td></tr></tbody></table></figure></li><li><p>SHA1：SHA1（Secure Hash Algorithm）安全哈希算法主要适用于数字签名标准里面定义的数字签名算法，SHA1比MD5的安全性更强。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。一般在没有高度混淆的Js代码中，SHA1加密的关键词就是sha1。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hashlib<br>sha1 = hashlib.sha1()<br>data1 = <span class="hljs-string">"msb"</span><br>data2 = <span class="hljs-string">"kkk"</span><br>sha1.update(data1.encode(<span class="hljs-string">"utf-8"</span>))<br>sha1_data1 = sha1.hexdigest()<br><span class="hljs-built_in">print</span>(sha1_data1)<br>sha1.update(data2.encode(<span class="hljs-string">"utf-8"</span>))<br>sha1_data2 = sha1.hexdigest()<br><span class="hljs-built_in">print</span>(sha1_data2)<br></code></pre></td></tr></tbody></table></figure></li><li><p>HMAC：HMAC全称：散列消息鉴别码。HMAC加密算法是一种安全的基于加密hash函数和共享密钥的消息认证协议。实现原理是用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> hmac<br><span class="hljs-keyword">import</span> hashlib<br>key = <span class="hljs-string">"key"</span>.encode()<br>text = <span class="hljs-string">"msb"</span>.encode()<br>m = hmac.new(key, text, hashlib.sha256)<br><span class="hljs-built_in">print</span>(m.digest())<br><span class="hljs-built_in">print</span>(m.hexdigest())<br><span class="hljs-comment">#new（key,msg=None,digestmod）方法创建哈希对象,key和digestmod参数必须指定，key和msg（需要加密的内容）均为bytes类型，digestmod指定加密算法，比如‘md5’,'sha1'等</span><br><span class="hljs-comment">#对象digest（）方法：返回bytes类型哈希值</span><br><span class="hljs-comment">#对象hexdigest（）方法：返回十六进制哈希值</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>DES：</p></li><li><p>DES全称：数据加密标准（Data Encryption Standard），属于对称加密算法。DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8位都用作奇偶校验），密钥可以是任意的56位数，而且可以任意时候改变。Js逆向时，DES加密的搜索关键词有DES、mode、padding等。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># pyDes需要安装</span><br><span class="hljs-keyword">from</span> pyDes <span class="hljs-keyword">import</span> des, CBC, PAD_PKCS5<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-comment"># 秘钥</span><br>KEY = <span class="hljs-string">'dsj2020q'</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_encrypt</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    DES 加密</span><br><span class="hljs-string">    :param s: 原始字符串</span><br><span class="hljs-string">    :return: 加密后字符串，16进制</span><br><span class="hljs-string">    """</span><br>    secret_key = KEY<br>    iv = secret_key<br>    k = des(secret_key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)<br>    en = k.encrypt(s, padmode=PAD_PKCS5)<br>    <span class="hljs-keyword">return</span> binascii.b2a_hex(en).decode()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_decrypt</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    DES 解密</span><br><span class="hljs-string">    :param s: 加密后的字符串，16进制</span><br><span class="hljs-string">    :return:  解密后的字符串</span><br><span class="hljs-string">    """</span><br>    secret_key = KEY<br>    iv = secret_key<br>    k = des(secret_key, CBC, iv, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)<br>    de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5)<br>    <span class="hljs-keyword">return</span> de.decode()<br><br>text = <span class="hljs-string">'msb'</span><br>secret_str = des_encrypt(text)<br><span class="hljs-built_in">print</span>(secret_str)<br><br>clear_str = des_decrypt(secret_str)<br><span class="hljs-built_in">print</span>(clear_str)<br></code></pre></td></tr></tbody></table></figure></li><li><p>AES：AES全程：高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。AES也是对称加密算法，如果能够获取到密钥，那么就能对密文解密。Js逆向时，AES加密的搜索关键词有AES、mode、padding等。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#需要安装pip install pycryptodome</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><span class="hljs-comment"># AES</span><br><span class="hljs-comment"># 需要补位，str不是16的倍数那就补足为16的倍数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_16</span>(<span class="hljs-params">value</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(value) % <span class="hljs-number">16</span> != <span class="hljs-number">0</span>:<br>        value += <span class="hljs-string">'\0'</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.encode(value)  <span class="hljs-comment"># 返回bytes</span><br><br><span class="hljs-comment"># 加密方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">key, text</span>):<br>    aes = AES.new(add_to_16(key), AES.MODE_ECB)  <span class="hljs-comment"># 初始化加密器</span><br>    encrypt_aes = aes.encrypt(add_to_16(text))  <span class="hljs-comment"># 先进行aes加密</span><br>    encrypted_text = <span class="hljs-built_in">str</span>(base64.encodebytes(encrypt_aes), encoding=<span class="hljs-string">'utf-8'</span>)<br>    <span class="hljs-keyword">return</span> encrypted_text<br><br><span class="hljs-comment"># 解密方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">key, text</span>):<br>    aes = AES.new(add_to_16(key), AES.MODE_ECB)  <span class="hljs-comment"># 初始化加密器</span><br>    base64_decrypted = base64.decodebytes(text.encode(encoding=<span class="hljs-string">'utf-8'</span>))<br>    decrypted_text = <span class="hljs-built_in">str</span>(aes.decrypt(base64_decrypted), encoding=<span class="hljs-string">'utf-8'</span>).replace(<span class="hljs-string">'\0'</span>, <span class="hljs-string">''</span>)  <span class="hljs-comment"># 执行解密密并转码返回str</span><br>    <span class="hljs-keyword">return</span> decrypted_text<br></code></pre></td></tr></tbody></table></figure></li><li><p>RSA：RSA全称：Rivest-Shamir-Adleman, RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用，它被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗目前为止已知的所有密码攻击。注意Js代码中的RSA常见标志setPublickey。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#需要安装：pip install pycryptodome </span><br><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> PKCS1_v1_5<br><span class="hljs-keyword">from</span> Crypto <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><span class="hljs-comment"># ------------------------生成密钥对------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_rsa_pair</span>(<span class="hljs-params">is_save=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    创建rsa公钥私钥对</span><br><span class="hljs-string">    :param is_save: default:False</span><br><span class="hljs-string">    :return: public_key, private_key</span><br><span class="hljs-string">    """</span><br>    f = RSA.generate(<span class="hljs-number">2048</span>)<br>    private_key = f.exportKey(<span class="hljs-string">"PEM"</span>)  <span class="hljs-comment"># 生成私钥</span><br>    public_key = f.publickey().exportKey()  <span class="hljs-comment"># 生成公钥</span><br>    <span class="hljs-keyword">if</span> is_save:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"crypto_private_key.pem"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(private_key)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"crypto_public_key.pem"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(public_key)<br>    <span class="hljs-keyword">return</span> public_key, private_key<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_public_key</span>(<span class="hljs-params">file_path=<span class="hljs-string">"crypto_public_key.pem"</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> x:<br>        b = x.read()<br>        <span class="hljs-keyword">return</span> b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_private_key</span>(<span class="hljs-params">file_path=<span class="hljs-string">"crypto_private_key.pem"</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> x:<br>        b = x.read()<br>        <span class="hljs-keyword">return</span> b<br><br><span class="hljs-comment"># ------------------------加密------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encryption</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, public_key: <span class="hljs-built_in">bytes</span></span>):<br>    <span class="hljs-comment"># 字符串指定编码（转为bytes）</span><br>    text = text.encode(<span class="hljs-string">"utf-8"</span>)<br>    <span class="hljs-comment"># 构建公钥对象</span><br>    cipher_public = PKCS1_v1_5.new(RSA.importKey(public_key))<br>    <span class="hljs-comment"># 加密（bytes）</span><br>    text_encrypted = cipher_public.encrypt(text)<br>    <span class="hljs-comment"># base64编码，并转为字符串</span><br>    text_encrypted_base64 = base64.b64encode(text_encrypted).decode()<br>    <span class="hljs-keyword">return</span> text_encrypted_base64<br><span class="hljs-comment"># ------------------------解密------------------------</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decryption</span>(<span class="hljs-params">text_encrypted_base64: <span class="hljs-built_in">str</span>, private_key: <span class="hljs-built_in">bytes</span></span>):<br>    <span class="hljs-comment"># 字符串指定编码（转为bytes）</span><br>    text_encrypted_base64 = text_encrypted_base64.encode(<span class="hljs-string">"utf-8"</span>)<br>    <span class="hljs-comment"># base64解码</span><br>    text_encrypted = base64.b64decode(text_encrypted_base64)<br>    <span class="hljs-comment"># 构建私钥对象</span><br>    cipher_private = PKCS1_v1_5.new(RSA.importKey(private_key))<br>    <span class="hljs-comment"># 解密（bytes）</span><br>    text_decrypted = cipher_private.decrypt(text_encrypted, Random.new().read)<br>    <span class="hljs-comment"># 解码为字符串</span><br>    text_decrypted = text_decrypted.decode()<br>    <span class="hljs-keyword">return</span> text_decrypted<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    <span class="hljs-comment"># 生成密钥对</span><br>    <span class="hljs-comment"># create_rsa_pair(is_save=True)</span><br>    <span class="hljs-comment"># public_key = read_public_key()</span><br>    <span class="hljs-comment"># private_key = read_private_key()</span><br>    public_key, private_key = create_rsa_pair(is_save=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># 加密</span><br>    text = <span class="hljs-string">"msb"</span><br>    text_encrypted_base64 = encryption(text, public_key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"密文："</span>, text_encrypted_base64)<br><br>    <span class="hljs-comment"># 解密</span><br>    text_decrypted = decryption(text_encrypted_base64, private_key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"明文："</span>, text_decrypted)<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AI学习</title>
    <link href="/2025/08/03/AI/"/>
    <url>/2025/08/03/AI/</url>
    
    <content type="html"><![CDATA[<h1 id="学习AI"><a href="#学习AI" class="headerlink" title="学习AI"></a>学习AI</h1><h2 id="Prompt-Agent-MCP-是什么"><a href="#Prompt-Agent-MCP-是什么" class="headerlink" title="Prompt, Agent, MCP 是什么"></a>Prompt, Agent, MCP 是什么</h2><ul><li>user prompt：用户提示词，一般就是我们提出的问题或者想说的话。当AI没有特定的人设时，就只会给出一个通用的回答。</li><li>system prompt：把人设信息单独拎出来，放到另外一个prompt内面就是系统提示词，它主要用来描述AI的角色、性格、背景信息、语气等等。总之只要不是用户直接说出来的内容，都可以放进system prompt内面。</li><li>每次用用户发送user prompt时，会将system prompt一起发送给AI，这样整个对话就显得更加自然了。在网页端的聊天机器人中，system prompt往往是系统预设的，用户不能随便更改。但是一般聊天机器人中，会提供一些允许用户在里面写下一些自己的偏好，这些偏好就会变成system prompt的一部分。</li><li>AI Agent：负责在模型、Agent工具和最终用户之间传话的程序叫做AI Agent。它代替用户直接和AI交互，完成特定复杂的工作流程任务。</li><li>Agent Tool：提供给AI调用的函数或者服务。</li><li>Function Calling：system prompt的描述是用自然语言随意写的，只需要AI能看得懂就行。但Function Calling则对这些描述进行了标准化，比如每个Tool都用一个Json对象来定义工具名、功能说明和所需要的参数，然后这些Json对象也从System Prompt中被剥离了出来，单独放到了一个字段里面。最后Function Calling也规定了AI使用工具时应该返回的格式，所以System Prompt中的格式定义就可以删掉了。这样一来，所有的工具描述都放在相同的地方，所有工具描述也都依照相同的格式；AI使用工具时的回复也都依照相同的格式。这样人们就能更加有针对性的训练AI模型，让它理解这种调用的场景。甚至如果AI生成了错误的回复，因为回复的格式是固定的，AI服务器端自己就可以检测到，并且进行重试，用户根本感觉不到。这样一来，不仅降低了用户端的开发难度，也节省了用户端重试带来的Token开销。正是有这样的好处，现在越来越多的AI Agent开始从System Prompt转身Function Calling。</li><li>Function Calling没有统一的标准，每家大厂的API定义都不一样，而且很多开源模型还不支持Function Calling，所以要实现一个跨模型通用的AI Agnet还很麻烦，所以System Prompt和Function Calling这两种方式现在在市面上是并在的。</li><li>MCP：由于很多Agent Tool的功能其实是通用的，比如一个网页浏览的工具，可能多个Agent都需要，这样就可以把Tool变成服务统一的托管，让所有的Agent都来调用，这就是MCP。MCP是一个通信协议，专门用来规范Agent和Tool服务之间是怎么交互的，运行Tool的服务叫做MCP Server，调用它的Agent叫做MCP Client，MCP规范了MCP Server如何和MCP Client通信，以及MCP Server要提供哪些接口，比如说用来查询MCP Server中有哪些Tool，Tool的功能、描述需要的参数、格式等等的接口。</li><li>除了普通的Tool这种函数调用的形式，MCP Server也可以直接提供数据，提供类似文件读写的服务叫做Resource，或者为Agent提供提示词的模板叫做Prompt。MCP Server既可以和Agent跑在同一台机器上，通过标准输入输出进行通信，也可以部署在网络上，通过HTTP进行通信。这里需要注意，虽然MCP是为了AI而制定出来的标准，但实际上MCP本身却和AI模型没有关系，它并关心Agent用的是哪个模型。MCP只负责帮Agent管理工具、资源和提示词。</li><li>AI Agent使用的整个流程：用户问AI Agent或者MCP Client问题，Agent会把问题包装在User Prompt中，然后Agent通过MCP协议，从MCP Server里面获取所有的Tool的信息，AI Agent会把这些Tool的信息或者转化成System Prompt或者转化成Function Calling的格式，然后和用户请求User Prompt一起打包发送给AI模型，AI模型发现有一个叫做web_browse的网页浏览工具，于是通过普通回复或者Funtion Calling格式产生一个调用这个Tool的请求，希望去网上搜索答案，Agent收到了这个请求之后，通过MCP协议去调用MCP Server里的web_browse工具，web_browse访问指定的网站之后，将内容返还给Agent，Agent再转发给AI模型，AI模型再根据网页内容和自己的头脑风暴生成最终答案，最后由Agent把结果展示给用户。</li><li>System Prompt、User Prompt、AI Agent、Agent Tool、Funtion Calling、MCP之间不是彼此取代的关系，而是像齿轮一样一起构成了AI自动化协作的完整体系。</li></ul><h2 id="MCP-Server推荐"><a href="#MCP-Server推荐" class="headerlink" title="MCP Server推荐"></a>MCP Server推荐</h2><ul><li><p>推荐一：文件系统filesystem</p><ul><li>Filesystem MCP 旨在为大型语言模型（LLM）和AI助手提供对本地文件系统的安全、受控访问。</li><li>主要功能：<ul><li>文件读写：允许读取和写入文件内容，支持创建新文件或覆盖现有文件。</li><li>目录管理：支持创建、列出和删除目录，以及移动文件或目录。</li><li>文件搜索：能够在指定路径中搜索匹配特定模式的文件或目录。</li><li>元数据获取：提供获取文件或目录的详细元数据，包括大小、创建时间、修改时间、访问时间、类型和权限等信息。</li></ul></li></ul></li><li><p>推荐二：数据库mysqldb-mcp-server</p><ul><li>一种模型上下文协议（MCP）实现，支持与Mysql数据库进行安全交互。此服务器组件可促进AI应用程序（主机/客户端）与Mysql数据库之间的通信，提供安全的MySql数据库操作，通过受控接口使数据库探索和分析更安全、更有条理。</li></ul></li><li><p>推荐三：高德地图amap-maps</p><ul><li>高德地图是一个支持任何MCP协议客户端的服务器，允许用户轻松利用高德地图MCP服务器进行各种基于位置的服务。</li><li>高德地图的主要特点：<ul><li>支持多种位置服务，包括地理编码、天气和距离测量。</li><li>提供步行、驾车、公交等多种交通方式的API。</li><li>允许根据关键字或位置详细搜索兴趣点（POI）</li></ul></li></ul></li><li><p>推荐四：网页数据的采集Firecrawl</p><ul><li>Firecrawl MCP 工具是一款基于模型上下文协议（MCP）的企业级网页数据采集服务器。能够为大型语言模型（LLM）提供强大的网页抓取能力。</li><li>主要功能：<ul><li>JavaScript 渲染：能够处理动态网页内容，突破传统抓取工具的局限，获取更全面的数据。</li><li>批量处理：支持并行处理和队列管理，提高数据抓取效率。</li><li>智能限速：根据网络状况和任务需求智能调整抓取速度，避免对目标网站造成过大压力。</li><li>多种输出格式：支持将抓取的内容转换为MakeDown、HTML等格式，满足不同场景的需求。</li><li>说明：去firecrawl官网注册后即可查看自己的api_key</li></ul></li></ul></li><li><p>推荐五：Github</p><ul><li>Github MCP 服务器是一个模型上下文协议（MCP）提供与Github API 无缝集成的服务器，从而实现面向开发人员的高级自动化工具和交互功能。</li><li>使用案例<ul><li>自动化Github工作流和流程。</li><li>从Github 存储仓库中提取和分析数据。</li><li>构建与Github 生态系统交互的AI驱动的工具和应用程序。</li><li>说明：去<a href="https://githut.com/settings/tokens">https://Githut.com/settings/tokens</a> 申请自己的token</li></ul></li></ul></li><li><p>推荐六：Git</p><ul><li>用于GIt 存储库交互和自动化的模型上下文协议服务器。</li><li>直接的Git 仓库操作，包括读取、搜索和分析本地仓库。</li></ul></li><li><p>推荐七：记忆图谱 memory</p><ul><li>基于知识图谱的长期记忆系统用于维护上下文</li><li>使用本地知识图谱的持久内存的基本实现。这使 Claude 可以在聊天中记住有关用户的信息。</li></ul></li><li><p>推荐八：控制台 desktop-commander</p><ul><li>在计算机上无缝执行终端命令和管理流程。使用强大的命令执行和文件作工具简化您的开发任务。</li></ul></li><li><p>推荐九：社交软件 Slack</p><ul><li>用于Slack API 的MCP服务器，使LLM能够与 Slack 工作区进行交互，用于频道管理和消息传递。</li><li>说明：去 <a href="https://app,slack.com/intl/zh-cn">https://app,slack.com/intl/zh-cn</a> 注册并获取自己的 team id</li></ul></li><li><p>其它推荐</p><ul><li><pre><code class="language-py"># 浏览器自动化{  "mcpServers": {    "playwright-mcp": {      "command": "cmd",      "args": [        "/c",        "npx",        "-y",        "@smithery/cli@latest",        "run",        "@microsoft/playwright-mcp",        "--key",        "c7cb8987-b1e0-40d2-b676-c0f2f9980185"      ]    }  }}<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  +</span> <br><br><span class="hljs-section">## A2A协议</span><br><br><span class="hljs-bullet">+</span> A2A协议：开启Agent间自然协作，在 AI Agent 的世界里，主要解决两大互联领域的挑战：<br><span class="hljs-bullet">  +</span> 第一，Agent 与工具 Tool（工具）的交互，Agent 需要调用外部 API 、访问数据库、执行代码等，主要是通过 MCP 协议来实现<br><span class="hljs-bullet">  +</span> 第二，Agent 与 Agent （其它智能体或用户）的交互，Agent 需要理解其他 Agent 的意图、协同完成任务、与用户进行自然的对话。主要通过 A2A 协议来实现。<br><span class="hljs-bullet">  +</span> 通过 Github 地址：https://github.com/google/a2a 查看。<br><br><span class="hljs-section">## MCP教程</span><br><br><span class="hljs-bullet">+</span> MCP 的通信机制<br><span class="hljs-bullet">  +</span> 根据 MCP 的规范，当前支持两种通信机制（传输方式）<br><span class="hljs-bullet">    +</span> stdio （标准输入输出）：主要用在本地服务器上，操作你本地的软件或者文件。比如 Bleender 这种就只能用 Stdio 因为它没有在线服务。这也是MCP默认通信方式。<br><span class="hljs-bullet">    +</span> SSE （Server-Sent-Events）：主要用在远程通信服务上，这个服务本身就有在线的API，比如你访问你的谷歌邮件，天气情况等。<br>  <br><span class="hljs-bullet">+</span> MCP 使用前的准备工作<br><span class="hljs-bullet">  +</span> Stdio 的本地环境安装有两种<br><span class="hljs-bullet">    +</span> 一种是python编写的服务，对应 uvx 指令，安装命令 pip install uv<br><span class="hljs-bullet">    +</span> 一种是TypeScript编写的服务，对应 npx 指令，安装 node.js 就可以了。<br>  <br><span class="hljs-bullet">+</span> MCP 服务器可以同时提供三种类型能力或其中一种<br><span class="hljs-bullet">  +</span> Resources：资源，类似于文件数据读取，可以是文件资源或是API 响应返回的内容。<br><span class="hljs-bullet">  +</span> Tools：工具，第三方服务、功能函数，通过此可控制LLM 可调用哪些函数。<br><span class="hljs-bullet">  +</span> Proｍpts：提示词，为用户预先定义好的完成特定任务的模板。<br>  <br><span class="hljs-bullet">+</span> MCP 的三个核心概念<br><span class="hljs-bullet">  +</span> MCP Server：<br><span class="hljs-bullet">    +</span> 基于各语言的MCP SDK开发的程序或服务<br><span class="hljs-bullet">    +</span> 基于某种神秘的机制将现存的程序或服务进行了转换，使其成为了MCP Server<br><span class="hljs-bullet">  +</span> MCP Tool：所属于MCP Server，一个MCP Server 可以有多个MCP Tool<br><span class="hljs-bullet">  +</span> MCP Client：当一段代码，一个Agent，一个客户端，基于MCP的规范去使用、去调用MCP Server里的MCP Tool 时，它就是MCP Client<br>  <br><span class="hljs-bullet">+</span> MCP 的好处<br><span class="hljs-bullet">  +</span> 简化开发：写一次，多次集成，无需为每个集成重写自定义代码<br><span class="hljs-bullet">  +</span> 灵活性：切换AI 模型或工具时无需复杂重新配置<br><span class="hljs-bullet">  +</span> 实时响应：MCP 连接保持活动状态，实现实时上下文更新和交互<br><span class="hljs-bullet">  +</span> 安全性和合规性：内置访问控制和标准化的安全实践<br><span class="hljs-bullet">  +</span> 可扩展性：随着您的AI 生态系统增长，轻松添加新功能，只需连接另一个MCP服务器<br>  <br><span class="hljs-bullet">+</span> MCP 的工作流程<br><span class="hljs-bullet">  1.</span> 用户通过MCP Client/Agent 输入问题，MCP/Agent 会将用户的问题和MCP Tool的定义和使用方法告诉（输入给）大模型<br><span class="hljs-bullet">  2.</span> 大模型收到上面给出的信息数据后，通过自身的思考、分析、处理，会返回（输出）给MCP Client/Agent应该调用哪个MCP Server内面的MCP Tool最合适<br><span class="hljs-bullet">  3.</span> MCP Client/Agent 会去调用大模型指定的MCP Tool<br><span class="hljs-bullet">  4.</span> MCP Server返回结果给MCP Client/Agent<br><span class="hljs-bullet">  5.</span> 再由MCP Client/Agent将用户的提问和返回结果传递给大模型<br><span class="hljs-bullet">  6.</span> 大模型结合用户的提问和MCP Server的返回结果，作进一步推理，并以一定的格式输出给MCP Client/Agent，最终用户就能得到返回的最终结果<br>  <br><span class="hljs-bullet">+</span> MCP 客户端代码结构<br><br><span class="hljs-bullet">  +</span> 导入所需要的库<br><span class="hljs-bullet">  +</span> 创建Client实例<br><span class="hljs-bullet">  +</span> 连接到MCP服务器<br><span class="hljs-bullet">  +</span> 发送查询<br><span class="hljs-bullet">  +</span> 处理响应<br><br><span class="hljs-bullet">+</span> 运行MCP客户端 <br><br>  <span class="hljs-code">```py</span><br><span class="hljs-code">  # 安装所需依赖：</span><br><span class="hljs-code">  uv pip install mcp-client # 也可以使用python的pip去安装</span><br><span class="hljs-code">  # 运行客户端：</span><br><span class="hljs-code">  uv run client.py  # 也可以使用python环境去运行</span><br></code></pre></td></tr></tbody></table></figure></code></pre></li></ul></li><li><p>MCP 客户端接入OpenAI、DeepSeek在线模型</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span>新增依赖，为了接入在线模型，需要安装额外的依赖<br>uv add mcp openai python-dotenv<br><span class="hljs-number">2.</span>创建一个.env 文件来存储API密钥<br>OPENAI_API_KEY=your_openai_api_key<br>BASE_URL=base_url<br>MODEL=gpt-4o<br><br></code></pre></td></tr></tbody></table></figure></li><li><p>MCP 的核心原理</p><ul><li>参考URL链接：<a href="https://blog.csdn.net/m0_63171455/article/details/147266077">全网最细，一文带你弄懂 MCP 的核心原理！_mcp host-CSDN博客</a></li></ul></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
