[{"title":"Hello World","url":"/2025/08/03/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Git学习","url":"/2025/08/03/git/","content":"git简述\n2005年，开源项目Linux创始人Linus为了将代码放到版本控制系统内面，花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\nGit是分布式的版本控制系统，分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n安装git\n在Linux上安装Git:如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt install git就可以直接完成Git的安装，非常简单。\n\n在Windows上使用Git，也有两种安装方法。第一种是直接从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功。第二种是先安装一个包管理器，推荐Scoop，然后在PowerShell中通过以下命令安装Git：C:&gt; scoop install git,安装完成后，在PowerShell下运行命令git -v显示Git版本.使用包管理器安装Git只需一条命令，且升级非常方便。\nDebian/Ubuntu Linux的APT、macOS的Homebrew、Windows的Scoop在命令行下的安装、升级、卸载命令都是类似的，例如，升级Git，三种包管理器对应的命令分别是：sudo apt update gitbrew update gitscoop update git可以说熟悉一种包管理器的用法后，在其他平台也可迅速上手，推荐使用。\n\n配置Git:安装好Git后，还需要最后一步设置，在命令行输入：\n$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\"#注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n\n创建版本库\n版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单：\n第一步：选择一个合适的地方，创建一个空目录：$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit第二步：通过git init命令把这个目录变成Git可以管理的仓库：$ git initInitialized empty Git repository in /Users/michael/learngit/.git/瞬间Git就把仓库建好了，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。在 Git 中，“删除仓库” 通常有两种场景：删除本地仓库和删除远程仓库。两者的操作方式完全不同，具体如下：一、删除本地仓库（保留远程仓库）如果你只是想删除本地计算机上的 Git 仓库，但保留 GitHub/Gitee 等远程服务器上的仓库，有两种方法：方法 1：直接删除仓库文件夹这是最简单的方法，直接删除包含 .git 隐藏文件夹的项目目录。方法 2：清除 Git 版本控制（保留文件但不再是 Git 仓库）如果你想保留项目文件，但不再使用 Git 进行版本控制，可以删除项目中的 .git 目录二、删除远程仓库（彻底删除）如果你想删除 GitHub/Gitee 等平台上的远程仓库（此操作不可逆，会永久丢失数据），需通过平台的网页界面操作注意事项删除远程仓库是不可逆操作，所有代码和提交历史将永久丢失，建议提前备份。删除本地仓库后，若想重新获取代码，可通过 git clone 从远程仓库拉取。删除远程仓库前，确保团队成员已同步最新代码，避免数据丢失。根据你的实际需求选择合适的删除方式即可。\n\n把文件添加到版本库：\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n现在我们编写一个readme.txt文件，一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。再把这个文件放到Git仓库只需要两步。第一步，用命令git add告诉Git，把文件添加到仓库：$ git add readme.txt第二步，用命令git commit告诉Git，把文件提交到仓库：$ git commit -m \"wrote a readme file\"[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件小结现在总结一下今天学的两点内容：初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步：使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；使用命令git commit -m &lt;message&gt;，完成。\n\n时光机穿梭版本回退\n要随时掌握工作区的状态，使用git status命令。\n\n如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n在Git中，我们用git log命令查看历史记录，显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上  –pretty=oneline  参数。\n$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file你看到的一大串类似1094adb...的是commit id（版本号）是一个SHA1计算出来的一个非常大的数字，用十六进制表示回退到上一个版本,首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：$ git reset --hard HEAD^HEAD is now at e475afc add distributed--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。让我们用git log再看看现在版本库的状态：$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:03:36 2018 +0800    add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 20:59:18 2018 +0800    wrote a readme file最新的那个版本append GPL已经看不到了，好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，怎么办？办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：$ git reset --hard 1094aHEAD is now at 83b0afe append GPL版本号没必要写全，前几位就可以了，Git会自动去找。Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL如果关掉了窗口或电脑的话，用以下命令显示用来记录你的每一次命令，从而找到你的commit id$ git refloge475afc HEAD@{1}: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPLe475afc HEAD@{3}: commit: add distributedeaadf4e HEAD@{4}: commit (initial): wrote a readme file小结现在总结一下：HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。\n\n工作区和暂存区\n工作区（Working Directory），就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。\n版本库（Repository），工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。\n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。\n小结：暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。\n\n管理修改\nGit比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。\n我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit，现在，把第二次修改提交了\n小结：现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。\n\n撤销修改\n命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\ngit checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n\nGit同样告诉我们，用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区，git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。\n\n小结\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\n\n\n删除文件\n在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了，现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit；另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout – test.txt，git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n从来没有被添加到版本库就被删除的文件，是无法恢复的！\n小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n远程仓库\n有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n\n你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n第1步：创建SSH Key.在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：$ ssh-keygen -t rsa -C \"youremail@example.com\"如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容,点“Add Key”，你就应该看到已经添加的Key为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。\n\n\n添加远程库\n首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。\n\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n在本地的learngit仓库下运行命令：$ git remote add origin git@github.com:cffljx@126.com/learngit.git说明：cffljx@126.com是你自己的GitHub账户名；origin是远程库的名字，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上：$ git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样从现在起，只要本地作了提交，就可以通过命令：$ git push origin master把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n删除远程库：如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm 命令。使用前，建议先用git remote -v查看远程库信息：\n$ git remote -vorigin  git@github.com:michaelliao/learn-git.git (fetch)origin  git@github.com:michaelliao/learn-git.git (push)然后，根据名字删除，比如删除origin：$ git remote rm origin此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n\n小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；\n关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；\n关联后，使用命令git push -u origin master第一次推送master分支的所有内容；\n此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n\n从远程库克隆\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。用命令git clone克隆一个本地库：\n$ git clone git@github.com:michaelliao/gitskills.gitCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done.注意把Git库的地址换成你自己的,如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n\nGitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。\nGit支持多种协议，包括https，但ssh协议速度最快。\n\n\n分支管理\n你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n创建与合并分支\n在版本回退里，我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点\n\t\t\t\tHEAD                    │                    ▼                 master                    │                    ▼┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │└───┘    └───┘    └───┘\n\n\n\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上\n\t\t\t\tmaster                    │                    ▼┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │└───┘    └───┘    └───┘                    ▲                    │                   dev                    ▲                    │                  HEAD\n\n你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n                master\n                    │\n                    ▼\n┌───┐    ┌───┐    ┌───┐    ┌───┐\n│   │───▶│   │───▶│   │───▶│   │\n└───┘    └───┘    └───┘    └───┘\n                             ▲\n                             │\n                            dev\n                             ▲\n                             │\n                           HEAD          \n\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n                           HEAD                             │                             ▼                          master                             │                             ▼┌───┐    ┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │───▶│   │└───┘    └───┘    └───┘    └───┘                             ▲                             │                            dev\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n                           HEAD                             │                             ▼                          master                             │                             ▼┌───┐    ┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │───▶│   │└───┘    └───┘    └───┘    └───┘\n\n下面开始实战。\n首先，我们创建dev分支，然后切换到dev分支：$ git checkout -b devSwitched to a new branch 'dev'git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：$ git branch dev$ git checkout devSwitched to branch 'dev'然后，用git branch命令查看当前分支：$ git branch* dev  mastergit branch命令会列出所有分支，当前分支前面会标一个*号。然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：Creating a new branch is quick.然后提交：$ git add readme.txt $ git commit -m \"branch test\"[dev b17d20e] branch test 1 file changed, 1 insertion(+)现在，dev分支的工作完成，我们就可以切换回master分支：$ git checkout masterSwitched to branch 'master'切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：                  HEAD                    │                    ▼                 master                    │                    ▼┌───┐    ┌───┐    ┌───┐    ┌───┐│   │───▶│   │───▶│   │───▶│   │└───┘    └───┘    └───┘    └───┘                             ▲                             │                            dev现在，我们把dev分支的工作成果合并到master分支上：$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。合并完成后，就可以放心地删除dev分支了：$ git branch -d devDeleted branch dev (was b17d20e).删除后，查看branch，就只剩下master分支了：$ git branch* master因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\nswitch:我们注意到切换分支使用git checkout ，而前面讲过的撤销修改则是git checkout – ，同一个命令，有两种作用，确实有点令人迷惑。实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：\n创建并切换到新的`dev`分支，可以使用：$ git switch -c dev直接切换到已有的master分支，可以使用：$ git switch master使用新的git switch命令，比git checkout要更容易理解。\n\n小结Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch \n切换分支：git checkout 或者git switch \n创建+切换分支：git checkout -b 或者git switch -c \n合并某分支到当前分支：git merge \n删除分支：git branch -d \n\n\n解决冲突\n小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n用git log –graph命令可以看到分支合并图。\n\n\n分支管理策略\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n\n小结Git分支十分强大，在团队开发中应该充分应用。\n合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n\nBug分支\n在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\nGit还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作\n\n现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支\n\n现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支\n\n现在，是时候接着回到dev分支干活了\n\n小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n\nFeature分支\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n小结开发一个新功能，最好新建一个分支；\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。\n\n\n多人协作\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n要查看远程库的详细信息，用git remote -v：$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n$ git push origin master如果要推送其他分支，比如dev，就改成：$ git push origin dev但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n抓取分支：多人协作时，大家都会往master和dev分支上推送各自的修改。从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，推送就会失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。\n\n因此，多人协作的工作模式通常是这样：\n首先，可以尝试用git push origin 推送自己的修改；如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to  origin/。\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n小结查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n\nRebase\nGit有一种称为rebase的操作，有人把它翻译成“变基”。把分叉的提交变成直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n小结rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n标签管理标签也是版本库的一个快照，其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n\n创建标签：\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：$ git branch* dev  master$ git checkout masterSwitched to branch 'master'然后，敲命令git tag &lt;name&gt;就可以打一个新标签：$ git tag v1.0可以用命令git tag查看所有标签：$ git tagv1.0默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。小结命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；命令git tag -a &lt;tagname&gt; -m \"blablabla...\"可以指定标签信息；命令git tag可以查看所有标签。\n\n操作标签\n小结命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\n\n使用GitHub我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。\n在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。\n如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：git clone git@github.com:path/bootstrap.git\n\n一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。\nBootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：┌─ GitHub ────────────────────────────────────┐│                                             ││ ┌─────────────────┐     ┌─────────────────┐ ││ │ twbs/bootstrap  │────▶│  my/bootstrap   │ ││ └─────────────────┘     └─────────────────┘ ││                                  ▲          │└──────────────────────────────────┼──────────┘                                   ▼                          ┌─────────────────┐                          │ local/bootstrap │                          └─────────────────┘如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。\n\n小结在GitHub上，可以任意Fork开源仓库；自己拥有Fork后的仓库的读写权限；可以推送pull request给官方仓库来贡献代码。\n使用Gitee如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）\n和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。Gitee的免费版本也提供私有库功能，只是有5人的成员上限。\n使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“设置”，然后在左侧菜单选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：点击“确定”即可完成并看到刚才添加的Key\n如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？\n首先，我们在Gitee上创建一个新的项目，选择右上角用户头像旁的加号，然后点击“新建仓库”：项目名称最好与本地库保持一致。然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联：$ git remote add origin git@gitee.com:path/learngit.git之后，就可以正常地用git push和git pull推送了！如果在使用命令git remote add时报错：git remote add origin git@gitee.com:liaoxuefeng/learngit.gitfatal: remote origin already exists.这说明本地库已经关联了一个名叫origin的远程库,我们可以删除已有的GitHub远程库：git remote rm origin再关联Gitee的远程库（注意路径中需要填写正确的用户名）：$ git remote add origin git@gitee.com:path/learngit.git现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。使用多个远程库时，即一个本地库既关联GitHub，又关联Gitee时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。$ git remote add github git@github.com:path/learngit.git远程库的名称叫github，不叫origin了。$ git remote add gitee git@gitee.com:liaoxuefeng/learngit.git远程库的名称叫gitee，不叫origin。如果要推送到GitHub，使用命令：git push github master如果要推送到Gitee，使用命令：git push gitee master这样一来，我们的本地库就可以同时与多个远程库互相同步：┌─────────┐ ┌─────────┐│ GitHub  │ │  Gitee  │└─────────┘ └─────────┘     ▲           ▲     │           │     └─────┬─────┘           │    ┌─────────────┐    │ Local Repo  │    └─────────────┘\n\nGitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。\n自定义Git在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。\n\n忽略特殊文件：有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等。这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n.gitignore文件本身应该提交给Git管理，这样可以确保所有人在同一项目下都使用相同的.gitignore文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：GitHub/gitignore忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。.gitignore文件放哪？答案是放Git仓库根目录下，但其实一个Git仓库也可以有多个.gitignore文件，.gitignore文件放在哪个目录下，就对哪个目录（包括子目录）起作用。myproject          &lt;- Git仓库根目录├── .gitigore      &lt;- 针对整个仓库生效的.gitignore├── LICENSE├── README.md├── docs│   └── .gitigore  &lt;- 仅针对docs目录生效的.gitignore└── source小结忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！\n\n配置别名：我们只需要敲一行命令，告诉Git，以后st就表示status：\n$ git config --global alias.st status--global 参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。\n\n在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：\n$ git config --global alias.unstage 'reset HEAD'当你敲入命令：$ git unstage test.py实际上Git执行的是：$ git reset HEAD test.py\n\n配置文件:配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中：\n$ cat .git/config [core]    repositoryformatversion = 0    filemode = true    bare = false    logallrefupdates = true    ignorecase = true    precomposeunicode = true[remote \"origin\"]    url = git@github.com:michaelliao/learngit.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"]    remote = origin    merge = refs/heads/master[alias]    last = log -1别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。\n\n而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：\n$ cat .gitconfig[alias]    co = checkout    ci = commit    br = branch    st = status[user]    name = Your Name    email = your@email.com\n\n配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置，或者直接删掉配置文件错误的那一行。\n小结给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。\n\n搭建Git服务器：搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n第一步，安装git：$ sudo apt install git第二步，创建一个git用户，用来运行git服务：$ sudo adduser git第三步，创建证书登录：收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。第四步，初始化Git仓库：先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：$ sudo git init --bare sample.gitGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：$ sudo chown -R git:git sample.git第五步，禁用shell登录：出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。第六步，克隆远程仓库：现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：$ git clone git@server:/srv/sample.gitCloning into 'sample'...warning: You appear to have cloned an empty repository.剩下的推送就简单了。\n\n小结搭建Git服务器非常简单，通常10分钟即可完成；要方便管理公钥，用Gitosis；要像SVN那样变态地控制权限，用Gitolite。\n\n\n使用SourceTreeGit有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。\n首先从官网下载SourceTree并安装，然后直接运行SourceTree。\n第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：也可以选择“New”-“Clone from URL”直接从远程克隆到本地。\n提交我们双击learngit这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了git add README.md命令：然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：实际上是执行了git commit -m “update README.md”命令。\n分支在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如master，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令git checkout master：要合并分支，同样选择待合并分支，例如dev，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令git merge dev：\n推送在SourceTree的工具栏上，分别有Pull和Push，分别对应命令git pull和git push，只需注意本地和远程分支的名称要对应起来，使用时十分简单。\n小结使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。\n总结\n在一个目录CMD窗口下，输入：git init 命令，将实现初始化所在的目录，该目录又称为工作区，下会有一个隐藏的.git目录，它就是 Git 本地仓库的核心，称为版本库。.git 目录下的 Index 文件，用来临时存储代码，称为暂存区或索引区。删除目录相当于删除了整个仓库，只删除.git目录相当于git就不能进行本地仓库的版本控制功能。\n\ngit status 查看一下状态，终端显示如下信息：\nOn branch master // 当前为 master 分支No commits yet // 本地仓库还没有任何提交nothing to commit (create/copy files and use \"git add\" to track) // 暂存区没有什么可提交的\n\n新建 index.txt 文件，然后 git status 查看一下状态，终端显示如下信息：\nOn branch master  // 当前为 master 分支No commits yet // 本地仓库还没有任何提交Untracked files: // 工作区中还没有被跟踪的文件，也就是还没有被 add 的文件，add 之后将会进入暂存区  (use \"git add &lt;file&gt;...\" to include in what will be committed)        index.txtnothing added to commit but untracked files present (use \"git add\" to track) // 暂存区没有任何提交，但是工作区存在没有被跟踪的文件\n\ngit add index.txt 将 index.txt add 到暂存区，然后 git status 查看一下状态，终端显示如下信息：\nOn branch master  // 当前为 master 分支No commits yet // 本地仓库还没有任何提交Changes to be committed: // 暂存区将要被提交的修改，也就是已经从工作区 add 到暂存区中的文件，commit 之后将进入本地仓库  (use \"git rm --cached &lt;file&gt;...\" to unstage)  // 使用 ”git rm --cached &lt;file&gt;“ 将从暂存区删除并取消跟踪文件，恢复到 add 之前的状态        new file:   index.txt\n\ngit commit -m ‘commt index.txt’ 将 index.txt 提交到本地仓库，然后 git status 查看一下状态，终端显示如下信息：\nOn branch master // 当前为 master 分支nothing to commit, working tree clean  // 暂存区没有什么可提交的，工作区的树也是干净的\n\n执行 git log 查看当前分支 commit 提交的历史记录， 终端显示如下信息：\ncommit 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) // 7d32b404e1c71fd4ed66a4e22d70b265bee9d307 哈希值为当次提交的 commit id 校验和Author: test &lt;test@&gt;Date:   Thu Sep 30 16:22:22 2021 +0800    second commit:index.txtcommit bbeac607be274343dc74099887b9cee40e50d3a3Author: test &lt;test@&gt;Date:   Thu Sep 30 11:13:15 2021 +0800BAN    first commit:index.txt// 或者使用 git log --pretty=oneline，来让每一条日志只显示一行，更加简洁7d32b404e1c71fd4ed66a4e22d70b265bee9d307 (HEAD -&gt; master) second commit:idex.txtbbeac607be274343dc74099887b9cee40e50d3a3 first commit:index.txt// 或者使用 git log --oneline，不仅可以让每一条日志只显示一行，而且缩短了哈希值，更加简洁7d32b40 (HEAD -&gt; master) second commit:idex.txtbbeac60 first commit:index.txt// 或者使用 git reflog7d32b40 (HEAD -&gt; master) HEAD@{0}: commit: second commit:idex.txtbbeac60 HEAD@{1}: commit (initial): first commit:index.txt  //  HEAD@{1} 表示移动到当前版本需要1步\n\n添加远程仓库：git remote add gitee git@gitee.com:cffljx/ljx.git，gitee是远程仓库的名字。\n\n使用ssh与远程仓库通讯前，需要作如下配置：\n在C:\\Users\\Administrator\\.ssh目录下，生成密钥对：ssh-keygen -t ed25519 -C \"cffljx@126.com\" -f \"$HOME/.ssh/id_ed25519\"# 按提示设置密码（或直接回车跳过）在.ssh目录下，新建config和known_hosts文件config文件内容Host gitee.com    HostName gitee.com    User git    IdentityFile C:/Users/Administrator/.ssh/id_ed25519  # 使用 Windows 绝对路径    StrictHostKeyChecking no  # 临时禁用主机密钥检查（提高安全性建议设置为 ask）known_hosts文件内容：gitee.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5zTjR8iJbPZ+01ZJ146GQJ3v6xq3dC6pX0d5i+hVY=注意：ssh-后面的内容，换成你前面生成的公钥的内容。在远程仓库中将本地公钥填写进去验证连通性：D:\\vscode\\ljxgit&gt;ssh git@gitee.comHi cffljx(@cffljx)! You've successfully authenticated, but GITEE.COM does not provide shell access.Connection to gitee.com closed.首次连接远程服务器时，系统会提示确认并自动添加：输入 yes 后，公钥会自动写入 known_hosts将文件推向远程仓库前，需要与远程仓库先同步：D:\\vscode\\ljxgit&gt;git pull --rebase gitee masterremote: Enumerating objects: 18, done.remote: Counting objects: 100% (1/1), done.remote: Total 18 (delta 0), reused 0 (delta 0), pack-reused 17 (from 1)Unpacking objects: 100% (18/18), 5.49 KiB | 151.00 KiB/s, done.From gitee.com:cffljx/ljx * branch            master     -&gt; FETCH_HEAD * [new branch]      master     -&gt; gitee/masterSuccessfully rebased and updated refs/heads/master.然后就可以将提交到本地仓库的内容推送到远程仓库中去，实现代码版本托管功能：D:\\vscode\\ljxgit&gt;git push -u gitee masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 514 bytes | 514.00 KiB/s, done.Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)remote: Powered by GITEE.COM [1.1.5]remote: Set trace flag a1441aaaTo gitee.com:cffljx/ljx.git   edac3c2..006c899  master -&gt; masterbranch 'master' set up to track 'gitee/master'.\n\n当然，你也可以用HTTPS协议与远程仓库通讯，只是推送时会提示输入用户名和密码，比较烦锁：\n# 修改远程仓库 URLgit remote set-url gitee https://gitee.com/cffljx/ljx.git# 推送（会提示输入 Gitee 用户名和密码/令牌）git push gitee master\n\n"},{"title":"Python爬虫学习","url":"/2025/08/03/Python/","content":"Python爬虫知识\n学好爬虫需要的知识：\n\n计算机网络协议（http/https协议，tcp/ip协议，socket编程）\n前端基础\n正则表达式\n数据存储技术（分布式存储）\n并发处理技术（多线程，多进程，线程池，协程）\n图像识别（处理反爬、验证码），机器学习算法（验证法、数据解析）\n\n\n爬虫要解决的问题：\n\n爬虫的采集和更新策略\n解决反爬\n数据解析\n数据存储\n模拟登录（验证码识别）\n爬虫的监督和部署\n数据的去重（url去重，内容去重）\n\n\n\n变量与常量\n变量：可以发生改变的一个量，变量是用来区分不同数据的，可以指向一个内存空间，帮我们存储一些数据。\n\n变量命名规范：\n\n\n必须是数字或字母或下划线组成。\n不能以数字开头，更不能是纯数字。\n不能用python关键字。\n不要用中文\n要有意义\n推荐使用下划线或者驼峰命名。\n\n\n常量：可以把所有的变量的字母变成大写就可以认为是常量。\n\n不存在绝对意义的常量。\n\n\n简单认识数据类型\n数据类型：区分不同的数据，不同的数据类型应该有不同的操作。\n\n数字：+-*/\n整数，int\n\n​    小数，float\n\n文字：展示\n​    字符串：str（重点掌握）\n​    表示 方式：’ ‘，” “，’’’ ‘’’，””” “””\n​    操作：+ ：左右两端必须是字符串，表示字符串连接操作。\n​           * ：一个字符串只能乘以一个数字，表示字符串重复次数。    \n\n布尔：条件判断，主要有二个值：True 表示真 和 Flase 表示假\n​    布尔运算符中，非0的数值类型表示True，0表示Flase；其它类型中，非空值表示True，空值表示Flase\n\n\n条件判断\n1、if 条件:\n​        代码\n​    如果条件成立就执行代码，如果不成立，就不执行。\n2、if 条件\n​       代码1\n​      else\n​        代码2\n​    如果条件成立，执行代码1，不成立执行代码2\n3、if语句可以互相嵌套。\n​        if 条件\n​            if ….:\n​            else:\n​        else:\n​            代码2\n4、 if  条件1:\n​        代码1\n​    else: 条件2\n​        代码2\n​    else: 条件3\n​        代码3\n​    ……..\n​    else:\n​        代码XXXX\n\n\n循环语句\nwhile循环：\n​    while 条件:\n​        代码\n过程：判断条件是否为真，如果真，执行代码，然后再次判断条件，直到条件为假循环结束。\n\nbreak：让当前循环立即停止。\n\ncontinue：停止当前本次循环，继续执行下一次循环。\n\nfor循环：\n​    for 变量 in 可迭代的成员\n​        代码\n把可迭代的成员中的每一项内容拿出来，挨个的赋值给变量，每一次赋值都要执行一次循环体（代码）。\n循环想要计数，必须借助于range，range(n)：从0到n，不包含n。range(m,n)：从m到n，不包含n。range(m,n,s):从m到n，不包含n，每次间隔为s。\n\n平时用得多的是for循环，while循环用的多的是死循环。\n\n\npass\npass是代码占位标志。\n\n基础数据类型详解\n“””   int ，float，bool\n​    str（非常重要）\n​    list（非常重要)\n​    tuple (了解就行)\n​    set（了解就行)\n​    dict（非常重要)\n​    bytes（重要)\n​    运算符（重要)\n​    文件操作(比较重要)\n“””\n以上是大多数需要记忆内容，理解的东西不多。在python爬虫中会经常用到。 \n1。字符串的格式化：\n​    %s 字符串占位，也能用在数值占位。\n​    %d 数值占位。\n​    %f 占位小数。\n​    f”{变量}”，格式化一个字符串。\n2、索引和切片：\n​    索引：按照位置提取无素。可以采用索引的方式来提取某一个字符（文字）。\n​    切片：从一个字符串中提取一部分内容。语法：s[start:end]，从start到end进行切片，但是提到不到end。\n​    可以给切片添加步长来控制切片的方向：s[::-1] ，负责表示从右往左，正数表示从左往右。\n3、字符串的常规操作：\n​    字答串的操作不会对原字符串产生影响，一般是返回一个新字符串。\n​    s.upper()：把所有字母变成大写字母。用得比较多，常用于条件判断时对输入进行转换比较。\n​    s.lower()：把所有字母变成小写字母。\n​    s.strip()：去掉字符串左右两端的空白符（空格，\\t，\\n）。\n​    s.replace(old,new)：字符串替换。\n​    s.split(“_”)：可以用任字符串进行切割，切割之后的结果会放到列表当中。\n​    s.find(“str”)：查找和判断，返回如果是-1就是没有该字符串出现。\n​    s.index(“str”)：如果报错就是没有字符串出现。\n​    以上二种查找和判断一般不常用，常用的的方法是：”str”  in s  这里in是成员运算符，返回bool值。\n​    s.startswitch(“str”)：判断字符串是不是以str开头。返回bool值。\n​    s.endswitch(“str”)：判断字符串是不是以str结尾。返回bool值。\n​    s.isdigit()：判断s字符串是不是0和正整数，返回bool值。\n​    len(s)：输出s字符串长度。\n​    s=””.join(list)：将列表list，用双引号中间的字符连接成一个字符串。双引号中间可以是空字符。\n4、字符串的循环和遍历：\n​    for c  in s:\n​        print(c)        字符串中的每一个字符。\n5、关于in用在:\n​    1.判断XXX是否在XXXX中了现。\n​    2.for循环中用到。\n\n列表\n定义：列表是能装东西的东西，在python中用[]来表示一个列表，列表中的元素通过”,”隔开。\n特性：1、也像字符串一样有索引和切片。2、索引超过范围会报错。3、可用for循环进行遍历。4、用len()拿到列表的长度。\n列表的增删改查：\n​    lst.append(元素)    添加元素到列表末尾。\n​    lst.insrt(索引，元素)    将无素插入到索引处。\n​    lst.extend(列表)    可以合并两个列表，批量的添加。\n​    ret=lst.pop(索引)    将索引处的元素删除，并将删除的元素返回到ret变量。\n​    lst.remove(元素)    删除某个无素。\n​    lst[索引]=无素    直接用索引就可以进行修改操作。\n​    print(lst[索引])    直接用索引进行查询操作。\n列表排序：\n​    lst.sort()    对列表进行升序排序。\n​    lst.sort(reverse=True)    对列表进行降序排序。\n\n元组\n\n​    tuple，元组，特点：不可变的列表。用途：当固定某些数据，不允许外界修改时使用。\n   元组如果只有一个元素(*，)，需要在元素的末尾添加一个逗号。否则()默认是优先级的使用了。\n   关于元组的不可变，是指内存地址变。t=tuple(1,2,3,[‘a’,’b’,’c’])中，元素列表指定的址是不变，但列表内面的元    素是可以变化。\n\n集合set\n\n set集合是无序的。\n 表示方式：s={元素1，元素2，…}\n set集合要求存储的数据必须是可以进行哈希计算的，可哈希的数据类型是不可变的有,int,str,tuple,bool。而可变的数据类型有：list,dict,set，它们是不能存在于集合内，成为集合的元素的。\n 只能通过s=set()来创造空集合。而列表可通过l=[]或l=list()、元组通过t=()、字符串s=””或s=str()创建空的对象。\n 由于集合的无序特性，不能使用索引来定位元素，所以修改集合时只能通过先删除后添加来实现：s.remove(无素)，s.add(无素)，使用s.pop()时，()内面也不能写索引，只会删除最后一个元素，具有不确定性。查询集合元素只能通过for  in 循环来实现。\n 集合的一个重要作用是：去重性。常用于将列表重复元素去除，然后重新赋给列表。方法：s=list(set(lst))。但获得的列表与原列表的元素位置会改变。\n\n字典：字典是以键值对的形式进行存储数据的。\n\n 字典的表示方式：{key:value，key2:value，key3:value，…}，使用时只是把索引变成了key。\n 字典的key必须是可哈希的数据类型（不可变）。value可以是任何数据类型。\n 字典的增删改查：\n dic[key]=”元素”    增加一项key:value。\n 再次相同的dis[key]=”元素”    表示修改已存在的key键的value值。\n dic.setdefault(key:value)    在字典内面的增加一项默认值，如果key存在，后面的value就不起作用。\n dic.pop(key)    删除字典内健为key的一项键值。根据key删除。\n print(dic[key])    查询字典对应键的值，如果key不存在程序会报错。当确定key存在的情况用得多。\n print(dic.get(key))    功能同上，查询字典对应键的值，但如果key不存在会返回None值。当不确定key的时候用得多。\n None是一种类型为NoneType类型，单纯的就是空，表示没有意思，谁都不能用，可放到if语句做判断。而s=””表示空字符串，是能够被其它函数使用的。\n 可以用for循环直接拿到key\n for key in dic:\n ​    print(key,dic[key])\n 把所有key保存在一个列表中：\n dic.keys()    拿到所有的key了。\n list(dic.key())    列表显示字典内所有的key。\n list(dic.values())    列表显示字典内所有的value值。\n print(list(dic.items()))    直接拿到字典中的所有key和value。\n for key,value in dic.items():    字典的items函数直接能拿到key和value的值。\n​    print(key,value)        直接将字典每个键对值分别赋给二个变量：key,value。元组和列表也能执                        行该操作，该操作被称为解构（解包）。\n\nbytes\n字符集和编码：电脑通过一系列的0和1存储信息。这一系列的0和1通过编码就能表示对应的字符信息。\n首先是美国的ascii编码，共编排了128个文字符号，只需要7个0和1个就可以表示。同时前面加一个0正好是一个字节8位：01111111\n当电脑传到其它国家后，其它国家需要在asii码的基础上扩展本国的文字符号，于是美国制订了ANSI标准，每个字符采用16位，2个字节：00000000  01111111，前8位给不同国家自己编码使用，后面的01111111是ascii标准，不允许修改。\n到了中国，首先是对二万个常用字符进行了编码（ANSI是16位，2个字节，能表示65536个字符），标准是gb2312编码，后来又扩展成了GBK编码（中文windows默认就是使用这个）\n但如果采用ANSI标准编码，不同国家之间的文字要正确显示就必须切换成本国的编码。\n为了避免不同国家文字需要切换成本国的编码标准才能正确显示字符。国际标准统一组织就制订了unicode编码，将世界所有国家的文字都进行了编码，又称万国码。\n但unicode使用了4个字节，在存储和网络传输时会浪费大量资源。因此，只能是概念性编码，是一种标准，没法实际落地使用。于是在unicode基础上，另一种编码UTF编码产生，它是一种可变长的unicode编码，可以进行数据存储和传输。\nutf有二种标准：utf-8表示最短的字节长度为8，对应英文就是8bit，1个字节，对应欧洲文字就是16bit，2个字节，对应中文就是24bit，3个字节；utf-16表示最短的字节长度为16\n因此，gbk源自ansi标准，utf-8源自unicode标准，二者之间不能直接就进行转化。相当于二套密码本（编码），要通过一套密码本转换成文字，然后再将文字转换成另一种密码本来进行相互转化。\n程序员平时遇见的所有数据最终单位都是字节byte。bytes就是字节串的意思。\n将字符串变成字节就是进行编码str.encode(“编码”)，将字节转化成字符串就是进行解码tytes.decode(“编码”)\n# 怎样将一个bgk字节转化成uft-8的字节：\nbs=b’\\xc0\\xee\\xbc\\xcc\\xcf\\xfe’ #开头的b表示 bytes类型\n# 先用gbk解码成字符串。\ns=bs.decode(‘gbk’)\n# 再用utf-8重新编码成字节。\nbs=s.encode(‘utf-8’)\nprint(bs)\n注意：英语字母在所有编码内面都能正常显示，不存在单独编码，因此在字符串中和bytes中都会正常显示成英文。\n注意2：python内存中使用的是unicode编码，因为内存数据随时可以抹除，不需要象保存到硬盘中的文件而需要编码来节约资源。\n\n\n\n\n运算符\n算术运算符中，a//b表示取商，a%b表示取余数（得到商后剩下的数字）\n逻辑运算符运算顺序：先算（）&gt;not&gt;and&gt;or\n成员运算符：in  判断xxx是否在xxxx中出现了。not in 判断xxx是否不在xxxx中出现了。\n\n文件操作\n读取文件语法：f=open(文件路径,mode=”r”,encoding=”utf-8”)\t文件路径可以是相对路径或绝对路径；mode是对文件的操作模式，在这里r表示读取，这条命令执行完并不会把文件全部加载到内存，只是在你的程序与文件间建立了一条通道，后读还要使用f.read()或f.readline()等方式将文件内容加载到内存；encoding是指出文件是以什么方式进行编码的（使用的是哪种字符集），一般对文本文件建议加上，对于其它文件如图片，音频等，因为其内容与编码没关系，在这里可以省略这个参数。\n\nfor line in f:            从f中读取到每一行数据。\n\n​    print(line.strip())\n\n写入文件语法：f=open(文件路径,mode=”w”,encoding=”utf-8”)      w模式下，写入的文件不存在会自动创建该文件，如果存在该文件都会清空该文件内容。同理该行代码也只是程序与文件间建立了一条通道，后面还要使用f.write()命令来写入数据内容。\n\n追加写入文件语法：f=open(文件路径,mode=”a”,encoding=”utf-8”)    a模式下，不会清空该文件原来内容，后面使用f.write()时，会在该文件后面追加数据内容。\n\nf.close()    不管读或写，最后注意要使用该语句关闭文件链接（即关闭程序与文件间的通道）。\n\n使用with open(文件路径,mode=”w”,encoding=”utf-8”)  as f:    with表示上下文件管理，这时就不需要使用f.close()了，该语句会自动关闭文件。\n\n对于非文本文件读写语法：f=open(图片或音频等文件路径,mode=”rb”)    要在mode中加入b属性，后面也不能再使用encoding参数了。读取出来的是字节内容。\n\n从源文件中读取内容，写入到新的路径去：with open(图片或音频等文件路径,mode=”rb”) as f1,open(图片或音频等文件路径,mode=”wb”) as f2:\n​    for line in f1:\n​        f2.write(line)\n\n修改文件的方法：1、从源文件中读取内容。2、在内存中进行修改。3、把修改后的内容写入新文件中。4、删除源文件，将新文件重命名成源文件。\n\n\n函数编程_上\n函数：对某一特定功能或代码进行封装，在需要使用该功能的时候直接调用即可。\n\n定义：\ndef 函数的名字():    函数体\t\t#被封装的功能或者代码块\n\n调用方法：函数的名字()    #函数定义后如果不调用是不会执行。\n\n形参与实参：\ndef main(形参1,形参2，..)\t#在定义的时候使用，接收调用的时候传过来的参数，在函数体代码中使用。\t函数体main(实参1,实参2，...)\t#在调用的时候传入。def main(*参数)\t#*号表示接收位置参数的动态传参，参数的类型必须是元组。\t函数体def main(**参数)\t#**表示接收关键字参数的动态传参，参数类型必须是字典。\t函数体#参数存放顺序：位置&gt;*args&gt;默认值&gt;**kwargsmain(*参数)\t#在实参位置使用*号是把列表（或有序数据类型）打散成位置参数进行传递。 \n\n返回值\n如果函数体没有return，此时外界收到的返回值是None\n函数体执行到return时，会直接返回，如果return后面没有值也会返回None值\n如果return 值1，值2，值3，….，这时返回的是一个元组，元组内是该反回值\n\n内置函数（上）\n反射函数4个\n\n基础数据类型相关38个\n一、和数字相关14个\t1、数据类型4个\t\t1.bool\t\t2.int\t# a=0b10010,int(a)能将二进制转变成10进制。\t\t3.float\t\t4.complex：复数，实部+虚部\t2、进制转换3个\t\t1.bin:\t#输出结果似0b10010，以0b开头。\t\t2.oct\t# 0o22，以0o开头。\t\t3.hex\t# 0x12，以0x开头。\t3、数学运算7个\t\t1.obs\t\t2.divmod\t\t3.round\t\t4.pow\t# pow(a,b),次幂，计算a的b次方，与a**b等价。\t\t5.sum\t# sum(lst)，计算列表中所有元素的和。\t\t6.min\t# mix(lst)，计算列表中最小的值。\t\t7.max\t# max(lst)，计算列表中最大的值。二、和数据结构相关24个\t1、序列13个\t\t1.列表与元组2个\t\t\t1.list\t# s={1,2,3} list(s) 将传递进来的集合变成一个列表。\t\t\t2.tuple\t\t2.相关内置函数2个\t\t\t1.reversed\t# 翻转\t\t\t2.slice\t\t# 切片 s=slice(1,4,2)  lst[s] 与 lst[1,4,2]相同。\t\t3.字符串9个\t\t\t1.str\t\t# 字符串，通过encode()能编码成字节串（二进制字符串）\t\t\t2.format\t# 格式化 a=18 format(a,\"08b\") 将a格式化8位的二进制，前面不足的补0。\t\t\t3.bytes\t\t# bytes类型的字符串，又称字节串（二进制的字符串），是为了满足网络传输时的需要而定义的一种数据类型，通过decode()能解码成字符串，\t\t\t4.bytearry\t\t\t5.memoryview\t\t\t6.ord\t# 输出码位 a='中' ord(a) 将\"中\"字的unicode的码位输出来。\t\t\t7.chr\t# chr(20013) 给出码位位置，展示出文字。通过for i in range(65536)展示大量文字\t\t\t8.ascii\t将传入的对象以ascii字节形式做一个切割。\t\t\t9.repr\t\t2、数据集合3个\t\t1.字典1个\t\t\tdict\t\t2.集合2个\t\t\t1.set\t\t\t2.frozenset\t# 冻结的集合，不可变，与元组相同。\t3、相关内置函数8个\t\t1.len\t\t2.sorted\t排序\t\t3.enumerate\t通过for item in enumerate(list): 可以拿到索引和元素。\t\t4.all\t当成逻辑运算符and来看，all([1,\"\",\"abc\"]),相当于运算成：t and f and t\t\t5.any\t当成逻辑运算符or来看，any([1,\"\",\"abc\"]),相当于运算成：t or f or t\t\t6.zip\t可以把多个可迭代内容进行合并。\t\t7.fiter\t筛选\t\t8.map\t映射\n\n作用域相关2个\n1.locals 函数会以字典的类型返回当前位置的全部局部变量2.globals 函数以字典的类型返回全部全局变量。\n\n\n\n面向对象相关9个\n\n迭代器/生成器相关3 个\n1.range2.iter3.next\n\n\n\n其它12个\n一、字符串类型代码的执行3个\t1.eval\t执行字符串类型的代码，并返回最终结果\t2.exec\t执行字符串类型的代码\t3.complie\t将一个字符串编辑为字节代码二、输入输出2个\t1.input\t2.print三、内存相关2个\t1.hash\thash(s) 对不可变的类型进行计算出一个数字，转化成内存地址，进行数据存储为字典(集合)哈希表\t2.id\tid(s) 直接拿到s在内存中的存储地址四、文件操作相关1个\topen五、模块相关1个\t__import__六、帮助1个\thelp\thelp(类型) 查看类型的定义和使用方法等详细信息。七、调用相关1个\tcallable八、查看内置属性1个\tdir\tdir(对象) 查看当前对象（数据）能执行哪些操作。\n\n函数编程_下作用域\n变量的访问权限：函数外面，顶格左边定义的变量称为全局变量，称全局作用域，在所有定义的函数中都能使用。而在函数内部定义的变量称为局部变量，称作局部作用域，只能在函数内部使用，外部调用不了。如果想要在函数外面访问函数内面的东西，必须要用到return返回值来获取。\n顶格左边声明的函数也是全局的，是全局的一个函数，跟变量调用范围相同。\n\n函数的嵌套\n在定义函数的内面再定义一个函数就会形成函数嵌套。在内面定义的函数也是局部函数，在外面不能调用。\n局部的东西一般都是自己访问使用的。\n函数可以作为返回值进行返回，函数也可以作为参数进行相互传递。因此函数名实际上就是一个变量名，都表示一个内存地址。\n\n二个关键字\nglobal  把外面的全局变量引入到局部。\nnonlocal 在局部，引入外层的局部变量，如果有就引入，如果没有，继续向外一层查找引入，直到全局(不包括)\n\n闭包\n闭包本质是内层函数对外层函数的局部变量的使用，此时内层函数被称为闭包函数。用于协作写出高效程序代码\n1、可以让一个变量常驻与内存。2、可以避免全局变量被修改。def fun():\ta=10\tdef inner():\t\tnonlocal a\t\t# 注意，这里是引入和使用的是外层局部变量。没有在内部重新定义一个a局部变量\t\ta+=1\t\t\t#这里的局部变量a因为常驻与内存，不会被垃圾回收，值一直在。\t\treturn a\treturn innera=20ret=fun()r1=ret()print(r1)  r2=ret()print(r2)第一个输出结果是：11第二个输出结果是: 12\n\n装饰器\n装饰器本身是一个闭包，它的作用是在不改变原有函数的情况下，给函数增加新的功能。可以这样来理解：可以在函数前后添加新功能，但是不改变原来的代码。\n\n装饰器一般用在用户登录的地方、日志。\n#理解装饰器之前需要理解三点知识：1.函数可以作为参数进行传递；2.函数可以作为返回值进行返回；3.函数名称可以当成变量一样进行赋值操作。#装饰器的通用写法：def wrapper(fn):\t#wrapper：装饰器，fn:目标函数。    def inner(*args, **kwargs):        #在目标函数执行之前...        ret=fn(*args, **kwargs)        #在目标函数执行之后...        return ret    return inner\t#不要加()@wrapperdef target()\tpasstarget()\t# 这里调用的inner了。#一个函数可以被多个装饰器装饰。@wrapper1@wrapper2def target():    print(\"...\")#运行的规则与规律：wrapper1 wrapper2 target wrapper2 wrapper1---------------------------------------# 实例：def guanjia(game):    def inner(*args, **kwargs):\t\t# * **表示接收所有参数，打包成元组和字典。        print('开始游戏...')        game(*args, **kwargs)\t#这里的* **表示把元组和字典打散成位置参数以及关键字参数传递进去。        print('结束游戏...')    return inner@guanjia    #相当于pisa=guanjia(pisa)def pisa(user,password):    print('%s欢迎来到Pisa,你的密码是%s'%(user,password))    print('正在玩Pisa...')    return \"获得了返回信息...\"@guanjia    def xiaomi(user,password,title):    print('%s欢迎来到xiaomi,你的密码是%s,你选择的型号是%s'%(user,password,title))    print('正在玩小米...')ret=pisa('admin','123456')\t#此时运行的是guanjia的内层函数innerprint(ret)xiaomi('admin','123456','note8')运行结果：开始游戏...admin欢迎来到Pisa,你的密码是123456正在玩Pisa...结束游戏...获得了返回信息...开始游戏...admin欢迎来到xiaomi,你的密码是123456,你选择的型号是note8正在玩小米...结束游戏...\n\n迭代器\niterable 可迭代的东西，包括：str、list、tuple、dict、set、open()\n\niterator：迭代器。\n\n可迭代的数据类型都会提供一个叫迭代器的东西，这个迭代器可以帮我们把数据类型中的所有数据逐一拿到。\n\nfor内面一定是要拿迭代器的，所以所有不可以迭代的东西不能用for循环。\n\nfor循环内面一定有__next__出现。\n\n迭代器统一了不同数据类型的遍历工作。\n\n迭代器本身也是可迭代的。\n\n迭代器本身的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）\n#获取迭代器的两种方案\t1.inter() 内置函数可以直接拿到迭代器。    it=iter(\"abc\")\tprint(it)\t    运行结果：    &lt;str_ascii_iterator object at 0x00000212A7091BD0&gt;    2.__inter__() 特殊方法    it=\"abc\".__iter__()\tprint(it)    运行结果：    &lt;str_ascii_iterator object at 0x0000012B1CF41BD0&gt;#从迭代器中拿到数据\t1.next()    it=iter(\"abc\")\tprint(next(it))    print(next(it))    print(next(it))    运行结果：    a\tb\tc    2.__iter__() 特殊方法    it=\"abc\".__iter__()    print(it.__next__())    print(it.__next__())    print(it.__next__())    运行结果：    a\tb\tc# 迭代器本身也可以迭代：    s=\"abc\"    it=iter(s)    for i in it:        print(i)    运行结果：    a\tb\tc\t\n\n生成器\ngenerator  生成器，本质就是迭代器，也具有迭代器的特性：1.只能向前迭代不能反复。2.特别省内存。3.惰性机制（不访问就不会各前挪移）。\n# 创建生成器的两种方案1.生成器函数 语法：yield2.生成器表达式 语法：(数据 for循环 if判断)# 生成器函数有一个关键字：yield，生成器函数执行的时候，并不会执行函数，得到的是生成器。# yield：只要函数中出现了yield，它就是一个生成。作用：1.可以返回数据。2.可以分段的执行函数中的内容，通过__next__()可以执行到下一个yield位置，用得好这个功能，特别的节省内存。def fun():    print(\"Hello\")    yield 999print(fun())运行结果：&lt;generator object fun at 0x00000203EE0CCAC0&gt;#如果要执行函数，就用迭代器去调用，因为生成器本质就是迭代器。def fun():    print(\"Hello\")    yield 999print(fun().__next__())运行结果：Hello999# yield也有与return相似的返回功能，return是直接返回，后面语句不会执行，但yield后面的语句还可以继续运行。def fun():    print(\"Hello\")    yield 999fun().__next__()运行结果：hello\t# 因为没有变量接收yield 999的值，所以仅仅只是执行了fun函数的print语句。# 多个yield分段执行过程：def fun():    print(\"Hello\")    yield 999    print(\"World\")    yield 666ret=fun()print(ret.__next__())print(ret.__next__())运行结果：Hello999World666# 生成器表达式演示：t=(i**2 for i in range(10))print(t)输出结果：# 如果是元组推导式的话，t应该会输出元组数据，实际输出t是生成器对象，说明不存在元组推导式。&lt;generator object &lt;genexpr&gt; at 0x0000024D0E520380&gt;gen=(i**2 for i in range(3))for item in gen:\t\t#因为生成器本质上是一种迭代器，要获取gen的数据只能通过for循环迭代实现。    print(item)输出结果：014gen=(i**2 for i in range(3))lst=list(gen)\t\t# 将生成器转换成列表。print(lst)输出结果：[0, 1, 4]\t# 结果说明，list()肯定包含了for循环，而for循环肯定就调用了next()函数。# 生成器表达式也是一次性的，各前取完后就不存在数据了。gen=(i**2 for i in range(3))for item in gen:    print(item)lst=list(gen)print(lst)输出结果：014[]\t\t# 前面for循环已取完生成器数据，因为是向前一次性的取数，所以再使用列表去取数就会显示为空。\n\n推导式\n推导式简化代码。数据有规律时使用。分为三种推导式：列表推导式、字典推导式、集合推导式。\n\n对于复杂长代码不建议用推导式，用for循环实现代码可读性更强。\n# 语法：\t#列表推导式 [数据 for循环 if判断]  数据就是你想往列表内放的东西，并且这个东西还能通过if语句判断条件来进行处理，if判断是可选择项。    #集合推导式 {数据 for循环 if判断}    #字典推导式 {k:v  for循环 if判断}# (数据 for循环 if判断) 这不是元组推导式，元组不允许修改，所以根本没有元组推导式，这种叫生成器表达式。\n\n匿名函数\n匿名函数又称为： lambda表达式，语法：变量=lambda 参数1,参数2,…：返回值 。实现了一句话创建了一个函数\n# 一个正常的函数定义包涵：def 、函数名、(参数)如果有的话、冒号、函数体、返回结果，如下：def fun(参数):    print(\"Hello\")    return 666#调用方法：用一变量接收函数fun(),并将参数放在()中的返回值。同时函数fun中的函数体代码也已经开始运行完成。ret=fun(参数)  # 匿名函数定义省略了：def 函数名、冒号、函数体，只乘下参数、冒号和返回结果，并用lambda来标识，如下：fn=lambda 参数:返回值\t#最显著少了函数名和函数体。# 调用方法：用一变量接收匿名函数fn(),并在()中传递参数。ret=fn(参数)\n\n内置函数（下）\nsorted 排序\nlst1=['中','中华人民共和国','中国']  # 当lst不是数字时，按key=确定排序方法的函数来进行排序print(sorted(lst1,key=lambda x:len(x)))\t# 对于匿名函数只是在这里需调用的时候，直接写在这里更合理。运行结果：['中', '中国', '中华人民共和国']lst=[{'id':5,'name':'中'},{'id':7,'name':'中国'}]s=sorted(lst,key=lambda d:d['id'],reverse=True)\t# 在sorted中，这时的lst成为列表中的每项即字典了print(s)运行结果：[{'id': 7, 'name': '中国'}, {'id': 5, 'name': '中'}]\n\nfilter 筛选\nlst=['张三','李四','王五','张天矣','张明明']f=filter(lambda x:not x.startswith('张'),lst)\t# 对lst中每个元素进行判断，符合条件的放入f中。print(list(f))运行结果：['李四', '王五']\n\nmap 映射\nlst=[1,2,3,4,5,6,7,8,9,10]f=map(lambda x:x**2,lst)\t# 对lst每一项进行处理后放在f中，f是一个可迭代的map对象。print(tuple(f))\t# 对可迭代的map对象转换成元组。输出结果：(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\n递归函数\n递归：函数自己调用自己\n递归如果没有任何东西拦截的话，它默认就是一个死循环。\n默认递归深度最大限制为1000\n\n模块time和datetime\ntime 通过import time导入，该模块基本上被datetime模块取代，实际使用中就只用记住二个功能：sleep()、time()\n\ntime.sleep()功能：让程序停止一会儿。\n\ntime.time()：返回一串长的数字表示的是时间戳。也叫数字类型的时间。\n\ndatetime 掌握二个功能：通过from datetime import datetime和from datetime import date。\nfrom datetime import datetime\t#datetim:年月日时分秒；date:年月日;time:时分秒print(datetime.now())\t# 显示当前时间输出结果：2025-03-19 18:40:29.543848print(datetime(2025,3,19,18,42,31)) #格式化或创建一个时间输出结果：2025-03-19 18:42:31t1=datetime(2025,3,19,18,42,31)t2=datetime(2025,4,19,2,12,1)diff=t2-t1print(diff)\t# 显示两个时间的差，以天数，小时，分钟，秒显示。print(diff.total_seconds())\t# 显示两个时间差，以秒显示。输出结果：30 days, 7:29:30\t2618970.0# 格式化一个时间：t=datetime.now()print(t.strftime(\"%Y年%m月%d日 %H时:%M分钟:%S秒\"))\t# 以字符串形式格式化时间。输出结果：2025年03月19日 18时:55分钟:04秒# 把字符串转化成时间：s=input(\"请输入时间(格式:yyyy-mm-dd HH:MM:SS):\")\t# 由用户按格式输入时间t=datetime.strptime(s, '%Y-%m-%d %H:%M:%S')   # p:parse(转化的意思)from datetime import date # 用法与datetime相同，也能实现strftime()和strptime()等功能。print(date.today())\t#date只需要掌握这个功能。输出结果：2025-03-19\n\n随机数模块\nrandom 通过import random导入，随机产生一个0到1之间的小数。\nfrom random import random  # 这里导入的是radmom模块内的一个random函数，实现产生一个随机数功能。print(random())输出结果：0.5512596462326173import randomprint(random.randint(1,100)) #随机整数，能够取到边界值print(random.uniform(1,100)) #随机浮点数，1-100之间lst=[1,2,3,4,5,6,7,8,9,10]print(random.choice(lst)) # 从列表中随机选取一项。import random#随机生成4验证码，包含数字、大写字母、小写字母def rand_int():    return str(random.randint(0,9))def rand_upper():    return chr(random.randint(65,90))def rand_lower():    return chr(random.randint(97,122))def rand_verify_code(n=4):    lst=[]    for i in range(n):        switch = random.randint(1,3)        if switch == 1:            s=rand_int()        elif switch == 2:            s=rand_upper()        else:            s=rand_lower()        lst.append(s)    return ''.join(lst)print(rand_verify_code())\n\npickle对象转字节\n把python对象写入文件的一种解决方案，写入到文件的是字节bytes， 这种过程叫做序列化。\n\n网络传输时只认字节，这种转化就很好地解决了这个问题。\n\npython代码中的字典数据通过open()方式写入文件只能通过转换成字符串才能写入，但在反过来读取的文件的时候，数据就是字符串类型，不能还原原来的字典数据类型，这时候通过pickle转化就能解决上述问题。\n\n把数据存储到文件中最合理的方案就是pickle，而eval存在安全隐患。\nimport picklelst=['李继晓','陈菲菲','李奕妙']print(pickle.dumps(lst))输出结果：b'\\x80\\x04\\x95)\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(\\x8c\\t\\xe6\\x9d\\x8e\\xe7\\xbb\\xa7\\xe6\\x99\\x93\\x94\\x8c\\t\\xe9\\x99\\x88\\xe8\\x8f\\xb2\\xe8\\x8f\\xb2\\x94\\x8c\\t\\xe6\\x9d\\x8e\\xe5\\xa5\\x95\\xe5\\xa6\\x99\\x94e.'import pickleb=b'\\x80\\x04\\x95)\\x00\\x00\\x00\\x00\\x00\\x00\\x00]\\x94(\\x8c\\t\\xe6\\x9d\\x8e\\xe7\\xbb\\xa7\\xe6\\x99\\x93\\x94\\x8c\\t\\xe9\\x99\\x88\\xe8\\x8f\\xb2\\xe8\\x8f\\xb2\\x94\\x8c\\t\\xe6\\x9d\\x8e\\xe5\\xa5\\x95\\xe5\\xa6\\x99\\x94e.'print(pickle.loads(b))输出结果：['李继晓', '陈菲菲', '李奕妙']import pickledic={'name':'李继晓', 'age':50}b=pickle.dumps(dic)pickle.dump(dic,open(\"ljx.data\",mode=\"wb\"))\t#将字典转化成字节写入文件。import pickledic=pickle.load(open(\"ljx.data\",mode=\"rb\"))\t# 将文件读取并还原成字典。print(dic,type(dic))输出结果：{'name': '李继晓', 'age': 50} &lt;class 'dict'&gt;# 说明：\t# 序列化：把对象转化成二进制字节；反序列化：把二进制字节转化回对象。    # 1.dumps 把对象（数据）转化成字节。    # 2.loads 把字节转化回对象（数据）    # 3.dump 把对象序列化成字节之后写入文件。    # 4.load 把文件中的字节反序列化成对象。\n\njson\njson是前后端交互的枢纽，相当于编程界的普通话，json的语法格式能完美展示出一个对象，全称为js对象简谱。它是一种数据传输的数据格式。 \n\n目前，几乎大部app后端返回的数据都是json格式，它非常方便前端处理。\n\n通过import json来导入json包。\n# 浏览器前端和python程序之间只能以字符串进行传递，所以我们需要做的事是：# 1.把python中的数据类型，如字典、列表、字符串，转化成json字符串，这种转换又称为序列化。import jsondic={\"name\":'李继晓',\"age\":'25'}s=json.dumps(dic)\t# 在这里转化时，会默认调用到ascii函数，中文将转化成字节。print(s,type(s))运行结果：{\"name\": \"\\u674e\\u7ee7\\u6653\", \"age\": \"25\"} &lt;class 'str'&gt;dic={\"name\":'李继晓',\"age\":'25'}s=json.dumps(dic,ensure_ascii=False)\t# 这里禁止调用ascii函数转化，中文就会正常显示。print(s,type(s))运行结果：{\"name\": \"李继晓\", \"age\": \"25\"} &lt;class 'str'&gt;# 2.前端返回的json字符串，想办法变成python中的数据类型，如字典、列表、字符串，这种转换又称为反序列化，反序列化的目的是让转换后的数据类型便于pthon语言方便处理。import jsons='{\"name\":\"李继晓\",\"age\":\"25\",\"text\":null}'dic=json.loads(s)print(dic,type(dic),type(s))运行结果：{'name': '李继晓', 'age': '25','text':None} &lt;class 'dict'&gt; &lt;class 'str'&gt;# 写入文件和读取文件代码：import jsondis={\"name\":\"李继晓\",\"age\":\"25\",\"test\":None}f=json.dump(dis,open(\"ljx.txt\",mode=\"w\",encoding=\"utf-8\"),ensure_ascii=False)dic=json.load(open(\"ljx.txt\",mode=\"r\",encoding=\"utf-8\"))print(dic,type(dic))运行结果：{'name': '李继晓', 'age': '25', 'test': None} &lt;class 'dict'&gt;# 总结：\t# 前端的json和python中的字典数据类型写法有细微差别，但用法一样：    \t# python\t前端        # True\t\tture        # None\t\tnull\t# 1.dumps 可以把对象（数据）转化成json，注意后面要跟参数：ensure_ascii=False否则中文会出问题。    # 2.loads 可以把json转化回对象（数据）    # 3.dump 可以把对象（数据）以json格式写入文件，注意后面要跟参数：ensure_ascii=False    # 4.load 可以从文件中读取json格式的数据转化成对象（数据）    # 5.json来自前端。    # 6.json是一种数据交互的数据格式，它本身就是一种象字符串的格式。\n\nhashlib\nMD5是一种不可逆的加密算法，由于MD5存在很久了，一些简单排列组合来计算MD5的密文被保存后，当出现相同的MD5密文后就能反推原来的数据，这种现象叫撞库。应对方法就是在使用MD5时，给函数的参数传递一个byte来进行MD5加密计算形成密文，这种方法称为哈希加盐。\nimport hashlib# 创建md5对象md5 = hashlib.md5()# 把要加密的信息传递给md5对象md5.update('123456'.encode('utf-8'))\t#参数字符串编码成字节。# 获取加密后的结果  result = md5.hexdigest()print(result)运行结果：e10adc3949ba59abbe56e057f20f883e# 正常的默认加密过程容易撞库，解决方法就是加盐。md5=hashlib.md5(b'fdafdfadfdfdfa')\t# 这里参数是字节。md5.update(b'123456')\t#这里参数也是字节。print(md5.hexdigest())运行结果：f6f8eda769519bb05b203a15818cf736# 动态加盐def func(salt,s):    md5=hashlib.md5(salt.encode('utf-8'))    md5.update(s.encode('utf-8'))    return(md5.hexdigest())username=input('请输入用户名：')password=input('请输入密码：')mi_pasword=func(username,password)with open('user.txt','w') as f:    f.write(username+'\\n'+mi_pasword)------------------------------------------# 登录验证：def func(salt,s):    md5=hashlib.md5(salt.encode('utf-8'))    md5.update(s.encode('utf-8'))    return(md5.hexdigest())username=input('请输入用户名：')password=input('请输入密码：')password=func(username,password)\t# 需要将用户输入的用户名和密码进行加密后再去判断。with open('user.txt','r') as f:    if f.readline().strip() == username and f.readline().strip() == password:               print('登录成功！')    else:        print('登录失败！')# 对文件进行加密：import hashlibmd5=hashlib.md5(b'ab566daf')with open('user.txt','rb') as f:    for line in f:        md5.update(line)print(md5.hexdigest())运行结果：f87f39c6f3744ac2d185246d18561cc4\n\nshutil\n主要封装了文件和文件夹的相关操作，比如文件复制粘贴，文件移动，文件夹的复制，移动等。\nimport shutilshutil.move(\"test.mp4\",'video/') # 把当前目录下的test.mp4文件移动到video目录内。shutil.copy(\"test2.py\",\"video/test2.py\") # 复制文件+权限。shutil.copy2(\"test2.py\",\"video/test2.py\") # 复制文件+权限+时间。shutil.copytree(\"img/\",\"img_bak/\") # 复制文件夹，文件夹内的文件也一起会复制。shutil.rmtree(\"img_bak/\") # 删除文件夹。\n\nlogging\nlogging代码模块不用记，只需要知道怎样用就行了（日志等级）。\n\nimport logging# filename:文件名。# format:日志格式。最终在日志文件中显示的样子：时间-名称-级别-模块：错误信息。# level:日志级别，有debug、info、warning、error等。# datefmt:时间格式:%Y-%m-%d %H:%M:%S。logging.basicConfig(filename='test.log',                    format='%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s',                    datefmt='%Y-%m-%d %H:%M:%S',                    level=0) # 0表示最低级别，输出所有信息,当软件交付客户使用时，应调成40，只记录错误。llogging.log(5, 'This is a log message') # 0表示最低级别，输出所有信息，在这里可以自定义级别。logging.debug('This is a debug message') # 10表示最低级别，输出最少的信息。logging.info('This is an info message') # 20表示最低级别，输出最少的信息。logging.warning('This is a warning message') # 30表示最低级别，输出最少的信息。logging.error('This is an error message') # 40表示最低级别，输出最少的信息。logging.critical('This is a critical message') # 50表示最高级别，输出最重要的错误信息。输出结果：# 输出在当前目录下test.log文件中。2025-03-23 17:06:32 root Level 5 test4: This is a log message2025-03-23 17:06:32 root DEBUG test4: This is a debug message2025-03-23 17:06:32 root INFO test4: This is an info message2025-03-23 17:06:32 root WARNING test4: This is a warning message2025-03-23 17:06:32 root ERROR test4: This is an error message2025-03-23 17:06:32 root CRITICAL test4: This is a critical messageimport logging# 如何将日志到不同文件。# 创建一个操作日志的对象logger。file_handler = logging.FileHandler(\"./log/test.log\",\"a\",encoding=\"utf-8\") # f=open()file_handler.setFormatter(logging.Formatter(\"fmt=%(asctime)s - %(levelname)s - %(message)s\"))logger1=logging.Logger(\"test1\",level=40) # 创建日志对象，级别为40。logger1.addHandler(file_handler) # 给日志设置文件信息。logger1.error(\"test1 message\") # 记录错误信息。file_handler2 = logging.FileHandler(\"./log/test2.log\",\"a\",encoding=\"utf-8\") # f=open()file_handler2.setFormatter(logging.Formatter(\"fmt=%(asctime)s - %(levelname)s - %(message)s\"))logger2=logging.Logger(\"test2\",level=40) # 创建日志对象，级别为40。logger2.addHandler(file_handler2) # 给日志设置文件信息。logger2.error(\"test2 message\") # 记录错误信息。运行结果：# 在log目录下会创建test和test2文件，内容如下。2025-03-23 17:30:33,881 - ERROR - test1 message2025-03-23 17:30:33,881 - ERROR - test2 message# 在全用时选择以下二种方式之一会按要求来记录日志。llogging.log(5, 'This is a log message') # 自定义。logger2.error(\"test2 message\") # 系统默认之一。\n\n异常处理\n程序运行中出现错误，需要提供try…except来处理。\ntry:    1/0except:    print(\"程序出错了\")输出结果：程序出错了# 异常处理标准格式：try:    代码excep 错误1 as 变量1:excep 错误2 as 变量2:excep Exception as e:\t#当以上所有异常都不符合条件时，最终会执行这条异常处理语句。万能错误接收。    最终处理finally:\t#上面的异常都没有发生也会运行下面代码收尾。不论是否出错都要执行finally    print()# 程序也能主动抛出异常：def fun(a,b)\tif type(a)==int and type(b)==int:        return a+b    else    \traise Exception(\"非整数类型错误。\")  # 抛出异常，调用的该函数，谁接收该异常。# 实例：try:    def main(a,b):        if a&gt;b:            print(\"a is greater than b\")        else:            raise Exception(\"a is not greater than b\")    if __name__ == '__main__':        main(2,3)except Exception as e:    print(e)运行结果：a is not greater than b\t\n\ntraceback\n当通过try…except捕获异常后，虽然能处理异常，但错误信息在哪里发生的不知道，如果想知道报错的信息和位置，就需要调用trackback这个模块。\nimport tracebacktry:    print(1/0)except :    print(\"error\")    print(traceback.format_exc())print(\"end\")输出结果：Traceback (most recent call last):  File \"d:\\vscode\\python\\PisaApp\\test4.py\", line 3, in &lt;module&gt;    print(1/0)ZeroDivisionError: division by zeroend\t\t# 虽然程序报错了，但下面的代码依旧会继续运行。# 与logging结合使用：# 准备好记录日志的logginglogging.basicConfig(filename='test.log',                    format='%(asctime)s %(name)s %(levelname)s %(module)s: %(message)s',                    datefmt='%Y-%m-%d %H:%M:%S',                    level=0)#正常写程序try:    print(1/0)except :    print(\"error\")    logging.error(traceback.format_exc())运行结果：2025-03-23 19:03:26 root ERROR test4: Traceback (most recent call last):  File \"d:\\vscode\\python\\PisaApp\\test4.py\", line 9, in &lt;module&gt;    print(1/0)ZeroDivisionError: division by zero\n\nzipfile\nzipfile主要封装了和zip压缩包相关的功能。\nimport zipfilef=zipfile.ZipFile('log/test.zip','w') # 创建压缩包。f.write('test1.py')f.write('test2.py')f.close()#  在log目录下生成了一个text.zip文件。import zipfilef=zipfile.ZipFile(\"log/test.zip\",\"r\") # 打开压缩包f.extractall(\"log/\") # 解压到指定目录f.close() # 关闭压缩包# 在log目录下生成test1.py和test2.py文件。# 一个一个的解奉压缩：f=zipfile.ZipFile(\"log/test.zip\",\"r\") # 打开压缩包for name in f.namelist():    f.extract(name,\"log/see\") # 解压文件到指定目录f.close() # 关闭压缩包运行结果：# 将二个文件自动解压到了log目录下的see目录中，目录没有会自动创建。\n\nOS模块\n完成文件夹的处理和命令的执行，常用的几个功能：\n\nos.system() #运行shell命令，直接显示os.popen().read() #运行shell命令，获取执行结果os.getcwd()\t#获取当前工作目录，即当前python脚本工作目录的路径os.chdir()\t#改变当前脚本工作目录，相当于shell下的cd #\t与路径相关的os操作，都是os.path模块下的函数和方法os.path.exists()\t# 判断一个路径是否存在，路径可以是文件夹和文件os.path.isdir()\t\t# 判断文件夹是否存在，比上面命令更精细明确os.path.isfile()\t# 判断文件是否存在，比上面命令更精细明确os.path.abspath()\t# 返回一个文件的绝对路径os.path.split(r\"d:\\vscode\\python\\PisaApp\\test8.py\")\t# 将文件路径切割成文件夹和文件名运行结果：('d:\\\\vscode\\\\python\\\\PisaApp', 'test8.py')print(os.path.dirname(r\"d:\\vscode\\python\\PisaApp\\test8.py\")) # 只返回文件夹运行结果：d:\\vscode\\python\\PisaAppprint(os.path.basename(r\"d:\\vscode\\python\\PisaApp\\test8.py\")) #只返回文件运行结果：test8.pyprint(os.path.join(r\"d:\\vscode\",\"python\",\"test.py\"))\t# 拼接路径运行结果：d:\\vscode\\python\\test.py\n\nSYS模块\n所有和python解释器相关的都在sys模块\n\nsys.argv # 可以接收到命令行参数\nimport sys\nprint(sys.argv[0])\n运行结果：d:\\vscode\\python\\PisaApp\\test8.py # 第一个参数指程序本身。\n\nsys.exit()    #程序退出\nimport sys\nwhile True:\n    print(\"ljx\")\n    sys.exit(0)    #这里只是一个描述，告诉操作系统返回了0表示正常退出\n    运行结果：ljx # 打印一次就退出\n    \nsys.version\nimport sys\nprint(sys.version)\n运行结果：# 输出当前解释器的环境版本说明\n3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]\n\nsys.path  #python用来搜索模块的，又称python环境变量，import时会去这里面找\nimport sys\nprint(sys.path)\n运行结果：\n['d:\\\\vscode\\\\python\\\\PisaApp', 'D:\\\\Programs\\\\Python\\\\Python312\\\\python312.zip', 'D:\\\\Programs\\\\Python\\\\Python312\\\\DLLs', 'D:\\\\Programs\\\\Python\\\\Python312\\\\Lib', 'D:\\\\Programs\\\\Python\\\\Python312', 'D:\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\site-packages', 'D:\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\site-packages\\\\win32', 'D:\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\site-packages\\\\win32\\\\lib', 'D:\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\site-packages\\\\Pythonwin']\n\nsys.path.append()    # 可以附加上需要用到的模块，放到python环境变量中去\n\nsys.platform\nprint(sys.platform)\n输出结果：win32 # 描述不准确，知道是win系统就行\n+ + ## socket+ socket英文翻译过来是插座意思，它本身不是一个协议，是一个套接字，操作系统为了方便大家直接使用TCP协议而存在的一个抽象层，它把复杂的tcp/ip协议隐藏在接口后面。  ```py  # socket服务器端  import socket    server=socket.socket()  # 绑定地址和端口  server.bind(('0.0.0.0',8080))  server.listen()  # 循环阻塞等待客户端连接  while True:      client,addr=server.accept()       #client为客户端对象，表示与客户端建立了一个独立的通道，addr为客户端地址。       print('客户端地址:',addr)      # 接收客户端数据      data=client.recv(1024)      print('客户端数据:',data.decode())      # 发送数据给客户端      client.send(b'hello')      # 关闭客户端连接      client.close()      # socket客户端  import socket    client=socket.socket()  # 绑定地址和端口  client.connect(('127.0.0.1',8080))  # 发送的数据为字节类型。有二种方法：  # client.send(b'Hello,Server!')  client.send('Hello,Server!'.encode('utf-8'))  client.close()  # 运行方法：先启动服务器，再运行客户端。  运行结果：当客户端运行完后，服务端会显示客户端的IP地址和发送过来的数据。  # 注意：服务端的rece方法是阻塞的，当客户发送的数据小于1024时是不会立即显示结果，但当客户端关闭连接时会显示出结果。\n\n\n\nhtml/css/javascript关系\nHtml是骨骼，css是皮肤，javaScript是肌肉（能动起来），三者之间的关系可以简单理解为m-v-c\n\nHtml语法规则：\n\n\n各种标签：\nh系列标签：h1~h6\na超链接标签：用于负责引入网页跳转链接。内面包含有href属性，后接值为链接地址；有target属性，用于链接展示的方式，值__blank是在新窗口展示，值_self在当前窗口展示。\nimg图片标签：用于负责引入图片，内包含src属性，值为图片路径的链接地址。还有height等属性。\nvideo视频标签：用于引入视频。内含src属性，值为视频链接地址。\ntable表标签，内有tr行标签，行标签内有td标签，存放单元格。数据抓取的时候，要注意Elements和页面源代码有区别。会渲染多出一个tbody标签。\nform表单标签，内有action属性，是服务的地址，最终提交表单的地方。默认是get提交，它的特点是在url上能够看到请求的所有参数，如果不希望看到，可通过method=”post”的属性和值来更换成post提交。\ninput输入标签，出现在form表单内，接收用户输入。有type、name等属性。\ndiv和span标签，这二个标签又称为素标签，与上面标签会实现一定功能不同，这二个标签没有任何功能，可塑性强，必须搭配css来使用，能修改成任意的样式，也是用得最多的地方，其中div是块级标签默认独占一行能换行，span是行级标签默认不独占一行，不能换行。随着h5的发展，又衍生出更详细的section、article、footer等素标签。\n在html中想要换行的话，有二个方案：\n可以选择一些自己独占的标签\n单纯的使用&lt;br/&gt;换行标签或专用于换行的段落标签&lt;p&gt;&lt;/p&gt;\n\n\n\n\n\n\nCSS又称为层叠样式表，能让页面好看，语法规则：属性：值；属性：值1 值2 值3；\n\n\n作用CSS有三种方式\n\n可以直接在标签上给出style，在style中给出样式内容，这时候这个style就是这个标签的属性。\n\n可以在html中使用&lt;style&gt;标签，可以写在head标签内面或外面，通过选择器去选择你页面上某个标签，给某个标签添加样式。如果标签内有class的类属性，可以直接使用class类属性值来添加样式。\ncss选择器：\t标签选择器：    \t# 选择标签    \t标签{                    }    类选择器        # 选择页面中class=\"xxx\"的标签        .xxx{                    }\n\n\n\n\n网页里面 使用的编程语言是 JavaScript ，简称 js，目前主流浏览器已经基本支持ES6版本\n\njs代码可以包含在网页中，发明 js 的目的，就是放在网页中，让网页 动 起来，称为一个交互式的应用程序，而不仅仅式展示文章类的信息\n\njs 是解释性的编程语言，由js解释器解释执行\n\n现代的浏览器 包括 Chrome、火狐、Edge、Safri 都内置了js解释器，解释执行 js 代码\n\njs 语言不仅仅只在浏览器中使用做前端开发，js语言已经走出了浏览器，用于其他领域，比如：后端服务开发、实时通讯、移动App开发（React Native）、桌面应用程序开发（Electron）等等\n比如 Node.js 就是一个独立的js解释器（就像Python解释器一样），可以运行任何用js代码编写的应用程序\n\njs 为什么能让网页实现动态的功能？因为 浏览器给了网页中的js 几个重要的能力：\n\n\n获取网页的内容\n更改网页的内容\n当某个事件发生时得到通知\n和服务端进行通讯\n\n\n我们常见的包含js执行引擎的软件： 一个是 浏览器 、另外一个是 node.js\n\n浏览器：\n打开浏览器，按F12，打开 开发者工具栏（英文叫 DevTools） 界面，然后点击 控制台（Console）\n这 Console 就是一个 js的 交互式代码输入界面。我们编写网页的时候，要执行功能的js代码，不可能让用户手动敲，而是放到网页里面。这包含两种方式： HTML内嵌js代码 和 HTML引用外部js代码文件网页内嵌的js代码 应该放在标签 script 中，成为一个 script 元素。包含js代码的 script元素， 通常可以放在html的 head 或者 body 元素里面。\n我们知道 CSS 可以嵌入 html，也可以独立在html外面，同样，我们还可以把js内容放到另外一个文件，比如 my.js ，然后html里面声明引用它\n\n\n//数据类型数字类型：整数和小数，在JS解释器内部都是存储为“双精度浮点数”，在 JavaScript 解释器看来，整数 和 小数 都是一样的，都是 数字类型，这和很多其他编程语言（Java、Python、C 等等）不同。//表达式带 加减乘除 运算符的，能够产生出一个结果数据的一段代码，术语叫做表达式。我们可以用 console.log 将表达式的结果输出到界面上。//js语句结尾可以加分号也可以不加因为即使你不加分号，js引擎执行时会自动加上分号//变量和注释我们把 js 语言中数据的名字, 称之为 变量名 ， 有时也简称 变量。所以 js 中的变量，就是 数据的名字。定义变量使用 关键字 let 或者 var ，变量名 和 数据 之间 用 等号 连接。注意：在js 中 变量名是大小写敏感的。js 定义变量时 可以不指定初始值。变量的值发生变化有两种情况：一是变量名 对应新的数据，这种情况也被称之为 变量重新赋值；二是变量数据 本身发生了变化，表现在js中 数组 和 Objects 是可变数据类型，当变量对应的数据是可变数据类型，可以通过变量名改变其内容。js 的注释有 单行注释 和 多行注释 2种：单行注释 以 // 开头，后面的内容都是注释多行注释 以 /* 注释内容 *///字符串数据js中， 一个字符串数据的类型是 字符串（String）字符串定义前后的引号，只是告诉解释器，引号内部 的内容就是一个字符串对象的内容。而引号本身并不是字符串的内容。字符串还可以 用 单引号 、双引号 、 反引号，其中反引号(backticks)引起来的称之为 模板字符串 ， 可以 直接写内容有多行 的字符串。如果不使用反引号定义字符串， 通常只能在字符串中 使用 \\n 转义符表示换行。字符串拼接：js引擎发现 字符串和其它类型的数据用+号连接，就会先把 其它类型的数据先转化为 对应的字符串，然后再拼接。字符串就是由一个个 元素 - 字符 组成的。像这种由一个个 元素依次组成的字符串， js 语言里面，把这种特性的数据称之为 sequence，翻译成中文就是序列。字符串就是一种序列。序列里面的元素都是有索引的。 所谓索引就是元素的下标，字符串元素的索引是从 0 开始，而不是从1 开始。获取字符串长度：字符串对象有个属性 length 可以用来获取字符串的长度，也就是获取字符串中字符的个数。//定义函数定义一个名字 对应多个语句操作， 称之为定义函数，所以：定义函数 就好像是给 一段代码 起了个名字。function 是关键字 表示定义一个函数，后面是函数的名字，紧接着后面需要一个括号 ，这个括号中间，根据需要还可以有 参数，最后函数里面要执行的所有代码 放在一个花括号中，表示这个函数名字代表的具体动作是什么，称之为函数体。//调用函数调用函数的时候，如果 传如的参数值个数 比定义参数的个数少，有的参数没有传值，js引擎会自动传入一个 undefined 值。调用函数的时候，如果 传如的参数值个数 比定义参数的个数多，多余的参数会在执行函数时被丢弃。//参数缺省值没有特别指定的情况下, 函数的参数的缺省值就是 undefined ，如果你调用的时候没有给某个参数传值，其值就是 undefined//变量的有效范围变量的有效范围有3种：全局 Global scope；函数内部 Function scope；代码块 Block scope定义在所有函数外部的变量，称之为 全局变量 。全局变量的有效范围是整个代码文件。函数内部代码 可以访问 全局变量的。定义在某个函数内部的变量，称之为 局部变量 。函数的 参数变量 也是 局部变量，局部变量有效范围只能是该函数内部。在 ES6（2015）之前，JavaScript 只有 Global Scope 和 Function Scope。ES6 引入了两个重要的新 JavaScript 关键字： let 和 const这两个关键字在 JavaScript 中提供了 代码块作用域 。{ } 花括号代码块内声明的变量不能从块外访问，如果要在代码块外访问只能通过return返回的值来使用。//var vs letvar 和 let 都可以定义一个变量.let 定义的变量如果在块内, 有效范围只能在本代码块内.而 var 定义的变量如果在块内, 其有效范围却可以是整个函数//一些内置函数输入框 - prompt 函数，以让浏览器弹出一个对话框，提示让用户输入单行文本信息提示框 - alert 函数，可以让浏览器弹出一个对话框，提示用户一段信息确认框 - confirm 函数，可以让浏览器弹出一个对话框，让用户确认一段信息，并选择是或者否parseInt、parseFloat，可以使用 parseInt 函数，把字符串表示的数字转化为 整数，可以使用 parseFloat 函数，把字符串表示的数字转化为 数字（整数或小数）//判断语句布尔数据只有两种取值： true 和 false运算结果是布尔值的表达式 ，就是 布尔表达式。是否相等：用 === 3个等号连接两个比较对象，== 2个等号连接两个比较对象，判断是否相等这种 2个等号比较 叫 松散相等比较（Loose Equality Comparison） ，而 3等号比较 称之为 严格相等比较（Strict Equality Comparison）是否不相等：!== 和 !=!== 的比较 称之为 严格不相等比较（ Strict inequality Comparison）!= 的比较 称之为 松散不相等比较（ Loose inequality Comparison）表达式逻辑操作：布尔表达式 主要有3 种逻辑操作 ：且（and） 、 或（or） 、 非（not） ， 分别对应 &amp;&amp; 、 || 、 ! 3种逻辑操作符如果 ! 、 &amp;&amp; 和 || 一起使用， 优先级是 ! &gt; &amp;&amp; &gt; ||，就是先计算 ! ， 再计算 &amp;&amp; 部分， 最后再计算 ||以上布尔表达式操作的结果true和false主要是用在判断语句中判断语句是以 if 关键字开头,if后面的逻辑表达式一定要用括号括起来,if 对应的后续执行代码如果只有一行，可以省略花括号else 表示在 if 后面的条件不成立时，要做一些事。if ... else 构成了一种 非此即彼 的判断关系。有的时候，情况更加复杂，还需要更多的判断，js中可以 使用更多的 else if 。注意 else if 和 else 的区别是 ：else if 后面会有一个 条件表达式， 而 else 没有if 语句后面也可以没有else 或者 else if//条件赋值:var fee = miles &gt; 3 ? miles*15 : miles*20如果条件评估为真，则冒号左侧的值将分配给变量。 如果条件评估为假，则冒号右侧的条件将分配给变量。//对象和属性js中 对象（Object） 可以和现实世界中的对象 概念对应就是包含了一组 属性（Property） 的数据， 属性可以是包含其它属性的对象。1.创建对象： 使用字面标记,创建一个 Object 类型的数据 有多种方法，最常见的就是直接 js语言 字面标记（literal notation） 构建var myCar = {    'brand'   : '奔驰',    'country' : '德国',    'price'   : 300000}这里面的 brand/country/price 都是对象的 属性（英文叫 properties ）。属性之间用逗号隔开，最后一个属性后面可以不用加逗号。有时，我们也把 属性名 称之为 对象的 key（键）访问对象的属性，语法是 对象.属性,或者 对象['属性名'],这种写法常用于属性名在写代码时不确定，是变量的情况动态更改属性:添加属性,myCar.year = '2021-3-3' 或者 myCar['year'] =  '2021-3-3'修改属性：如果赋值语句前面的的属性名已经存在，会覆盖原来的属性值删除属性：如果你要删除对象中一个属性，可以使用 操作符 delete比如：delete myCar.year 或者 delete myCar['year']函数作为对象属性：对象的属性也可以是函数，比如var myCar = {    brand   : '奔驰',    country : '德国',    price   : 300000,    showInfo : function() {      console.log(this.brand + ' ' + this.country + ' ' + this.price)    }}对象的函数属性，通常也被叫做对象的 方法（英文叫 method ），对象 的方法其实可以看成是对象所拥有的函数。调用对象的方法，语法是 所属对象.属性()在 JavaScript 中， this 关键字 代表了 当前执行环境，术语是Context，上下文的意思。就是指 调用这个方法 所通过的那个对象 ，也就是 . 前面的对象通过 myCar.showInfo() 这行代码调用的showInfo，里面的 this就是 myCar 对象2.创建对象：使用构造函数function Car(brand, country, price) {  this.brand = brand  this.country = country  this.price = price}var myCar1 = new Car('凯美瑞2020', '日本', 200000);var myCar2 = new Car('特斯拉Model 3', '美国', 300000);这里的 Car 就是一个构造函数。构造函数其实本质上就是一个函数。任何函数都可以当作构造函数来使用。只是，用来构造的函数里面，通常会 为将来所要构造对象 设置一些属性。函数里面的 this 就代表了要构建的对象，使用 new 操作符 后面调用构造函数，并传入参数，这样构建的对象就会拥有这些属性通常，我们可以说，myCar1、myCar2 就是一个 Car 类型的 对象 ， 或者 对象实例原型 和 原型链：内置构造函数 Object，js 有个内置的构造函数 Object，Object 翻译成中文，也叫 对象，为方便区分，我直接用 英文 Object 称呼它，不给他起中文名直接 字面标记语法var myCar = {    brand   : '奔驰',    country : '德国'}实质上是js引擎对这样的写法会自动调用Object构造函数var myCar = new Object()myCar.brand = '奔驰'myCar.country = '德国'所以，所有 用 字面标记 创建的对象 都是 Object 类型的 对象实例。函数本身也是对象，也可以为其动态的添加属性function func1(){  console.log('in func1')}func1.name = 'func1'func1.desc = 'func1 函数的作用是...'使用原型创建对象：内置函数 Object 有个 create 方法（函数对象也可以有自己的方法属性）可以用它直接创建对象。对象会 继承（inherit） 原型链 对象 里面的属性。如果对象自身属性和 原型链上的属性 同名，使用哪个，按原型链次序，首先会优先使用自身属性Object.prototype，原型链最后一环，其实：js中所有的对象 的原型链 最后都是终结于 Object.prototype，所以，js 所有的对象都可以访问 Object.prototype 里面的属性myCar1.toString()myCar1.hasOwnProperty('owner')myCar1.hasOwnProperty('type')toString 和 hasOwnProperty 都是 Object.prototype 里面的属性toString 是把对象转化为字符串表示的，对象可以自己添加该属性方法，重新实现该方法。在打印结果和字符串格式化拼接时有用。hasOwnProperty 是用来判断参数 是否是 对象自身的属性对象常见操作：检查对象是否有某个属性，可以使用 hasOwnProperty得到对象所有属性，Object.keys 方法可以返回 对象的 所有属性名 一个数组得到对象所有属性和值，Object.entries 方法可以返回 对象的 所有属性和值 到一个数组，方便我们遍历//数组数组的概念：js 有内置的构造函数 Array 。构造出的对象被称为 数组对象 ，或者直接简称 数组，里面存储的数据，通常被称之为数组的 元素索引：可以用元素 索引 的方式取出里面的元素切片 slice：js 中的 字符串 和 数组 ，都有 slice 方法可以进行切片改变数组内容：和我们前面学过的其它数据类型不同，数组对象有个特点，它的内容是 可以变化的末尾添加 push，push方法就会改变数组的内容，在后面添加一个元素。末尾取出元素 pop，如果我们要从数组 末尾取出元素 一个元素，就可以使用 pop 方法。pop 方法的返回值 是 取出来的元素开头取出元素 shift如果我们要从数组 开头取出元素 一个元素，就可以使用 shift 方法。shift 方法的返回值 是 取出来的元素，注意，取出后，该元素就从数组中删除了。指定位置删除 splice，splice 方法可以 删除 数组的一段内容指定位置替换 splice，splice 方法也可以 替换 数组的一段内容。替换就是 删除后再插入内容， splice从第3个开始，以后的参数都是要插入的元素。这种写法称之为 切片赋值指定位置插入 splice，如果我们 不是要在后面 添加一个元素， 而是在 指定位置插入一个元素怎么办？还是可以使用 splice 方法，第2个参数 删除个数 设置为 0数组元素倒过来 reverse：reverse方法将数组元素倒过来获取元素索引 indexOf，indexOf 方法返回 参数对象 在数组 中的位置，也就是索引检查是否包含 includes：数组的 includes 方法 返回数组中是否包含参数指定的数据，返回值为 true 表示存在，false 表示不存在清空数组方法1 ：变量赋值如果我们是想让某个变量对应的数组为空，可以这样：var arr1 = ['a','b','c','d','e','f'];arr1 = [];方法2 ：设置数组长度var arr1 = ['a','b','c','d','e','f'];arr1.length = 0设置数组长度为0，这样一个数组里面的内容就会被清空方法3 ：使用splicevar arr1 = ['a','b','c','d','e','f'];arr1.splice(0, arr1.length)拼接字符串 join：join 就是用参数里面的字符串连接数组里面的元素，返回值就是拼接后的字符串多个变量同时赋值我们可以像下面这样把 数组 中的元素直接赋值给变量var x1, x2, x3, x4[x1, x2, x3, x4] = [1,2,3,4]console.log(x1, x2, x3, x4)这种方式的术语叫： 解构赋值（Destructuring assignment ）解构赋值时，如果变量的个数 多于 等号右边的 值个数，有的变量值就是 undefined。const 定义变量：const 定义的变量，必须在定义时就赋值，后续不能重新赋值，也就是说： const 变量指向的对象 定义后就不能改变，但是const定义的变量 指向的对象内容变化是可以的map方法：对数组中的每个元素进行同样的处理，产生另外一个数组，参数是一个函数对象，就是对每个元素的处理函数//字符串、数字对象实际上，几乎所有的js数据类型，原型链最终都是 Object.prototype ，所以几乎所有的js数据类型的实例，都可以说是一个 对象，它们都可以使用 Object.prototype 的属性方法，和自身原型的属性方法。而下面的定义：let n1 = 356let s1 = '您好'它们是 primitive （ 原语 ）数据， 不是对象数据，primitive 数据 没有 属性，底层实现 往往就是 直接对应 存储在内存的 数据，所以非常高效。primitive数据是不能改变的。字符串对象，字符串对象 String 有如下常用的属性方法length，返回字符串对象的长度indexOf字符串的 indexOf 方法 和 数组的 indexOf 方法类似，它用来在字符串中查找 参数字符串，并返回该 参数字符串 在其中 第一个 出现的位置索引，如果字符串对象里面 没有 要查找的参数字符串，就会返回 -1，indexOf 方法 的第二个参数，用来指定 查找起始位置 切片 slicesplit：split 方法以参数字符串为分割符 ，将字符串 切割为多个 字符串，作为元素存入一个数组，并返回这个数组。分隔符本身在切割后，会被丢弃掉，所以切割后的字符串中不会有分隔符。trim、trimStart、trimEndtrim 方法可以 删除 字符串前面和后面的空白字符，比如空格、tab符， 以及行终结符， 比如回车、换行等等trimStart 方法 将 字符串前面 (左边) 的空格删除，但是不会删除字符串中间和右边的空格trimEnd 方法 将 字符串后面 (右边) 的空格删除，但是不会删除字符串中间和左边的空格replace 也是常用的方法，用来 替换 字符串里面 第一个 指定的 子字符串 为另一个 字符串新版本的浏览器 支持 replaceAll 方法。replaceAll 方法，用来 替换 字符串里面 所有指定的 子字符串 为另一个 字符串startsWith 和 endsWithstartsWith 方法检查字符串是否以参数指定的字符串 开头，如果是，返回true，否则返回falseendsWith 方法检查字符串是否以指定的字符串 结尾，如果是，返回true，否则返回false字符串模板:就是在字符串使用 反引号 ，然后占位符使用 ${} ,里面直接放入对应的数据对象。转义符:\\n 就是一个转义字符，表示一个换行字符,用 \\t 表示tab字符,用 \\x41 表示 ASCII编码为0x41的字符（也就是字符 A），用 \\u767d 表示 unicode编码为0x768d的字符（也就是汉字 白）也可以 使用反引号 ，在字符前面加上一个 String.raw ，表示字符串内容是raw string， 无需转义，像这样path = String.raw`c:\\windows\\temp`console.log(path)数字对象数字对象Number 有如下常用的属性方法parseInt、parseFloat可以使用 Number 的 parseInt 方法，把字符串表示的数字转化为 整数，可以使用 Number 的 parseFloat 方法，把字符串表示的数字转化为 数字（整数或小数）toString可以使用 Number 的 toString 方法，把字符串表示的数字转化为 整数//循环js 中有3种类型的循环: while循环 、 do while循环 和 for 循环do while 循环 肯定要先执行一次循环体内代码， 然后再判断是否继续循环的条件。而 while 循环 是 一开始就要先判断循环条件是否成立， 成立后再执行循环体代码。for 循环更适合 循环执行某段代码 指定次数for 循环的 后面那个括号里面有3个语句组成for (循环前执行代码; 循环继续与否判定表达式; 单次循环后执行代码) {  // 循环体代码}循环前执行代码：是 整个 for循环前 要执行的代码，只执行1次。循环继续与否判定表达式：是每次循环前用来判定是否继续执行本次循环的表达式。单次循环后执行代码：是每次循环后 要执行的一次语句，常用来执行 循环次数标记变量 的值变化遍历数组可以这样遍历数组，使用 for ... of 写法：这种写法适合遍历可遍历对象，比如 字符串String、数组Array、TypedArray, Map, Set 等等。每次循环，都会依次，取出 of 后面的数组里面的对象，赋值给 of 前面定义的变量，执行循环体里面的代码遍历对象如果我们需要遍历一个对象里面的所有属性和值，怎么办？Object.entries 方法可以返回 对象的属性和值 到一个数组，方便我们遍历，然后使用 for ... of 遍历数组break 终止循环解释器执行到 循环内的 break 语句，就会从循环退出。continue：只结束当前这一轮循环，后面还要继续循环的执行。//类和继承类型是 具有共同特征（属性、行为）的对象 的 特性 的定义。是特征的集合js中对象种类的共同特性 的提取定义， 是 通过 原型对象（包括构造函数） 实现的。定义类使用关键字 class 后面加 类的名称。紧跟类名 后面的花括号里面的所有内容就是 类定义，是该类的所有 属性（方法）的定义。从定义的类来 创建对象 也是使用 new 操作符，后面加上类名和括号，括号里面的参数是传递给 类定义里面 名为 constructor 的方法的 。constructor 被称之为构造函数， 作用类似前面讲的独立构造函数。这个方法在 使用 new 创建这个类 对应的 对象时，会被解释器自动调用 ，并且传入new 语句里面的参数。类里面定义的函数（包括constructor） 可以叫类的方法， 都是 不需要 function 关键字 声明的前面，我们说过 构造函数 也可以看作类型， 构造产生的对象 ，就是 这个构造函数类型的实例。类的继承关系通常我们把被继承的类称之为 父类 或者 基类 或者 超类把继承类称之为 子类 或者 派生类。类的继承关系可以通过关键字 extend子类会自动拥有父类的一切属性和方法，子类和父类不同的地方，可以重新定义子类 实例化时，如果构造函数里面行为 和 父类不完全一样，这时候，就需要 重定义 constructor 函数 。可以直接使用关键字 super 直接调用父类的constructor代码注意 super不仅仅可以代表调用父类的构造函数方法，也可以调用父类的其他方法//错误对象js 还有其他的错误类型， 都是继承自 Error 类型，代表各种不同类型的错误。抛出错误抛出错误, 使用关键字 throw ，后面加一个错误对象，这里是新构建一个对象，直接使用 Error 构造函数创建。执行完 throw 抛出异常的代码后， 后续的代码不会再执行捕获错误使用 try... catch ... 这样的语法来捕获和处理错误。try 下面缩进的花括号里面的代码可以看成是 监控区 中的代码。catch 引导的代码段 就是对 错误 的一种处理。try ... catch 后面还可以跟一个 finally 代码块。finally 代码块的代码， 不管try 里面有无错误抛出，都要执行的。//剩余参数函数参数的 个数是不确定的，前面加 3个点 的参数，称之为 剩余参数（rest parameters） 。展开语法：在调用函数时，对于剩余参数时的传递，可以使用三个点操作符 ...，这就是 展开语法(Spread syntax) //回调、匿名函数、this// 注册事件回调函数document.querySelector('#go').addEventListener(\"click\", salaryStats );所以 salaryStats 这种 先定义，后面在某个时候被调用的函数，叫 回调函数和 Python、Java 等语言不同，js 的执行引擎设计是 异步架构这里的 异步 是什么意思呢？就是 碰到阻塞性的调用，比如 定时等待、网络操作、磁盘IO等等， js引擎都不会停止后面代码的执行来 等 这些操作完成。这种异步的架构设计，设计模式里面 叫做 reactor 模式系统底层实现基本都是一个 主循环处理各种事件，比如 网络socket收到数据、文件读取数据返回、定时器超时 等等。然后调用相应的 用户代码进行处理。碰到阻塞性的操作，不会等，而是记录好操作完成的回调代码，继续执行后面的用户代码。用户代码都执行完了，就返回主循环，处理下一个需要处理的事件。这种架构， 特别适合 IO bound（也就是 高IO，低CPU） 的软件系统，典型的就是网站服务系统。因为它能高效的利用CPU。这个好像 操作系统多线程 调度的概念。操作系统可以让处于执行阻塞操作（读文件，等待网络消息）的线程让出CPU执行权，让其它线程占据CPU执行代码。这样大大减少了CPU闲置 ，这是 操作系统 对 多个线程 的 调度而异步的软件架构，是程序自身（比如js引擎）实现的 单线程 自身的内部代码 整理和调度。相比 操作系统多线程方式，它的效率更高，因为，多线程调度涉及到 操作系统调用，导致 CPU的执行模式切换，是要额外耗费资源的。而且，没有多线程操作共享资源的同步问题。因为实际上，这是单线程匿名函数：使用 匿名函数 避免这种起名字的麻烦匿名函数如果 单独定义在非参数位置，并且不赋值给变量，需要加上括号(function (a){  return a + 100;})箭头函数ES6 引入了 箭头函数 这种新的定义匿名函数的语法，更加精简a =&gt; {   return a + 100;}如果 箭头函数 体内 只有一行代码，并且是返回一个值，可以省略 return 和 花括号a =&gt; a + 100回调函数中的this：通过哪个对象调用了这个函数，函数里面的 this 对应的是就是这个对象箭头函数中的this：箭头函数中的this比较特殊，它对应的 是 包含该箭头函数 的函数的执行环境\n\nJS前端\n怎么用 js 语言实现 浏览器相关 的 操作呢？浏览器运行环境 提供了 丰富了 js语言编程接口 ， 称之为 Web API 接口。\n\n浏览器内置window对象：\n\n对应的是一个 Window 类型的对象，它代表了 js 运行的这个浏览器窗口环境。由于它代表的就是整个浏览器js运行环境，所以这个对象的属性方法可以直接在js代码中使用，不需要加上 window. 作为前缀，比如，我们前面学过的 prompt、alert、confirm 其实就是 window的方法\n\nhistory、location：history 对应 就是 当前浏览器的 浏览历史对象\n\n// 返回上次浏览地址，等于点击浏览器的返回按钮\nhistory.back();\n// 也是 返回上次浏览地址\nhistory.go(-1);\n// 前进到返回前面的地址，等于点击浏览器的前进按钮\nhistory.forward();\n+ `location` 对应 就是 当前浏览器的 地址对象  ```js  // 设置当前浏览地址  location.href = '/main.html'  // 重新加载网页，等于刷新网页  location.reload()\n\n\nlocalStorage 可以看作一个 本地键值对数据库，它是当前网站的 前端存储，关闭浏览器窗口后也不会丢失数据\n// 存入/修改 数据localStorage.setItem('myCat', 'Tom');// 获取数据const cat = localStorage.getItem('myCat');// 清除localStorage 数据localStorage.clear();\n\nsessionStorage 也是一个 本地键值对数据库，它也是当前网站的 前端存储，和 localStorage 的差别是， 它的数据是和session相关的。关闭浏览器窗口后，数据就会丢掉。\n// 清除 sessionStorage 数据sessionStorage.clear();// 存入/修改 数据sessionStorage.setItem('myCat', 'Tom');// 获取数据const cat = sessionStorage.getItem('myCat');\n\nclose() 方法可以 关闭当前窗口\n\nopen() 方法可以 打开一个新的窗口\n// 打开新空窗口open()// 打开新窗口，访问指定urlopen('https://www.byhy.net')// 直接本窗口打开访问指定urlopen('https://www.byhy.net', '_self')\n\n\nDOM 文档对象模型:\n\n浏览器加载网页（根据html文档和一些代码） 后， 会在浏览器内部（内存中）创建一个文档对象模型 (document object model) 简称 DOM 对象 ， 对应 树状的 文档结构。每个html元素以及每段字符串，都会对应DOM对象的一个 节点（node）,它们的上下层关系和html文档对应。\n有如下一些DOM 相关的术语：这个树状文档的 根节点（root node） 是 HTML节点每个html元素 都对应一个 元素节点（Element node）有的元素节点，有其 子节点（Child node） ，相对而言，它就是其子节点的 父节点（Parent node）某个元素节点 分支下面所有的子节点、子节点的子节点，等等， 都是它的 后代节点（Descendant node）相同父节点的节点 之间是 兄弟节点（Sibling nodes） 的关系只包含一段文本字符串的节点是 文本节点（Text node）特别要注意的是名词 元素（Element） 和 节点（Node） 的区别任何 DOM对象都是一个 节点 ， 包括 元素节点、 注释节点、 文本节点、属性节点节点类型\t节点值ELEMENT_NODE\t1ATTRIBUTE_NODE\t2TEXT_NODE\t3CDATA_SECTION_NODE\t4PROCESSING_INSTRUCTION_NODE\t7COMMENT_NODE\t8DOCUMENT_NODE\t9DOCUMENT_TYPE_NODE\t10DOCUMENT_FRAGMENT_NODE\t11\n\n元素（也叫元素节点） 只是其中一种 节点，它们是对应一个html元素的， 比如 body、p、span、div 这些节点。\n\n其它的，比如注释节点、文本节点 就不是 元素节点\n\n整个DOM对象， 可以通过 js引擎内置对象 window.document 或者直接 document 访问到。\n\nDOM对象中每个节点对象 都是可以通过 document对象 的一些内置方法获取到。\n\n\n\n网页程序示例\n\n现代的网站不仅仅只是富文本信息的呈现，可以 网页聊天、邮件交互、甚至可以在网页上打游戏\n所以现在很多网页，其实 就是一个真正的 应用程序 ，而不是传统意义上的 网页 了。\n\n网页成为应用程序 的关键 就是 js 语言对网页内容的操作能力，主要就是： 得知网页事件、获取网页内容，改变网页内容\n\n获取元素对象：网页应用程序，要管理界面，其实就是管理界面的一个个元素对应 的 DOM 对象。而要控制这些对象（获取信息、修改信息）， 首先得能在代码中 获取这些DOM对象 ，然后才能调用它们的方法对其进行控制。选择对象，最灵活的方法就是使用 querySelector 、 querySelectorAll 方法，参数是 CSS 选择表达式\n\nquerySelector 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 querySelectorAll 方法\n\n事件和处理：什么时候网页 应该 执行我们写的代码？通常是某个事件发生的时候，比如用户输入数据后，按回车、 点击某个按钮、鼠标移动到某个元素上、等等。那么怎么告知浏览器，当某个事件发生，回调我们的代码呢？使用 DOM 对象的 addEventListener 方法。\n&lt;script&gt;      function salaryStats(event){    alert('执行salaryStats')   }  // 注册事件回调函数  document.querySelector('#go').addEventListener(\"click\", salaryStats );  &lt;/script&gt;其中 注册事件回调函数的代码 ，在 id 为 go 的元素上，使用 addEventListener 方法，注册了点击的事件， 当这种事件发生的时候，就回调执行函数 salaryStats 来处理这个事件。salaryStats定义的时候，知道，浏览器回调自己的时候，会传入一个 MouseEvent（鼠标事件）类型的对象。事件类型 除了鼠标事件外，还有 键盘事件，滚轮事件、拖拽事件、剪贴板事件 等等。\n\n获取网页内容：主要就是要通过DOM 对象的 属性。不同类型的html元素，对应的DOM 对象的类型是不同的\na 对应的DOM对象类型是 HTMLAnchorElementp 对应的DOM对象类型是 HTMLParagraphElementtextarea 对应的DOM对象类型是 HTMLTextAreaElementbutton 对应的DOM对象类型是 HTMLButtonElementdocument.querySelector('#salary').value从HTMLTextAreaElement的属性表得知，textarea文本框里面的内容 对应的是属性 value\n\n等等\n\n改变网页的内容：和获取网页内容一样，要改变网页内容，首先要获取 对应的 DOM对象，然后通过对象的属性方法，改变其内容。通常有如下几类\n\n添加元素：可以给某个节点添加新节点，比如\ndocument.querySelector('div')  .insertAdjacentHTML(\"beforeend\", \"&lt;p id='test1'&gt;薪资20K以上的有：xxx、yyy&lt;/p&gt;\")insertAdjacentHTML 方法就是在DOM 对象的某个位置插入新的html节点。第2个参数 就是要插入的节点对应的HTML 内容第1个参数 指定插入节点的位置，这里 beforeend 就是 指 插入节点作为 当前节点的 最后一个子节点\n\n删除元素：要删除元素，可以 先获取该元素，然后调用remove方法\ndocument.getElementById(\"test1\").remove()还可以这样删除：document.getElementById(\"myDiv\").outerHTML=\"\";支持这种方式的浏览器更广泛，包括IE\n\n改变元素内容和属性：改变元素内容和属性 ， 同样也是通过DOM对象的方法\n// 设置 id 为 salary的textarea 里面的内容 document.querySelector('#salary').value = `薛蟠     4560 25薛蝌     4460 25`document.querySelector('#salary').value = ''// 改变 id为result元素的内部文本document.querySelector('#result').innerText = '薪资20K以上的有：xxx、yyy'// 改变id为result元素的文本颜色为红色document.querySelector('#result').style.color = 'red'// 改变button按钮文本let addOneBtn = document.querySelector('button')addOneBtn.innerText = addOneBtn.innerText === '隐藏' ? '添加' : '隐藏';那么到底一个元素对应的DOM对象有哪些属性方法呢？还是要看DOM对象的 类型不同类型的HTML元素对应的 HTMLElement 对象不同， 属性也会有差异\n\n控制元素是否显示：\n\n控制元素是否显示，可以根据元素的CSS样式里面的 display 属性 ，当 display 的值为 none ，元素不显示\nlet pnEle = document.querySelector('.paginator')if(pd.pagecount === 0){  pnEle.style.display = 'none'  return}\n\n其它能力：浏览器 Web API编程接口还提供了其它能力，比如：和服务器通信能力包括HTTP/WebSocket等，浏览器端存储能力包括Local Storage, Session Storage, Cookie, IndexedDB等等，本地文件访问能力，定位能力等等，完整的编程接口，点击参考这里，这些js编程接口的API 提供了底层能力，我们运用好它们，就可以开发各种功能的网页应用程序\n\n\n\n\n\n元素通用属性\n\n继承关系：要用js代码改变界面元素展示的内容、样式， 需要先获取该元素对应的 DOM 对象， 然后再通过调用对象的属性或者方法。不同类型的HTML元素对应的 DOM 对象类型不同， 属性、方法 也会有差异。但是所有的 HTML元素对象 都有相同的继承关系：\nEventTarget &lt;- Node &lt;- Element &lt;- HTMLElement \n\n我们知道，js对象可以使用其祖先类型的属性/方法，所以所有的HTML元素，不管是 p、div、span、button ， 他们对应的对象，都可以使用 EventTarget、Node、Element、HTMLElement 这些祖先类型的属性和方法，也就是页面元素DOM对象 通用 的属性和方法。\n\n\n\nEventTarget：EventTarget类型提供了如下方法：\n\naddEventListener()：用来注册处理 该对象的事件 的处理函数。\n\nremoveEventListener()：这是 类型 EventTarget 的方法，用来取消 注册处理 该对象的事件 的处理函数。\n\n\n\nNode：Node类型提供了如下属性和方法：\n\n获取所有子节点：childNodes属性可以 获取元素的所有子节点对象，获取的子节点是所有的DOM子节点， 包括 html元素、文本、注释。返回的NodeList 类型，类似数组，可以使用for of 遍历， 里面的对象就是各自节点对应的类型\n\ntextContent：用来 获取 元素内部所有的文本内容，包括不可见的部分。这个属性也可以用来 设置 元素内部 文本内容\n\n获取父元素节点：该属性返回这个Node的父HTML元素\n\n\n\n内置对象document：内置对象 document 的类型是 Document ， 继承关系如下，所以 EventTarget 和 Node 的属性方法，比如 addEventListener() , childNodes 等等 ， 对 document都是适用的。\nEventTarget &lt;- Node &lt;- Document\n\n\n产生元素对象：createElement 方法可以产生元素对象。\n&lt;body&gt;  &lt;p id='target'&gt;原来的元素&lt;/p&gt;&lt;/body&gt;&lt;script&gt;  let p = document.querySelector('#target')  const new1 = document.createElement(\"p\");  new1.textContent = '新元素1';  p.after(new1);&lt;/script&gt;\n\n寻找内部元素：寻找内部元素，最灵活的方法就是通过 document对象的 querySelector 、 querySelectorAll 方法，参数是 CSS 选择表达式，来选择元素。如果，没有找到符合条件的元素，返回 null，querySelector 方法，返回的是HTML中第一个符合 选择表达式的 元素。如果要选择所有符合 选择表达式的元素， 可以使用 querySelectorAll 方法，返回的是一个类似数组的对象NodeList，里面存放了所有符合条件的 DOM 对象。通过 document 调用 querySelector/querySelectorAll 是在整个DOM 里面选择元素。如果要在某个 DOM 元素 的 内部范围内选择，就可以调用这个 元素 DOM 对象的 querySelector/querySelectorAll 方法。\ndocument.querySelector('div').querySelector('span')\n\n除了css表达式选择元素，还可以直接根据元素的 id 、 name属性 、 标签名 、 class属性 选择元素\n比如\n// 根据id选择，返回单个元素对象document.getElementById(\"myDiv\")// 根据name属性选择，返回的是一组元素对象document.getElementsByName(\"btn\")// 根据标签名选择，返回的是一组元素对象document.getElementsByTagName(\"input\")// 根据class属性选择，返回的是一组元素对象document.getElementsByClassName(\"btn\")\n\n注意返回的一组对象时，是放在一个类似 数组的 对象 HTMLCollection 中，就像数组一样，可以直接通过索引访问对应的元素\ndocument.getElementsByTagName(\"input\")[1]\n\n\nElement：我们常用的属性和方法大都是来自 Element 类型的。\n\nid：id 属性可以获取/设置 该元素的id属性。\n\nchildren 只读：可以获取该元素的所有子元素，返回的是对象是 HTMLCollection 类型，这个类型 功能类似 数组，里面存放的是 html元素对象，可以使用 for of 遍历， 也可以使用索引获取其中的元素。\n\ninnerHTML、outerHTML：innerHTML 可以用来获取一个元素对象 内部 HTML文本；outerHTML 可以用来获取一个元素对象 全部 HTML文本。\n\n获取内部元素：如果我们只要在某个元素的内部获取元素，通用的针对某个元素调用这些方法即可。同样，如果没有找到符合条件的元素，querySelector 返回 null。\n\n获取上级元素：closest() 方法获取符合条件的 最接近 的上级元素，参数是一个css选择表达式。如果自身也匹配，则返回本元素自身，因为自身更接近自身。如果没有匹配的元素，则返回null\n\n添加元素：Element方法中，有好几个用来添加节点。after() / before() / append()，after 是给当前元素节点，添加一些 后续弟弟节点 ，参数可以是1个或者 多个节点对象，参数可以是 元素对象 （添加后成为html元素） 或者 字符串（添加后成为文本节点）\n&lt;body&gt;  &lt;p id='target'&gt;原来的元素&lt;/p&gt;&lt;/body&gt;&lt;script&gt;  let p = document.getElementById('target')  const new1 = document.createElement(\"p\");  new1.textContent = '新元素1';  const new2 = document.createElement(\"p\");  new2.textContent = '新元素2';  p.after(new1,new2,'abc');&lt;/script&gt;\n\n相反，before 是给当前元素节点，添加一些 前置哥哥节点,append 是给当前元素节点，添加一些 子节点 ，\n\ninsertAdjacentHTML()：使用 after() / before() / append()，必须先使用 document.createElement() 创建一个元素对象然后再调用新对象的方法，创建内容。写起来比较麻烦。可以使用 insertAdjacentHTML` 方法直接写元素对应的html文本内容。比如\n&lt;p&gt;薪资统计&lt;/p&gt;&lt;script&gt;  let pEle = `      &lt;br&gt;&lt;br&gt;      &lt;p&gt;小张: &lt;mark&gt;15000&lt;/mark&gt;&lt;/p&gt;      &lt;p&gt;小李: &lt;mark&gt;18000&lt;/mark&gt;&lt;/p&gt;`  document.querySelector('p')  .insertAdjacentHTML(\"beforeend\", pEle)&lt;/script&gt;\n\ninsertAdjacentHTML 方法就是在DOM 对象的 某个位置 插入新的html节点。\n\n第2个参数 就是要插入的节点对应的HTML文本\n\n第1个参数 指定插入节点的位置\n\nafterbegin\n插入内容 作为 当前节点的 第一个子节点\n\nbeforeend\n插入内容 作为 当前节点的 最后一个子节点\n\nbeforebegin\n插入内容 作为 当前节点的 前一个哥哥节点\n\nafterend\n插入内容 作为 当前节点的 下一个弟弟节点\n\n\n\n\n\n删除元素:remove() 方法用来删除元素自身。\n\n替换元素：可以使用 outerHTML 、 innerHTML 属性替换元素。也可以使用 replaceWith 方法替换元素\n\n获取元素属性：getAttribute() 可以用来获取元素的属性， getAttribute() 返回值都是字符串的形式，有的属性，也可以直接通过 元素对象.属性 的方式获取元素的属性，但是这种方式只能获取元素的标准属性， 不能获取自定义非标准属性的值，而且有的属性获取的结果和 getAttribute() 不一样，返回值不一定是字符串，比如\na.style // 得到的值 类似 Object类型a.href  // 得到的值是全路径\n\n设置元素属性：setAttribute() 可以用来设置元素的属性，参数 都是字符串的形式，也可以直接通过 元素对象.属性 的方式设置元素的属性，而且有的设置方式和 setAttribute()不一样，因为 元素对象.属性 的方式值不都是字符串，比如\na.style.color = 'green'\n\nstyle 属性其实不是 Element 类型里面的，是 HtmlElement 类型里面的\n\n删除元素属性：removeAttribute() 用来删除元素的属性\n\nclass属性：class属性操作， 除了前面讲的通用方法，还可以这样操作：classNameclassName 可以用来，获取和设置元素的class属性，之所以不直接用 class 作为属性名，是为了避免和 js 的关键字 class 冲突,className 是对元素 class属性整体 当作一个字符串操作的。如果想单独操作某个class ，不改变其它class属性，推荐使用 classList 属性，classList 属性对应一个 DOMTokenList 类型， 有一些方便操作属性值的方法，比较常用的是：contains 方法、remove 方法、add 方法。\n\nHtmlElement：有如下常用属性方法\n\ninnerText、outerText：HtmlElement 的 innerText 和 Node 的 textContent 属性都可以 获取/设置 元素内部的文本内容区别是：innerText 展示的是该元素对应的可以呈现在界面上的文本内容；textContent 展示的是元素内部所有的文本内容，包括不可见的部分\n\nstyle：style属性的值是 CSSStyleDeclaration 类型， 类似 Object类型， 可以通过这个对象的属性来 获取、设置 元素的样式\n\nfocus()：focus方法可以让该元素获取输入焦点，前提是这种元素可以获取输入焦点\n\nclick()：click 方法 模拟鼠标点击该元素\n\n元素自身属性：前面学习了HTML元素通用的属性和方法，不同类型的HTML元素对应的 DOM 对象类型不同，属性也会有差异。这里我们学习一些常用HTML元素对象 自身 的属性方法，注意：下面介绍的元素属性，如果没有特别标记为 只读 ， 就是 既可读、也可写\n\na： 对应的DOM对象类型是 HTMLAnchorElement。常用属性有： hash host hostname href origin port protocol search\n&lt;a href='https://www.byhy.net:80/py/lang/basic/09?name=byhy&amp;pagenum=23#pop'    target='_blank'&gt;  测试连接&lt;/a&gt;&lt;br&gt;&lt;br&gt;脚本运行结果如下&lt;pre style='font-size:1rem'&gt;&lt;/pre&gt;&lt;script&gt;  let a = document.querySelector('a')  let pre = document.querySelector('pre')  pre.innerText = `a.hash     = ${a.hash}a.host     = ${a.host}a.hostname = ${a.hostname}a.href     = ${a.href}a.origin   = ${a.origin }a.port     = ${a.port}a.protocol = ${a.protocol}a.search   = ${a.search}`&lt;/script&gt;\n\nbutton：对应的DOM对象类型是 HTMLButtonElement，常用属性有：disabled，是个bool值，表示该按钮是否被禁用，禁用为true，可用为false\n\nimg：对应的DOM对象类型是 HTMLImageElement，常用属性有：alt，对应 img 元素的 alt属性， 当图片显示失败时（比如url错误），在图片位置显示的文本内容；height，对应 img 元素的 高度，数字为单位，表示像素；width，对应 img 元素的 宽度，数字为单位，表示像素；src，对应 img 元素的 的url地址\n\ninput：对应的DOM对象类型是 HTMLInputElement，常用的通用属性和方法有：value属性对应输入框里面的文本；name属性；type属性；disabled是个bool值，表示该按钮是否被禁用，禁用为true，可用为false\n\ninput - text，email，password，number：类型是 text，email，password，number 等这些输入框input，有如下属性：maxLength/minLength，最多和最少输入的字符数量；placeholder；readOnly；size；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，\n参数 replacement 指定用来替换的字符串，参数 start, end 是可选参数，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。\n\ninput - number：类型是 number 的数字输入框, 除了上述属性外，还有下面的属性，max、min，max指定了 输入框 可输入数字最大值，超过该值时会有错误提示，min指定了 输入框 可输入数字最小值，小于该值时会有错误提示，点击增加箭头，不会超过该数值；step一个数字，表示输入框数字的增减单位。\n\ninput - radio，checkbox：checked，该属性值为bool类型，表示是否选中；defaultChecked，该属性值为bool类型，表示缺省（页面刚加载完成时）是否选中；\n\ntextarea：对应的DOM对象类型是 对应的DOM对象类型是 [HTMLTextAreaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement)，常用属性有：value，返回/设置 文本框内的输入内容；rows/cols，rows、cols属性分别指定 输入框的行数和列数；disabled，返回/设置 是否禁用文本框，被禁用后，就不能输入内容了；maxLength/minLength，也就是最多和最少输入的字符数量；placeholder；wrap，返回/设置 一行文字超过文本框宽度时 如何显示，取值为off，一行文字超过文本框宽度时，不换行， textarea元素出现水平滚动条，soft，一行文字超过文本框宽度时，剩余内容 折到下一行显示，这是缺省值，hard，设置该值时，必须同时指定cols` 属性这样，一行文字超过文本框宽度时，浏览器自动插入换行符 (CR+LF)，剩余内容 折到下一行显示；select()，全部选中输入框里面的文本，调用该方法前面通常需要先调用focus方法；setSelectionRange(selectionStart, selectionEnd)，选中指定部分内容，参数 selectionStart 指定了选中的开始字符索引， selectionEnd指定了选中的结尾字符索引+1， 索引从0开始计数，调用该方法前面通常需要先调用focus方法；setRangeText(replacement, start, end)，用新字符串替换输入框中指定部分内容，参数 replacement 指定用来替换的字符串，如果没有 start,end 参数，会替换用户选中部分内容，如果用户没有选中内容，则插入到光标位置，如果 有 start,end 参数， 分别指定了替换的开始字符索引 和 结尾字符索引+1， 索引从0开始计数。\n\nselect 和 option：select 对应的DOM对象类型是 HTMLSelectElement，option 对应的DOM对象类型是 HTMLOptionElement，HTMLSelectElement 常用属性、方法有：options 只读，返回 HTMLOptionsCollection 对象， 里面存放了所有的option对应的 HTMLOptionElement 对象；value，返回/设置 第一个选定 option 元素的value属性，值为 空字符串 表示未选择任何元素；selectedIndex，返回/设置 第一个选定 option 元素的索引数字，值为 -1 表示未选择任何元素；disabled，返回/设置 是否禁用选择框，被禁用后，就不能选择了；type 只读，返回 表示支持多选与否的字符串。 当该select有multiple属性时，返回“select-multiple”， 否则，返回“select-one”；add(item, before)，添加选项，有两个参数，item，新增 HTMLOptionElement 对象 或者 HTMLOptGroupElement 对象，before，表示在哪个索引对应的选项前插入，值为数字，插入到index对应的位置上，该参数可选，如果没有传入值，或者为一个不存在的index，则新选项会插入到最末尾；remove(index)，删除选项，参数index表示要删除选项的位置索引，值为数字；HTMLOptionElement 常用属性、方法有：value，返回/设置 该 option 元素的value属性；text，返回/设置 该 option 元素的 选项文本内容，selected，返回/设置 该 option 元素是否被选择，是为 true，否为 false；index 只读，返回 该 option 元素的索引值。\n\n\n\n事件处理：addEventListener，可以告知浏览器，当某个事件发生时，执行哪个函数进行处理。除了使用 addEventListener 指定 事件处理函数，还可以使用 元素对应 DOM 对象的事件属性 指定 事件处理函数，事件属性名是 on开头，后面加事件名称，比如： onkeydown 、 onclick 等等。还可以直接在 元素属性中设置事件处理这叫html 内联定义 - 不推荐，这样破坏了html界面和js代码的分离，不方便维护\n\n事件针对的元素：针对哪个元素dom对象调用 addEventListener 方法， 就是在这个元素的范围内注册事件处理函数。非这个元素内发生的 注册事件 ，不会触发调用。\n\n代码在html中的位置：很多人喜欢把js内嵌的代码都集中放在head里面，在head中的js代码在网页内容（也就是body中的内容）渲染前，会被先执行。这样 DOM 里面内容还没有创建， 还没有body节点，所以会报错。为解决这个问题，可以定义load事件，因为页面资源完成全部加载，包括页面HTML所有DOM对象产生，界面渲染完成，引用的外部js、css、图片加载完成 等等，会发出load事件：\nwindow.addEventListener('load', (event) =&gt; {  // 执行代码});//参数event 就是 load事件对象,如果不需要处理该对象，可以忽略，像这样:window.addEventListener('load', () =&gt; {  // 执行代码});//也可以使用 window对象的onload属性:window.onload = () =&gt; {  // 执行代码};\n\n事件对象和类型：\ndocument.querySelector('#salary').onkeydown = event =&gt;{  // 处理代码}//这个里面的 event 参数对应的就是，事件发生时，浏览器传入回调我们的函数时，传入的 事件对象,不同的用户操作触发的事件对应的事件对象的类型不同,比如我们上面的是键盘事件，对应的就是 键盘事件（KeyboardEvent） 对象类型如果是鼠标按钮点击操作，对应的就是 鼠标事件（MouseEvent） 对象类型。不同类型的对象，其属性、方法 不同比如 上例中，我们是 键盘事件，传入的是键盘事件对象，它有属性：ctrlKey如果事件发生时，ctrl键按下，值为true，否则为falsealtKey如果事件发生时，alt键按下，值为true，否则为falseShift如果事件发生时，shift键按下，值为true，否则为falsekey返回 事件发生时，按下按键的字符串表示，比如Enter 对应回车键1、2、3、4 对应数字键 1、2、3、4a、b、c、d 对应字母键 a、b、c、dA、B、C、D 对应字母键 A、B、C、D等等，大家可以通过 在代码中加上console.log(event.key)查看你的按键对应的到底是什么key属性的值事件对象类型 有很多，除了 键盘事件、鼠标按钮事件 外，还有 滚轮事件（WheelEvent）、拖拽事件（DragEvent）、游戏触控板事件（GamepadEvent） 等等。//还有的事件不是用户操作触发的，比如 页面加载完成事件、网址hash更改事件（HashChangeEvent）、websocket网络消息事件、 存储事件 等等\n\n\n\n事件处理顺序：\n浏览器创建一个 click 事件对象,这个事件对象会先从 浏览器DOM 顶层的 window 对象一直 传递下去，直到 触发事件的对象的父对象 ，这个过程称之为 capture Phase（捕获阶段）。这个路径上，如果有任何DOM对象注册了点击处理事件，就会按照从上到下的先后顺序，依次被调用。然后，这个事件对象 到达触发事件的td对象，这个过程称之为 target phase（目标阶段）然后，这个事件对象 再从触发事件的td对象，一直传递到顶层的window对象，这个过程称之为 bubbling Phase（冒泡阶段）注意， click 事件是会 冒泡传播 的， 但是也有些类型的事件（比如，blur、focus）是不会冒泡的，到target 位置就结束了。要声明注册的处理函数是在 捕获阶段 触发执行 ，应该这样element.addEventListener(\"click\", e =&gt; {这里是处理代码}, true)第3个参数如果是boolean 并且设置为true ，就表示是 Capture Phase触发行。要声明注册的处理函数是在 非捕获阶段（target phase 和 bubbling Phase）触发执行 ，应该没有第3个参数，或者第3个参数为false，如下：element.addEventListener(\"click\", e =&gt; {这里是处理代码})// 或者这样element.addEventListener(\"click\", e =&gt; {这里是处理代码}, false)\n\n事件对象 target属性 / this：当我们实现事件处理函数的时候，传入的参数对象就是 触发的事件对象，这里我们用变量名 e 指代它，这个事件对象的属性中 有两个要注意的：e.target 指代了 真正触发事件的那个DOM对象，而e.currentTarget 指代了当前 正在处理事件的DOM对象， 也就是当前处理函数 注册对应那个对象。在处理函数中，也可以使用 this ，等价于 event.currentTarget\n\n\njQuter\njQuery 是一个非常流行的 js库，方便我们进行 web 前端开发。主要的用途有： 操作DOM对象、事件处理 、和服务端通信、常用功能库、动画效果。特别是早期前端开发，当时 js语言 和 浏览器 Web API 功能比较少，使用jQuery提供的库，可以大大提高开发人员的效率，几乎是web前端开发必不可少的库。后来 js语言本身 和 浏览器 Web API 不断完善 ，现在通常可以不需要 jQuery，但是仍有大量的第三方库 和 现有项目的代码 依赖 jQuery，所以还是有必要学习的。\n\njQuery的安装：开发环境下，要使用 jQuery 库，可以在本地服务创建一个库目录，然后把 jQuery 库 从 官网下载地址下载本地库目录中。还可以直接使用 靠谱的 js库 公共cdn推荐如下：\njsdelivr3.6.0 版本的jQuery库url为：https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js由于目前 3.6.0 就是最新版，可以简化写为https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.jscdnjsjQuery库url为：https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js字节跳动公共库cdnjQuery库url为：https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js大家可以把 jQuery 库的url地址 添加到你的网页head中，比如&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;//注意：公共cdn有时会突然宕机，所以正式产品部署时，还是下载部署到自己的网站上，或者自己购买的CDN云服务上（比如 阿里云CDN+OSS）\n\n选择元素和事件处理：html中 引入jQuery 库链接后，就可以使用该库了，先看一下jQuery 如何选择元素并进行事件处理。\n&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id='b1'&gt;测试按钮1&lt;/button&gt;  &lt;button id='b2'&gt;测试按钮2&lt;/button&gt;  &lt;script&gt;  jQuery('button').on('click', function () { alert('按钮被点击') })  &lt;/script&gt;&lt;body&gt;//其中 jQuery 本身就是一个构造函数， 里面的参数是css 选择器,jQuery('button') 返回的就是一个 jQuery 对象。这个对象类似js的数组，里面包含了所有参数 css 选择器 选中的DOM对象。jQuery 对象的 on 方法，用来定义事件处理,第一个参数就是事件名称，第二个参数是回调函数,还有一种简便写法，如下jQuery('button').click( function () { alert('按钮被点击') })//如果返回的对象选择到了多个元素对象， 不需要循环定义每个元素对象的事件处理，而是可以一起定义。//jQuery 还有一个简化的别名就是一个字符 $ 所以上面的代码也可以简写为$('button').on('click', function () { alert('按钮被点击') })//当然也可以注册处理其他类型事件，比如&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;textarea&gt;按ctrl+回车 试试&lt;/textarea&gt;  &lt;script&gt;  $('textarea').on('keydown', function (e) {     if (e.ctrlKey &amp;&amp; e.key==='Enter')          alert('按下了ctrl+回车')   })  &lt;/script&gt;&lt;body&gt;\n\n元素操作：\n\n添加元素\n&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id='content1'&gt;    &lt;p id='target1'&gt;原来的元素1&lt;/p&gt;  &lt;/div&gt;  &lt;div id='content2'&gt;    &lt;p id='target2'&gt;原来的元素2&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;//然后打开控制台，分别执行如下代码，看看html内容的变化,下面是添加子元素的示例// 这样创建一个html元素对象 var ele1 = $( \"&lt;p&gt;新元素1&lt;/p&gt;\" );// 添加到 div#content1 ，作为最后一个子元素ele1.appendTo( \"#content1\" );// 当然也可以这样写$( \"&lt;p&gt;新元素1&lt;/p&gt;\" ).appendTo( \"#content1\" );// 添加到 #content1 ，作为第一个子元素$( \"&lt;p&gt;新元素2&lt;/p&gt;\" ).prependTo( \"#content1\" );// 插入到 #target2 前面，作为哥哥节点$( \"&lt;p&gt;新元素3&lt;/p&gt;\" ).insertBefore( \"#target2\" );// 插入到 #target2 后面，作为弟弟节点$( \"&lt;p&gt;新元素4&lt;/p&gt;\" ).insertAfter( \"#target2\" );//还可以这样$( \"#content1\" ).append( \"&lt;p&gt;新元素1&lt;/p&gt;\" );$( \"#content1\" ).prepend( \"&lt;p&gt;新元素2&lt;/p&gt;\" );$( \"#target2\" ).before( \"&lt;p&gt;新元素3&lt;/p&gt;\" );$( \"#target2\" ).after( \"&lt;p&gt;新元素4&lt;/p&gt;\" );\n\n删除元素\n//删除元素方法很简单，先选中，然后调用 remove 方法，比如：$( \"#content1\" ).remove()\n\n替换元素内容\n//先选中，然后调用 html 方法，更新元素内部的html，比如：$( \"#content2\" ).html(`&lt;p id='target3'&gt;新元素2222&lt;/p&gt;`)//类似 浏览器内置的 元素对象的 innerHTML 方法//调用 text 方法，更新元素内部的文本内容，比如：$( \"#target2\" ).text(`新元素22222`)//类似 浏览器内置的 元素对象的 innerText 方法\n\n元素值操作\n//调用 val() 方法，可以获取或者设置一些元素的值，比如 input、select、textarea类似 HtmlElement 的 value 属性的作用,比如:// 获取 id 为 username 的元素的值let username = $('#username').val()// 设置 id 为 username 的元素的值$('#username').val('byhy')\n\n\n元素属性操作：\n\n获取元素属性\n//attr() 可以用来获取元素的属性，类似浏览器内置的 元素对象的getAttribute() 方法,返回值都是字符串的形式,如下：&lt;a id=\"hey\"   style='color:green;font-size: 2rem;'    href=\"/\"   class='nav nav-item'  attr1='自定义属性'&gt;  一个链接&lt;/a&gt;&lt;script&gt;let a = $('a')console.log(a.attr('id'))console.log(a.attr('style'))console.log(a.attr('href'))console.log(a.attr('class'))console.log(a.attr('attr1'))&lt;/script&gt;\n\n设置元素属性\n//attr() 如果提供第2个参数，就是用来设置元素的属性，类似浏览器内置的 元素对象的setAttribute() 方法,比如&lt;a id=\"hey\" style='color:green'  href=\"/\" attr1='自定义属性'&gt;一个链接&lt;/a&gt;&lt;script&gt;let a = $('a')a.attr('id', 'new-hey')a.attr('style' , 'color:blue')a.attr('href', 'https://www.byhy.net')a.attr('attr1', '自定义属性2')&lt;/script&gt;\n\n删除元素属性\n//removeAttr()方法 用来删除元素的属性,类似浏览器内置的 元素对象的removeAttribute() 方法,比如a.removeAttr('id')a.removeAttr('style')a.removeAttr('href')a.removeAttr('attr1')\n\nstyle设置\n//css()方法 用来设置元素的style里面的某个样式属性,比如a.css('color', 'red')//如果是点击某个元素，就设置这个被点击元素的style属性，可以这样写&lt;a id=\"hey\"   style='color:green;font-size: 2rem;'    href=\"#\"&gt;  一个链接&lt;/a&gt;&lt;script&gt;  $('a').click(function () {    $(this).css('color', 'red');  });&lt;/script&gt;// $(this) 代表了 触发这个点击事件的 对象，并且封装为一个JQuery对象，这样可以方便的使用JQuery对象更便捷方法。否则，如果我们只用 this，就得这样写$('.a').click(function () {  this.style.color = \"red\"});\n\n\n和服务端通讯：\n\nXHR/AJAX：用户访问网页，包括网页里面内嵌的 CSS/js/图片 等等资源，通常是浏览器直接获取的，这种获取请求的HTTP被称之为 同步请求；而浏览器执行网页包含的js代码的过程，有时js代码还要到服务端 提交、获取数据， 这样的请求被称之为 异步请求，异步请求，典型的出现在前后端分离的web系统中。浏览器的js环境内置了一个 XMLHttpRequest 类型，简称 `XHR，可以这样创建一个 XHR 对象\nvar xhr = new XMLHttpRequest();//XHR 对象 有属性方法，支持 浏览器页面代码 和 服务端之间的通信。这种使用 XMLHttpRequest 对象 和 服务端之间的 通信技术，是一种异步的通信方式。而且开始的那几年，这种方式传输数据，使用的序列化方法主要是 XML， 所以又被称之为 AJAX (Asynchronous JavaScript And XML) 方式。使用 浏览器原生的 XMLHttpRequest 对象收发消息，可以点击这里了解。缺点是：写起来比较麻烦，所以目前并不推荐使用。现在比较多的用法是： 使用 jQuery库 ，或者 ES6引入的 fetch API,这里介绍 使用 jQuery库 和服务端通信\n\n前后端API接口：当我们的js代码要服务端异步通信时，HTTP请求访问的服务端要获取的 不是像 HTML/CSS/JS 这样的静态文件资源，往往是要求服务端程序进行数据库操作后，再进行代码处理，返回的数据。这样的异步请求，往往被称为 API请求提供这种服务的后端，被称为 API 服务端这种服务接口，被称为 API 接口 。 该接口由系统设计者设计定义，通常会提供接口说明文档，针对该接口测试服务端实现、客户端实现，就是 大家经常听说的 API接口测试。\n后端实现对 静态文件的访问服务 和 动态API请求服务，往往不是一个程序。\n比如，静态文件是 nginx 提供的服务，API则是单独开发的业务服务程序\n系统设计者在设计 API 接口消息时， 规定的 API 消息的 URL 路径会有明显的特征，比如都是以 /api 开头这样，后端可以配置哪些url访问请求是针对API接口的，转发为API服务。live Server有代理配置项，可以设置转发规则如下配置\n\"liveServer.settings.proxy\": {  \"enable\": true,  \"baseUri\": \"/api\",  \"proxyUri\": \"http://127.0.0.1:80/api\"}//其中 baseUri 就是配置什么样的请求是要转发给API服务的,这里 /api ， 就是把 /api 开头的 http请求 都转给 bysms系统处理，因为 bysms系统服务的IP和端口 是 127.0.0.1:80 ，所以 proxyUri 的值为 http://127.0.0.1:80/api ，也可以写成 http://127.0.0.1/api,注意： http://127.0.0.1:80/api 后面的部分 /api 不能少，否则如果是 http://127.0.0.1:80 ， 发送的url /api/customer ，到了 服务后端 就变成了 /customer\n\njQuery构建请求消息：可以使用jQuery库里面的 ajax()方法 和服务端进行HTTP消息的收放。\n//请求方法：典型的ajax()方法，接收一个settings参数，该参数是一个PlainObject类型， 可以把它当作 Object 来用，可以在里面设定 XHR（AJAX）请求的数据 ， 包括 请求方法、url、消息头和消息体，比如，要发送 get 请求，可以使用这样的代码$.ajax({    type: 'GET',          url : '/api/mgr/signin',  })//这里settings参数包含了两个键值对数据：type 是 HTTP方法，比如 GET,POST,PUT,DELETE,HEAD 等等url 是 请求的url地址，比如这里就是 /api/mgr/signin ，注意：这里url没有前面的 http://IP:端口 这部分，表示前面的这部分和当前网页前面的这部分相同。下面是是POST请求的一个代码示例$.ajax({    type: 'POST',          url : '/api/mgr/signin',   data: {    username:'byhy',    password:'abc',  }})//这里 data 是请求消息体，如果请求的方法是get、post，还有简便写法，如下$.get('/api/mgr/signin')$.post('/api/mgr/signin',      {        username:'byhy',        password:'abc'      })// 或者$.get({          url : '/api/mgr/signin',  })$.post({       url : '/api/mgr/signin',   data: {    username:'byhy',    password:'abc',  }})\n\nurl 和 url参数：可以使用浏览器内置的 URLSearchParams 类型。URLSearchParams对象的方法 toString ,可以将对象序列化为 urlencoded 格式，比如：\nvar queryStr = new URLSearchParams({code:'6000001', time:'2022-02-23' }).toString()$.get(`http://localhost/api/stock?${queryStr}`)//也可以使用 jQuery 的 param 方法var queryStr = $.param({code:'6000001', time:'2022-02-23' })$.get(`http://localhost/api/stock?${queryStr}`)\n\n消息头：jQuery 发送http请求要定制一些消息头，可以通过ajax方法的settings参数里面的 headers 属性设置，如下\n$.ajax({    url: '/api/something',  type: 'GET',   headers: {\"X-Test-Header\": \"test-value\"}})\n\ncontentTypeajax方法的参数对象 contentType 设置消息头 contentType 的值\n缺省为： application/x-www-form-urlencoded; charset=UTF-8\n可以改为其它的，比如\n$.ajax({  url: '/api/mgr/signin',          type: 'POST',         contentType : 'application/json',   data: JSON.stringify({ username: 'byhy', password:'abc'}),})\n\n消息体jQuery的请求消息体都是参数对象 settings的 data 属性中设置的，该属性的值可以是一个 Object 或者 字符串，urlencode 格式，消息体也可以是 urlencode 格式，同样可以使用 URLSearchParams 或者 jQuery的 param 方法。其实，如果使用jQuery发送请求， data参数如果是 Object，缺省行为就是转化为 urlencode格式，所以可以直接传对象，如下\n$.ajax({  // 提交的网址  url: 'http://localhost/api/mgr/signin',          type: 'POST',          data: { username: 'byhy', password:'88888888' }})\n\nJSON 格式现在的API接口消息体 很多是JSON格式的字符串。\n可以使用浏览器js内置对象 JSON\nJSON 的方法 stringify 可以序列化 js对象 为 JSON格式的字符串\n$.ajax({  url: '/api/mgr/signin',          type: 'POST',         contentType : 'application/json',   data: JSON.stringify({ username: 'byhy', password:'88888888'}),})\n\n\njQuery 解析响应消息：解析响应消息的前提是能正确获取到响应消息，如果使用的是jQuery， settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，可以在回调函数的第3个参数 jqXHR 对象获取响应消息的信息，这个jqXHR 类型 是 XMLHTTPRequest 的扩展类型，封装了一些便捷方法。\n\n消息头\n\n\n$.ajax({  url: '/api/mgr/signin',          type: 'POST',   data: 'username=byhy&amp;password=88888888',  // 正确返回  success: function(data, textStatus, xhr) {     // 获取状态码    console.log(textStatus);    // 获取所有消息头    console.log(xhr.getAllResponseHeaders());    // 获取某个消息头    console.log(xhr.getResponseHeader(\"content-length\"));  },  // 错误    error:function (xhr, textStatus, errorThrown ){    console.error(`${xhr.status} \\n${textStatus} \\n${errorThrown }`)  }})//success 请求响应成功后的回调函数,所谓成功就是返回响应消息，回调函数被传入3个参数：data 从服务端返回的数据textStatus 返回的状态文本描述xhr 这是 XMLHttpRequest的扩展类型jqXHR的对象error 请求响应失败后的回调函数//回调函数被传入3个参数：xhr 这是 XMLHttpRequest的扩展类型jqXHR的对象textStatus 返回的错误状态文本描述比如：\"timeout\", \"error\", \"abort\", 等等 \"parsererror\"errorThrown 异常对象文本比如：\"Not Found\" 或者 \"Internal Server Error.\"\n\n\n消息体解析：如果使用的是jQuery，ajax 参数 settings的 success属性函数定义了成功接收到HTTP响应消息的回调函数，回调函数的第1个参数 data 包含了响应的消息体数据。jQuery 会根据响应消息信息（比如 content-type 消息头）猜测对应的数据类型，从而进行相应的处理。比如下面的示例\n$.ajax({  url: '/api/mgr/signin',          type: 'POST',   data: 'username=byhy&amp;password=88888888',  // 正确返回  success: function(data, textStatus, xhr) {     console.log(data)  }})//登录成功后， 服务端返回的响应的 消息头 content-type : application/json 指明了 响应的消息体是json格式，jQuery 会自动反序列化为 js中对应的数据对象， 传递给 data参数。//如果明确知道响应消息体数据格式， 应该设置 ajax 参数 settings 的 dataType 属性说明这个data的类型,比如 设置为 json，$.ajax({  url: '/api/mgr/signin',          type: 'POST',   data: 'username=byhy&amp;password=88888888',  // 响应消息格式 预设为 json,   dataType: 'json',   // 正确返回  success: function(data, textStatus, xhr) {     console.log(data)  }})//dataType 属性值还可以是,xml返回 XML 对象html返回 HTML 字符串text返回消息体字符串\n\nSESSION机制：采用session机制的系统设计，通常session号是认证成功后， 服务端是通过 HTTP的响应头 Set-Cookie 把产生的 sessionid 告诉客户端的。Set-Cookie 是设定服务端要存放在客户端的Cooked数据，这些数据，浏览器会自动保存。后续访问该网站的其它请求，浏览器会自动在HTTP的请求头 Cookie 中携带保存的所有cookie数据。所以，只要已经调用登录接口，获取了sessionid，后续的请求代码，不需要我们自己的代码里面设置。比如\n$.ajax({  url: '/api/mgr/customers?action=list_customer&amp;pagesize=5&amp;pagenum=1',          type: 'GET',   // 响应消息格式 预设为 json,   dataType: 'json',   // 正确返回  success: function(data, textStatus, xhr) {     console.log(data)  }})//如果我们没有登录成功，就执行上面的代码，服务端就会要求认证了。\n\nWeb请求过程剖析\n\n服务器渲染：在服务器那边直接把数据和html整合在一起，统一返回给浏览器，在页面源代码中能看到数据。\n客户端渲染：第一次请求只要一个html骨架。第二次请求拿到数据，进行数据展示，在页面源代码中，看不到的数据。\n\n\n\nHttp协议\n\n分为两块：\n请求\n请求行：有请求方式、请求url地址、协议。\n请求头：放一些服务器要使用的附加信息。\n请求体：一般放一些请求参数。\n\n\n响应\n状态行：有协议、状态码（200成功，302和307临时转移至新url，404找不到该页面，500服务器内部错误，503服务器不可用，一般是被反爬）。\n响应头：放一些客户端要使用的附加信息。\n响应体：服务器返回的真正客户端要用到的内容（HTML、json）等。\n\n\n\n\n请求头中最常见的一些重要内容（爬虫需要）\nUser-Agent：请求载体的身份标识（用啥发送的请求）\nReferer：防盗链（这次请求是从哪个页面来的?反爬会用到）\ncookie：本地字符串数据信息（用户登录信息，反爬的token）\n\n\n响应头中一些重要内容\ncookie：本地字符串数据信息（用户登录信息，反爬的token）\n各种神奇的莫名其妙的字符串（这个需要经验，一般都是token字样，防止各种攻击和反爬）\n\n\n请求方式\nGET：链接地址信息内面直接在？后面带上参数，多个参数用&amp;隔开。如果要将参数进行封装，可以放在一个字典中，通过请求的params参数进行传递。\nPOST：链接地址信息内面不带参数。参数传递有二种方式：一是表单参数，form-data，它是字典形式，使用requests.post(url,data=字典参数)发送请求；二是json参数，也是字典形式，使用requests.post(url,json=字典参数)发送请求。\n\n\n模拟登录的二种方式\ncookie+session鉴权机制\ncookie是由web服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户访问到服务器，都会带上该服务器的cookie信息。一般cookie都是有有效期的，只在浏览器上保存一段规定的时间，一旦超过规定的时间，该cookie就会被系统清除。\nsession将数据存储在服务器中，服务器会为每个用户创建一条session，用户访问服务器的时候需要拿着sessionid去表明自己的身份。\n一般常见于项目没有做前后端分离，通过参数是否是表单形式或者第一次请求地址域名和第二登录请求发送的地址域名是一样的来判断分析。\n返回的时候，在响应头的set-cookie字段中。\n\n\n基于Token的鉴权机制：当客户端使用用户和密码登录认证后，如果服器鉴权成功，就会生成token返回给客户端，客户端后续发送请求时需要携带token，服务器判断token有效性后才会返回数据。一般常见于前后端分离的项目（通过是否是json参数或者第一次请求时的地址域名和第二次登录请求的地址域名不一样来判断分析）。返回的时候，在响应体中。\n\n\n\n\n\nrequests入门python系统自带有from url.request import urlopen模块，能实现网页请求，但使用第三方库requests模块使得网页请求更加简化，特别是在处理一些请求头上面特别简单。\n用pip下载requests模块：pip install requests，实现urllib.request模块的功能，用requests模块发送请求，获取数据\nimport requestsurl = \"https://www.baidu.com\"headers = {    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\"}  # 一般网站都有防爬机制，需要加上User-Agent键，伪装成浏览器发送请求。resp = requests.get(url, headers=headers)resp = requests.get(url)\t# 返回一个Response对象和响应码print(resp)resp.close()运行结果：&lt;Response [200]&gt;# resp作为Response的对象，有很多属性和方法，其中属性content获取网页的字节流，text获取网页的字符串。json方法返回json格式的数据并转换成python的一种类型的数据。# json是一种轻量级的数据交换格式,可以用来传输数据。爬回来的数据使用json格式会使可读性更好。# 爬完记得用close()方法关闭response对象,防止资源泄露,当再次爬取时也会出现报错异常现象。# request.get(url,verify=False) 忽略SSL证书验证,防止报错，Flase表示去掉安全验证。# 响应头中的Referrer Policy: 防止跨站请求伪造(Cross-Site Request Forgery,CSRF)攻击,也就是网页的防爬机制,这时可以考虑在请求头中加入浏览器的User-Agent字段。\n\n\n构建请求url参数：url参数的格式，有个术语叫 urlencoded 格式。使用Requests发送HTTP请求，url里面的参数，通常可以直接写在url里面，但是有的时候，我们的url参数里面有些特殊字符，比如 参数的值就包含了 &amp; 这个符号，那么我们可以把这些参数放到一个字典里面，然后把字典对象传递给 Requests请求方法的 params 参数。\n\n构建请求头消息：每个消息头也就是一种 键值对的格式存放数据，Requests发送这样的数据，只需要将这些键值对的数据填入一个字典。然后使用post或get方法的时候，指定参数 headers 的值为这个字典就可以了。\n\n构建请求体消息：http 的 消息体就是一串字节，里面包含了一些信息。这些信息可能是文本，比如html网页作为消息体，也可能是视频、音频等信息。最常见的消息体格式当然是 表示网页内容的 HTML。Web API接口中，消息体基本都是文本，文本的格式主要是这3种： urlencoded ，json ， XML。注意：消息体采用什么格式，是由 开发人员设计的决定的。Requests库的post方法，参数data指明了，消息体中的数据是什么。如果传入的是字符串类型，Requests 会使用缺省编码 latin-1 编码为字节串放到http消息体中，发送出去。编程语言都有现成的库处理解析 XML、json 这样的数据格式，我们直接拿来使用，而自己定义的格式就难以表达这样复杂的数据格式，而且还要自己写代码在发送前进行格式转化，接收后进行格式解析，非常麻烦。urlencoded 格式消息体就是一种 键值对的格式存放数据，Requests发送这样的数据，当然可以直接把这种格式的字符串传入到data参数里面。json 格式消息体：json 格式 当前被 Web API 接口广泛采用。json 是一种表示数据的语法格式。 它和Python 表示数据的语法非常像。它的优点是：比xml更加简洁、清晰， 所以程序处理起来效率也更高。可以使用json库的dumps方法，构建一个json 格式的字符串，如下\nimport requests,jsonpayload = {    \"Overall\":\"良好\",    \"Progress\":\"30%\",    \"Problems\":[        {            \"No\" : 1,            \"desc\": \"问题1....\"        },        {            \"No\" : 2,            \"desc\": \"问题2....\"        },    ]}r = requests.post(\"http://httpbin.org/post\", data=json.dumps(payload))# 这里是将python数据类型对象转换成json字符串格式，叫序列化。# 也可以将 数据对象 直接 传递给post方法的 json参数，如下r = requests.post(\"http://httpbin.org/post\", json=payload)# 这里是由json参数实际上是由request模块调用了json类进行了json序列化处理。\n\n检查http响应\n\n检查 HTTP 响应 的状态码，直接 通过 reponse对象的 status_code 属性获取\n\n要检查 HTTP 响应 的消息头，直接 通过 reponse对象的 headers 属性获取，response.headers 对象的类型 是 继承自 Dict 字典 类型的一个 类。我们也可以像操作字典一样操作它，比如取出一个元素的值\n\n检查响应消息体，要获取响应的消息体的文本内容，直接通过response对象 的 text 属性即可获取，那么，requests是 以什么编码格式 把HTTP响应消息体中的 字节串 解码 为 字符串的呢？requests 会根据响应消息头（比如 Content-Type）对编码格式做推测。但是有时候，服务端并不一定会在消息头中指定编码格式，这时， requests的推测可能有误，需要我们指定编码格式。可以通过这样的方式指定：\nimport requestsresponse = requests.get('http://mirrors.sohu.com/')response.encoding='utf8'print(response.text)\n\n如果我们要直接获取消息体中的字节串内容，可以使用 content 属性，比如：\nimport requestsresponse = requests.get('http://mirrors.sohu.com/')print(response.content)# 返回的内容既可以是字符串格式:text，也可以是字节串格式:content,两者之间通过encode和decode进行转换，decode默认以UTF-8的编码形式进行转码，也可以手动指定解码所采用的编码形式来进行解码。\n\n当然，如果可以直接对 获取的字节串 bytes对象进行解码，如：\nprint(response.content.decode('utf8'))\n\nAPI 响应的消息体格式，通常以json居多。为了 方便处理 响应消息中json 格式的数据 ，我们通常应该把 json 格式的字符串 转化为 python 中的数据对象。怎么转化？ 前面我们学习过 json库，可以直接使用 json库里面的 loads 函数， 把 json 格式的字符串 转化为 数据对象\nimport requests,jsonresponse = requests.post(\"http://httpbin.org/post\", data={1:1,2:2})obj = json.loads(response.content.decode('utf8'))print(obj)# 这种方式称为反序列化。\n\n\nrequests库为我们提供了更方便的方法，可以使用 Response对象的 json方法，如下：\nresponse = requests.post(\"http://httpbin.org/post\", data={1:1,2:2})obj = response.json()print(obj)\n\n\n\nsessionHTTP 协议规定了， 网站服务端放HTTP响应中 消息头 Set-Cookie 里面的数据， 叫做 cookie 数据， 浏览器客户端 必须保存下来。而且后续访问该网站，必须在 HTTP的请求头 Cookie 中携带保存的所有cookie数据。\n我们在Python代码中如果接收到服务端HTTP响应， 就能构建请求头，完全可以自己处理cookie。但requests库给我们提供一个 Session 类 。通过这个类，无需我们操心， requests库自动帮我们保存服务端返回的 cookie数据， HTTP请求自动在消息头中放入 cookie 数据。如下示例：\nimport requests# 打印HTTP响应消息的函数def printResponse(response):    print('\\n\\n-------- HTTP response * begin -------')    print(response.status_code)    for k, v in response.headers.items():        print(f'{k}: {v}')    print('')    print(response.content.decode('utf8'))    print('-------- HTTP response * end -------\\n\\n')# 创建 Session 对象s = requests.Session()# 通过 Session 对象 发送请求response = s.post(\"http://127.0.0.1/api/mgr/signin\",       data={           'username': 'byhy',           'password': '88888888'       })printResponse(response)# 通过 Session 对象 发送请求response = s.get(\"http://127.0.0.1/api/mgr/customers\",      params={          'action'    :  'list_customer',          'pagesize'  :  10,          'pagenum'   :  1,          'keywords'  :  '',      })printResponse(response)\n\n如果Session对象所有的请求都通过设置的代理进行，可以这样使用：\nimport requestsproxies = {'http': 'http://127.0.0.1:8888'}s = requests.session()s.proxies.update(proxies)s.get(\"http://www.example.com\")\n\n\n\n数据解析三种解析方式：1、re解析；2、bs4解析、3、xpath解析。其中re解析最快，xpath现在最流行，bs4解析最方便，但性能最低。三种方式可以混用，完全以结果做导向，只要能拿到结果，用哪种方案并不重要。\n\n正则表达式：优点：速度快，效率高，准确性高。缺点：上手有点难度。\n\n正则表达式的语法：使用元字符进行排列组合用来匹配字符串。\n\n元字符：具有固定含义的特殊符号，常用元字符：\n1\t.\t匹配除换行符以外的任意字符2\t\\w\t匹配字母或数字或下划线3\t\\s\t匹配任意的空白符4.\t\\d\t匹配数字5.\t\\n\t匹配一个换行符6.\t\\t\t匹配一个制表符7.8.\t^\t匹配字符串的开始9.\t$\t匹配字符串的结束10.11.\t\\W\t匹配非字母或数字或下划线12.\t\\S\t匹配非空白符13.\t\\D\t匹配非数字14.\ta|b\t匹配a或者b15.\t()\t匹配括号内的表达式，也表示一个组16.\t[]\t匹配字符组中的字符17.\t[^]\t匹配除了字符组中字符的所有字符\n\n量词，控制前面的元字符出现的次数\n1.\t*\t重复零次或更多次2.\t+\t重复一次或更多次3.\t?\t重复零次或一次4.\t{n}\t重复n次5.\t{n,}\t重复n次或更多次6.\t{n,m}\t重复n到m次\n\n贪婪配置和惰性匹配，这是爬虫用得最多的就是这个惰性匹配\n1.\t.*\t贪婪匹配2.\t.*?\t惰性匹配\n\nre模块，python内置的模块。\n# findall，匹配字符串中所有符合正则的内容，返回的是列表。import relst=re.findall(r'\\d+','我的电话是：13574048sina668，电话是10086')\t# 建议第一个参数前加上rprint(lst)运行结果：['13574048', '668', '10086']# finditer，匹配字符串中所有符合正则的内容，反回的是迭代器，从迭代器中拿到内容要.group()import relst=re.finditer(r'\\d+','我的电话是：13574048sina668，电话是10086')for match in lst:    print(match.group())运行结果：1357404866810086# 使用返回迭代器的效率要比使用列表高得多。# 使用search，找到一个结果就返回，返回的是match对象，拿数据用.group()import relst=re.search(r'\\d+','我的电话是：13574048sina668，电话是10086')print(lst.group())运行结果：13574048#match,从头开始匹配，第一个不符合就会报错，找到第一个就会返回。import relst=re.match(r'\\d+','13574048sina668，电话是10086')print(lst.group())运行结果：13574048# 预加载正则表达式，方便多次调用。import res=\"\"\"\"     &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;\"\"\"obj=re.compile(r\"&lt;div class='.*?&gt;&lt;span id='.*?'&gt;.*?&lt;/span&gt;&lt;/div&gt;\",re.S)ret=obj.findall(s)print(ret)运行结果：[\"&lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;\", \"&lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;\"]# (?P&lt;分组名字&gt;正则)\t可以单独从正则匹配的内容中进一步提取内容。import res=\"\"\"\"     &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;\"\"\"obj=re.compile(r\"&lt;div class='.*?&gt;&lt;span id='(?P&lt;id&gt;.*?)'&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;\",re.S)# re.S中，S是一个标志符，让.能匹配换行符。使用?P&lt;id&gt;的目的是使迭代器循环调用时通过.group(分组名)输出结果。ret=obj.findall(s)print(ret)  运行结果：[('1', '李继晓'), ('2', '小李飞刀')]\n\nbs4解析：通过标签和属性去定位页面上的内容。\n\n用法：\n# pip install bs4from bs4 import BeautifulSoupimport requestss=\"\"\"\"     &lt;div class='jay'&gt;&lt;span id='1'&gt;李继晓&lt;/span&gt;&lt;/div&gt;    &lt;div class='tory'&gt;&lt;span id='2'&gt;小李飞刀&lt;/span&gt;&lt;/div&gt;\"\"\"# 1.将页面源代码交给Beautifulsoup进行处理，生成bs对象。soup=BeautifulSoup(s,\"html.parser\")\t# 指定html解析器，明确指出将返回结果转换成html格式，不加这个参数也不会报错，但会出现警告，并将返回结果转换成html来处理。# 2.从bs对象中查找数据,find_all(标签，属性=值)。resule=soup.find_all('div',class_='jay')print(resule)\t# 返回的是列表，但列表的内容格式是html格式，可继续使用fina_all(标签，属性=值)print(type(result[0]))\t# 注意列表的元素类型为&lt;class 'bs4.element.Tag'&gt;result1=result[0].find_all('span') print(result1)result2=result1[0].text # 通过text最后取标签的结果。result3=result1[0].get(\"id\") # 通过get能取到标签内的指定属性的值print(result2)print(result3)运行结果：[&lt;div class=\"jay\"&gt;&lt;span id=\"1\"&gt;李继晓&lt;/span&gt;&lt;/div&gt;]&lt;class 'bs4.element.Tag'&gt;[&lt;span id=\"1\"&gt;李继晓&lt;/span&gt;]李继晓1\n\nxpath：是在xml文档中搜索内容的一门语言\n\nhtml是xml的一个子集，xpath将标签当作一个结点处理，标签内的标签称为子结点，标签外的标签称为父结点。\n\n使用xpath需要安装lxml模块：pip install lxml\n\n使用方法：\n选取节点：使用路径表达式来选择XML文档中的节点或者节点集。这些路径表达式和我们在常规的电脑系统中看到的表达式非常相似\n\n\n\n路径表达式\n描述\n\n\n\nnodename\n选取此节点的所有子节点\n\n\n/\n从根节点选择\n\n\n//\n从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置\n\n\n.\n选择当前节点\n\n\n..\n选择当前节点的父节点\n\n\n@\n选择属性\n\n\n条件过滤：查找某个特定的的节点或包含某个指定的值的节点，被嵌在方括号中\n\n\n\n路径表达式\n结果\n\n\n\n/ul/li[1]\n选择属于ul子元素的第一个li元素\n\n\n/ul/li[last()]\n选择属于ul子元素的最后一个li元素\n\n\n/ul/li[last()-1]\n选择属于ul子元素的倒数第二个li元素\n\n\n/ul/li[position()&lt;3]\n选取最前面的两个属于ul元素的子元素的li元素\n\n\n//div[@attr]\n选取所有拥有名为attr属性的div元素\n\n\n//div[@attr=‘leng’]\n选取所有div元素，且这些元素拥有值为leng的attr属性\n\n\n选择未知节点：通配符可用来选取未知的XML元素\n\n\n\n通配符\n描述/结果\n\n\n\n*\n匹配任何元素节点\n\n\n@*\n匹配任何属性节点\n\n\n/div/*\n选取div元素的所有子元素\n\n\n//*\n选取文档中的所有元素\n\n\nhtml/node()/a/@*\n选择html下面任意节点下的a节点的所有属性\n\n\n//div[@*]\n选取所有带有属性的div元素\n\n\n//li[contains(@attr,100)]\n选取属性为attr，并且值为100的所有元素。contains属于模糊匹配\n\n\n//*[contains(text(),’当’)]\n选择所有元素中文本中包含有“当”字符的元素\n\n\n获取数据：1、获取文本数据，选取节点后要获取节点中的文本内容，使用text()方法；2、获取属性值，@属性\n\n\n\n表达式\n描述\n\n\n\n/div/ul/li/span/text()\n获取span标签中的文本内容\n\n\n/div//li/a/@herf\n获取a标签中的herf属性\n\n\n以上就是xpath的语法内容，在运用到Python抓取时要先转换为XML，如下示例\n# from lxml import etree  导入etree模块，lxml库是专门用来解析XML文档的库# tree=etree.XML()\t创建etree对象# tree.xpath()\t调用xpath方法from lxml import etrees=\"\"\"&lt;root&gt;    &lt;book&gt;        &lt;title&gt;Python&lt;/title&gt;        &lt;author&gt;Guido van Rossum&lt;/author&gt;        &lt;year&gt;1991&lt;/year&gt;    &lt;/book&gt;    &lt;book&gt;        &lt;title&gt;Java&lt;/title&gt;        &lt;author&gt;James Gosling&lt;/author&gt;        &lt;year&gt;        \t&lt;a href=\"https://www.java.com\"&gt;2000&lt;/a&gt;            &lt;a href=\"https://www.oracle.com\"&gt;2005&lt;/a&gt;            &lt;a href=\"https://www.openjdk.java.net\"&gt;2011&lt;/a&gt;            &lt;a href=\"maodian\"&gt;锚点&lt;/a&gt;            &lt;title&gt;Python&lt;/title&gt;        &lt;/year&gt;    &lt;/book&gt;&lt;/root&gt;\"\"\"tree=etree.XML(s)print(type(tree))result=tree.xpath('/root')\t# /表示层级关系，第一个/是根节点，返回一个结点的迭代器result1=tree.xpath('/root/book/title/text()')\t#text()返回结点内容。print(result)print(result1)result2=tree.xpath(\"//title/text()\")\t# //后代结点。print(result2)result3=tree.xpath(\"/root/book/*/title/text()\")\t# 任意的节点，通配符。print(result3)result4=tree.xpath(\"/root/book/year/a[1]/text()\")\t# 通过索引拿到第一个内容。print(result4)result5=tree.xpath(\"/root/book/year/a[@href='maodian']/text()\") # 通过[@取属性=值]来取到内容print(result5)result6=tree.xpath(\"/root/book/year/a[1]/@href\")\t# 通过@属性，取到标签内的属性值。print(result6)输出结果：&lt;class 'lxml.etree._Element'&gt;&lt;class 'lxml.etree._Element'&gt;[&lt;Element root at 0x1bf98c6a8c0&gt;]['Python', 'Java']['Python', 'Java', 'Python']['Python']['2000']['锚点']['https://www.java.com']\n\nrequests进阶\n当网站需要用户名和密码进行登录时：\n\n登录后会得到cookie，当再次请求网站其它url时，就会带着cookie去请求，不需要再次输入登录名有密码，这时候写代码就得把登录和cookie这两操作连起来，这时候就可以使用session。\n\nsession意思是会话，可以认为是一连串的请求，在这个过程中cookie不会丢失。\nimport requestssession=requests.session()\t#可获取session对象data={    \"loginName\":\"13574048668\",    \"passwrod\":\"741209\"}# 1.登录url=\"http://zhcxapp.hnrcc.bank/hnhccp/\"resp=session.post(url,data=data)\t# 通过session对象进行数据提交。print(resp.text)\t# 显示返回数据print(resp.cookies)\t# 显示cokkies内容# 2.拿登录进去后的其它url链接数据# 刚才哪个session中是有cookie的，不要使用requests.get()请求，否则拿不到数据。resp1=session.get(\"http://zhcxapp.hnrcc.bank/hnhccp/file?id=123\")print(resp1.json())\t# 这里返回的数据一般是json格式的，不使用test而使用json会显示得更友好些。\n\n代理是通过第三方的一个机器去发送请求，用法：\n  import requests  # 从https://www.zdaye.com/free/站点找哪些透明或者普匿的ip地址:端口，放在一个字典中。  proxies={    'http': '111.1.61.47:3128',    'https': '119.3.113.151:9094'  }  url=\"http://www.baidu.com\"  resp=requests.get(url,proxies=proxies)\t# 调用代理参数  print(resp)  运行结果：&lt;Response [200]&gt;## 多线程+ 操作系统每次运行一个程序的时侯，都会给这个程序准备一块内存，存放程序执行过程中的变量，这个内存区域可以称为进程。在进程内面有一个或多个线程，来帮助我们工作。所在进程与线程的关系是：+ 进程是资源单位，线程是执行单位。程序运行的时候必须创建线程去执行。好比一个公司，公司是资源单位，而公司运转的话必须要有员工，员工就是线程，公司的一个项目需要多个人去完成的时候，多个人就是多线程。如果线程没有了，进程也就没用了。+ 每一个进程至少需要一个线程，CPU在工作的时候，调度的是一个线程。启动每一个程序，默认都会有一个主线程。+ 实现多线程的二种方法：  ```py  1. 第一种方法，创建线程实例对象方式运行：  from threading import Thread\t# 线程类  def my_func():      for i in range(1000):       print(f\"my_func\",i)  if __name__ == '__main__':      t1 = Thread(target=my_func) # 创建一个线程对象，并给线程安排任务      t1.start()\t# 开始执行该线程，实质是给多线程对象加了一个可以开始工作状态，具体执行时间由CPU决定      for i in range(1000):          print(f\"main!\",i)  运行结果描述：主线程运行到t.start()后，就会有二条线程同时在运行，my_func函数和主入口函数main交互输出结果。    2.\t自己定义一个类，继承线程类，重写线程类的run()方法：  from threading import Thread  class MyThread(Thread):      def run(self):\t# 当线程被执行的时候，被执行的就是run()          for i in range(1000):              print(f\"子线程\",i)    if __name__ == '__main__':      t=MyThread()      # t.run()\t这里调用的是函数的run()方法，实际运行时还是单线程      t.start()\t# 这样调用同上面一样，是给多线程添加了可以开始工作的状态，实现了多线程运行      for i in range(1000):          print(f\"主线程!\",i)            # 注意：线程传的参数必须是元组  1.创建实例对象方法  from threading import Thread\t  def my_func(name):      for i in range(1000):       print(f\"my_func\",i,name)  if __name__ == '__main__':      t1 = Thread(target=my_func,args=(\"李继晓\",)) # 参数是元组，只有一个参数时要用,区分      t1.start()\t      t1 = Thread(target=my_func,args=(\"小李飞刀\",))       t1.start()  2.定义一个类，继续父类方法  from threading import Thread    class MyThread(Thread):      def __init__(self, name):\t# 在构造函数中传递参数          super().__init__()  # 需要调用父类 Thread 的初始化方法，不调用的话某些情况下会出现问题          self.name = name        def run(self):          for i in range(1000):              print(f\"子线程 {self.name}\", i)    if __name__ == '__main__':      t = MyThread(\"李继晓\")      t.start()      t1 = MyThread(\"小李飞刀\")      t1.start()\n\n多进程\n相对于线程，多进程使用较少，因为开辟进程所消耗的内存资源要比线程大得多。\n\n创建方法与创建子线程的二种方法相似:\n1. 第一种方法，创建进程实例对象方式运行：from multiprocessing import Processdef my_func():    for i in range(1000):        print(f\"子进程\",i)if __name__ == '__main__':    p=Process(target=my_func)    p.start()    for i in range(1000):        print(f\"主进程!\",i)        2.\t自己定义一个类，继承线程类，重写线程类的run()方法：from multiprocessing import Processclass MyProcess(Thread):    def run(self):\t# 当线程被执行的时候，被执行的就是run()        for i in range(1000):            print(f\"子进程\",i)if __name__ == '__main__':    p=MyThread()    # p.run()\t这里调用的是函数的run()方法，实际运行时还是单进程    p.start()\t# 这样调用同上面一样，是给多进程添加了可以开始工作的状态，实现了多进程运行    for i in range(1000):        print(f\"主进程!\",i)\n\n线程池和进程池\n线程池：一次性开辟一些线程，我们用户直接给线程池子提交任务，线程任务的调度交给线程池来完成。\n\n方法：\nfrom concurrent.futures import ThreadPoolExecutor #创建线程池from concurrent.futures import ProcessPoolExecutor #创建进程池def fun(name):    for i in range(1000):        print(name,i)if __name__ == '__main__':    # 创建线程池    with ThreadPoolExecutor(50) as executor:        # 向线程池提交任务        for i in range(100):\t# 制定任务完成的次数            executor.submit(fun, f\"在运行线程{i}\")            # 等待线程池中的任务全部执行完毕，才继续执行（守护）        print(\"线程池执行完毕\")# 该段代码会运行100个线程对象（任务的次数），每个线程都运行fun函数，统一交给线程池来调度运行，而线程池由50个线程来分配运行，一直到运行完成后才会打印出执行完毕的结果。\n\n协程\n一般情况下，sleep(3)方法、input()方法、网络请求返回数据之前、程序处于IO操作的时候，线程会处于阻塞状态，阻塞状态下，CPU是不为我工作的。为解决这种问题，引入了协程。\n\n协程：当程序遇见了阻塞操作的时候，可以选择性地切换到其它任务上，让CPU继续为我工作，实现充分地将CPU绑定在我的程序上面。\n\n在微观上，协程是一个任务一个任务的进行切换，切换条件就是会产生阻塞的操作；在宏观上，我们看到的其实是多个任务一起在执行，所以协程就是多任务异步操作。都是在单线程条件下发生。\nimport asyncio\t# 导入异步模块async def test():\t# 加上async后，这个函数变成了异步函数，需要用异步模块的run()方法调用    print(\"Hello, world!\")if __name__ == \"__main__\":    asyncio.run(test()) # run()运行事件循环，test()将在事件循环中并发执行    --------------------------------------------------------------------------import asyncioasync def test1():    await asyncio.sleep(2)    print(\"Hello, world1!\")async def test2():    await asyncio.sleep(3)    print(\"Hello, world2!\")async def test3():    await asyncio.sleep(4)    print(\"Hello, world3!\")async def main():    tasks = [asyncio.create_task(test1()), asyncio.create_task(test2()), asyncio.create_task(test3())]    await asyncio.wait(tasks)\t# 等待所有任务完成if __name__ == \"__main__\":    # asyncio.create_task() 函数会将协程包装成任务对象，并安排它们在事件循环中并发执行。    asyncio.run(main()) # asyncio.run() 会运行事件循环，直到 asyncio.wait(main()) 完成运行结果：Hello, world1!Hello, world2!Hello, world3![Done] exited with code=0 in 4.334 seconds\n\nawait的含义：是Python异步编程中的核心关键字，主要含义和作用如下：\n\n执行权让出机制\n\n表示”等待这个异步操作完成”\n\n会让出当前协程的执行权，使事件循环可以执行其他任务\n\n不会阻塞整个线程，仅暂停当前协程\n\n\n\n使用限制\n\n必须用在async def定义的异步函数内面使用\n\n后面必须跟一个”可等待对象”（Awaitable），如：\n\n协程（coroutine）\n任务（Task）\nFuture对象\n\n\n\n\n典型应用场景\n\n网络请求（HTTP/TCP）\n文件IO操作\n数据库查询\n睡眠延迟（await asyncio.sleep(1)）\n\n\n注意事项\n\n忘记写await会导致协程不执行（常见错误）\n在错误位置使用会报错：SyntaxError: 'await' outside async function\n合理使用可以大幅提升I/O密集型程序的并发性能\n\n\n\n\n异步http请求aiohttp模块\n\n\nrequests.get()是同步的代码，异步操作要改成aiohttp。安装方法：pip install aiohttp。\nimport aiohttpimport asyncioasync def save_webpage():    async with aiohttp.ClientSession() as session:\t# 相当于是同步的requests，前面加async是语法规定        print(type(session))\t# 返回的是异步对象        async with session.get('http://www.baidu.com/') as response:            print(type(response))\t# 返回的是异步的对象的结果            # with open('test.txt', 'w', encoding='utf-8') as f:            #     f.write(await response.text())  注意异步是text()，同步是text,细微差别，写取内容是异步的，要加上await挂起。            运行结果：            &lt;class 'aiohttp.client.ClientSession'&gt;            &lt;class 'aiohttp.client_reqrep.ClientResponse'&gt;\n\n\n在链接非常多的情况下，多任务异步比同步下载要快得多，实践过程中，抓取4000多个小说的链接内容，同步花了26分钟左右，而同步仅用时56秒就完成了。\n\n\nm3u8解析\nm3u8是一个文本文件，本身并不是媒体文件，里面是以UTF-8格式记录的音频视频资源，以及这些资源的播放地址。m3u8相当于视频音频资源的种子文件。\nM3U8 文件是一个UTF-8编码的文本文件，所以用任何文本工具都能打开，但是如果用文本打开，你会发现里面记录的都是视频或者音频资源的访问路径。基于M3U8文件格式播放，你需要专门支持流媒体播放的播放器。可能有人发现.M3U文件也是这样的，是的，.M3U和 .M3U8文件的唯一区别就是一个是UTF8编码过的。\n视频播放过程：现在的视频网站采用的是流媒体传输协议，就是将一段视频切成无数个小段，这几个小段就是ts格式的视频文件，一段一段的网站上播放。一个视频播放的全过程如下：\n服务器采集编码传输视频到切片器\n切片器对视频创建**索引文件，并且切割成n个ts文件**\n这2个文件传输到http服务器上\n网站/客户端根据索引文件查找http服务器上的ts文件，连续播放这n个ts文件，就可以了。\n\n\n索引文件非常重要，索引文件里面存储着ts文件的网络url链接，网站需要拿到索引文件，去按照url链接下载在http服务器中的ts文件。\n索引文件就是m3u8文件。现在大部分视频网站传输都是采用这种方法，所以，也就是说，如果你在观看网页视频的时候，能够弄到加载该视频的m3u8文件，那么再配合一些工具，就能下载该视频了。\n爬虫下载过程：\n拿到页面源代码\n从源代码中提取到m3u8的url\n下载m3u8\n读取m3u8，获取ts下载链接，下载视频\n合并视频\n\n\n\n初始化搜狗浏览器\n搜狗浏览器使用的是chromed内核，确定搜狗使用的是哪种版本后去下载对应版本的webdriver驱动，然后使用下面的代码：\n\nfrom selenium import webdriverfrom selenium.webdriver.chrome.service import Service# 设置搜狗浏览器的路径sogou_browser_path = r\"D:\\SogouExplorer\\SogouExplorer.exe\"options = webdriver.ChromeOptions()options.binary_location = sogou_browser_path# 初始化浏览器驱动driver = webdriver.Chrome(options=options,service=Service(r\"D:\\vscode\\chromedriver.exe\"))# 调用WebDriver 对象的get方法 可以让浏览器打开指定网址driver.get('http://zhcxapp.hnrcc.bank/hnhccp/')\n\n\n浏览器内核版本查看地址：https://liulanmi.com/labs/core.html\n\n谷歌浏览器驱动版本下载地址：\n\n\n老版本地址：https://chromedriver.storage.googleapis.com/index.html\n\n\n\n新版本地址：https://registry.npmmirror.com/binary.html?path=chrome-for-testing/\n\n\n\n统一浏览器内核版本：108.0.5359.95\n\n\n\n人行Pisa能正常运行的内核版本：80.0.3987.87\n\n\n\nEdge浏览器目前内核版本：134.0.0.0\n\n\n\n谷歌浏览器目前内核版本：135.0.0.0\n\n\n\nselenium自动化\n关于验证码：\n直接把浏览器内面的cookie拿出来直接用\n手动编写验证码识别的功能（深度学习）\n第三方打码平台（收费），超级鹰、图鉴\n\n\n\n# 学习参考资料1. 下载谷歌浏览器驱动查看谷歌浏览器的版本 设置--&gt;帮助--&gt;关于Chrome进入网站下载 https://npmmirror.com 选择 Selenium 镜像: https://npmmirror.com/mirrors/selenium/ 对应我们浏览器的版本下载Selenium版本新建python工程 将下载解压后的exe文件拖入根目录下案例 百度查询⬇#encoding:utf-8from selenium import webdriver​# 调用环境变量指定的PhantomJS浏览器创建浏览器对象from selenium.webdriver.common.by import By​driver = webdriver.Chrome(\"./chromedriver.exe\")# get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)driver.get(\"http://www.baidu.com/\")html = driver.page_source  获取整个页面源代码数据​kw = driver.find_element(By.ID,\"kw\")kw.send_keys(\"丢丢\")​# driver.find_element(By.CSS_SELECTOR,\"#su\").click()su = driver.find_element(By.ID,\"su\").click()su.click()# driver对象的相关属性：1.current_url：当前url地址2.title：页面标题3.page_source：页面html代码（渲染以后的）4.window_handler：获取浏览器上所有的窗口句柄5.current_window_handler：获取当前窗口句柄#一.元素定位1. 获取单个元素driver.find_element(By.ID，\"inputorigina”）driver.find_element(By.CSS_SELECTOR，\"#inputoriginal\"）driver.find_element(By.TAG_NAME，\"div\"）driver.find_element（By.NAME，\"username\")driver.find_element(By.LINK_TEXT,“下一页”）driver.find_element(By.XPATH,\"//*[@id='kw']\")  #会以上一种就可以了，现在主流是xpath定位               2. 如果找不到相应的元素会报错selenium.common.exceptions.NosuchElementException: Message:no such element:Unable to 7ocate element:XX3. 获取多个元素driver.find_elements(By.ID，\"inputoriginal”）driver.findelements(By.CSS_SELECTOR，“inputoriginal”）driver.find_elements(By.TAG_NAME,“div\")driver.findelements(By.NAME，“username”)driver.find_elements(By.LINK_TEXT，\"下一页”）4. 内容获取与操作    1. size 返回元素大小    2. text 获取元素的文本 &lt;div&gt;hello&lt;/div&gt;    3. title 获取页面的title    4. current_url 获取当前页面URL    5. get_attribute() 获取属性值&lt;a href=\"www.baidu.com\"&gt;&lt;/a&gt;    6. is_display() 判断元素是否可见    7. is_enabled() 判断元素是否可用    8. driver.page_source  获取整个页面数据    9. tagname 获取标签名\t10. parent 获取父级标签   \t11. click() 点击元素\t12. clear() 清空表单\t13. send_keys() 输入内容\t# 示例\t\t   from datetime import time            from selenium import webdriver            from selenium.webdriver.common.by import By            driver = webdriver.Chrome()            driver.get('http://www.baidu.com')                     time.sleep(10)            li_list=driver.find_elements(By.XPATH,'//ul[@class=\"replylist\"]/li')              for item in li_list                 title=item.find_element(By.XPATH,'./div/[@class=\"title\"]/h1').text #通过xpath方式\t\t\t\t\t\t\t找到的元素对象，可以继续使用xpath语法在元素中继续搜索目标，最后显示出文本。             driver.quit()        5. 窗口操作    1. maximize_window() 窗口最大化    2. set_window_size(100,100) 浏览器大小 设置浏览器的宽高(像素点)    3. set_window_position(300,200) 浏览器位置 设置浏览器位置    4. back() 后退    5. forward() 前进    6. refresh() 刷新    7. close() 关闭浏览器按钮(关闭单个窗口)    8. quit() 关闭webDriver启动的窗口6. 访问有道翻译网站，输入单词，并获取翻译后的内容#encoding:utf-8from datetime import time​from selenium import webdriver# 调用环境变量指定的PhantomJS浏览器创建浏览器对象from selenium.webdriver.common.by import By​driver = webdriver.Chrome(\"./chromedriver.exe\")# get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)driver.get(\"https://fanyi.youdao.com/\")time.sleep(4)# 获取输入框input = driver.find_element(By.ID,\"inputOriginal\")# 输入内容input.send_keys(\"hello\")# 获取翻译按钮tbtn = driver.find_element(By.ID,\"transMachine\")# 先获取遮挡的广告条 点击关闭按钮close_btn = driver.find_element(By.CSS_SELECTOR,\".guide-con .guide-close\")close_btn.click()# 点击翻译tbtn.click()# 获取翻译后的内容transTarget = driver.find_element(By.ID,\"transTarget\")print(transTarget.text)7. 爬当当网书籍的数据#encoding:utf-8from datetime import time​from selenium import webdriver# 调用环境变量指定的PhantomJS浏览器创建浏览器对象from selenium.webdriver.common.by import By​driver = webdriver.Chrome(\"./chromedriver.exe\")driver.implicitly_wait(30)  # 隐式等待30秒，针对webdriver元素对象的所有查询，全局有效。# get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)driver.get(\"https://www.dangdang.com/\")driver.maximize_window()# 获取输入框key = driver.find_element(By.ID,\"key_S\")key.send_keys(\"科幻\")# 获取搜索框 点击搜索search = driver.find_element(By.CSS_SELECTOR,\"#form_search_new .button\")search.click()# 获取商品标题及价格for i in range(5):  shoplist = driver.find_elements(By.CSS_SELECTOR,\".shoplist li\")  for li in shoplist:    print(li.find_element(By.CSS_SELECTOR,\"a\").get_attribute(\"title\"))    print(li.find_element(By.CSS_SELECTOR,\".search_now_price\").text)​  # 获取下一页的按钮  next = driver.find_element(By.LINK_TEXT,\"下一页\")  next.click()8. 显式等待：显式等待某些情况下找不到时使用from selenium.webdriver.support.ui import WebDriverwaitfrom selenium.webdriver.support import expected_conditions as EC#程序每0.5秒检查，是否满足：标题包含“百度一下”这个条件，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常WebDriverwait（driver，15).until（Ec.title_contains（“百度一下”）#程序每0.5秒检查，是否满足：某定位的元素出现，检查是否满足条件的最长时间为：15秒，超过15秒仍未满足条件则抛出异常WebDriverwait(driver，15）.until（Ec.visibility_of_element_located(By.CSS_SELECTOR，“XX”））9. 隐式等待implicitly_wait(time_to_wait)设置时间单位为秒 例如30秒 implicitly_wait(30) 意思是超过30秒没有定位到一个元素 程序就回抛出异常,期间会一直轮询查找定位元素二. 鼠标及键盘操作:使用ActionChains类，导入：from selenium.webdriver import ActionChains1. 鼠标操作    1. context_click() 右击    2. double_click() 双击    3. drag_and_drop() 拖动，在一个位置按下鼠标，到另一个位置释放    4. move_to_element() 悬停，鼠标移动到某个节点    5. perform()    执行动作\t6.click()  鼠标左击    \t7.click_and_hold\t鼠标左键按下鼠标                                                               8.move_by_offse\t\t鼠标相对当前位置进行移动\t9.release()\t\t释放鼠标                                                               driver.get(\"https://www.baidu.com/\")more = driver.find_element(By.LINK_TEXT,\"更多\")# 将鼠标移动到更多按钮ActionChains(driver).move_to_element(more).perform()案例 打开百度鼠标移动到更多位置#encoding:utf-8from datetime import timefrom selenium import webdriver# 调用环境变量指定的PhantomJS浏览器创建浏览器对象from selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome(\"./chromedriver.exe\")# get方法会一直等到页面被完全加载,然后才会继续程序,通常测试会在这里选择 time.sleep(2)driver.get(\"https://www.baidu.com/\")more = driver.find_element(By.LINK_TEXT,\"更多\")# 将鼠标移动到更多按钮ActionChains(driver).move_to_element(more).perform()2. 键盘操作    1. send_keys（Keys,BACK_SPACE）删除键（Backspace）    2. send_keys（Keys.SPACE）空格键（Space）    3. send_keys（Keys.TAB）制表键（Tab）    4. send_keys（Keys·ESCAPE）回退键（ESC）    5. send_keys（Keys·ENTER）回车键（Enter）    6. send_keys（Keys.CONTROL，'a'）全选（Ctrl+A）    7. send_keys（Keys.CONTROL，'c'）复制（Ctr1+C）from selenium.webdriver.common.keys import Keysdriver.get(\"https://www.baidu.com/\")element = driver.find_element(By.ID,\"kw\")#输入用户名element.send_keys(\"admin1\")#删除1element.send_keys(Keys.BACK_SPACE)#全选element.send_keys(Keys.CONTROL,'a')#复制element.send_keys(Keys.CONTROL,'c')#粘贴element.send_keys(Keys.CONTROL,'v')                                                                三. 窗口滚动条在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载#1.设置]avascritp脚本控制滚动条，（0:左边距；1000：上边距；单位像素）js=\"window.scro11To(0,1000)\"js=\"window.scro11By(0,1000)\"    # 向下滚动1000像素                                         driver.execute_script(js）\t# WebDriver调用js脚本方法\tfor i in range(5):\t\ttime.sleep(random.random()) # 等待0-1秒\t\tjs=\"window.scro11By(0,{})\".format(random.randint(100,300))  #向下滚动100到300像素                 \t  driver.execute_script(js)#2. 使用selenium的滚动元素可见属性,定位到 【查看更多】 的元素\tele=driver.find_element(By.PATH,'//*[@class=\"mostlist\"]') \ttime.sleep(2)                      \tres=ele.location_once_scrolled_into_view                          print(res)\t# 查看滚动之后的座标\tele.click()\t# 点击滚动按钮                      四. 窗口截图自动化脚本是由程序去执行的，因此有时候打印的错误信息并不是十分明确。如果在执行出错的时候对当前窗口截图保存，那么通过图片就可以非常直观地看到出错的原因#截取当前窗口driver.get_screenshot_as_file(\"./demo.png\")                      五. 数据存储将数据写入CSV文件#读写CSV文件import csv#以写入方式打开文件，如果文件不存在则自动创建f = open(\"d:/test.csv\",'w')#获取csvwriter，用于写入csv格式数据writer = csv.writer(f)#写入数据writer.writerow([\"张三\",\"男\",\"1.7\"])#关闭文件f.c1ose() 将数据写到MySql安装模块pip install pymysqlimport pymysq1#创建连接conn = pymysql.connect(host='127.0.0.1',port=3306,user='root',passwd='',db='tkq1',charset='utf8')#创建游标cursor = conn.cursor()#执行SQL，并返回收影响行数effect_row = cursor.execute(\"select * from tb7\")#执行SQL，并返回受影响行数#effect_row = cursor.execute(\"update tb7 set pass= 123’where nid= %s\",(11,))#执行SQL，并返回受影响行数，执行多次#effect_row=cursor.executemanyC\"insert into tb7(user,pass,icnese）values（s,%s,%s）”[（“ui\"，“ulpass”11111)，（“u2”，u2pass”，*22222”)]）#提交，不然无法保存新建或者修改的数据conn.commit()#关闭游标cursor.close()#关闭连接conn.close() 六. 数据分析网站    https://www.heywhale.com/home    https://kaggle.com/ 七.无头浏览器语法chrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')chrome_options.add_argument('--no-sandbox')chrome_options.add_argument('--disable-infobars') #禁止显示浏览器正在受到自动测试软件控制的通知chrome_options.add_experimental_option(\"excludeSwitches\",[\"enable-automation\"]) #排除启用自动化扩展程序的开关，可以防止被网站检测到使用了自动化工具，减少被反爬虫封锁的可能性chrome_options.add_experimental_option(\"userAutomationExtension\",False) #禁用自动化扩展程序，同样是为了避免被网站检测到使用了自动化工具\n\n\n对于浏览器窗口的切换和窗口中的iframe切换的方法：\n\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport time# 初始化 WebDriver，这里以 Chrome 为例driver = webdriver.Chrome()# 手动登录后假设打开了两个窗口# 等待页面加载完成time.sleep(5)# 切换到第1个窗口driver.switch_to.window(driver.window_handles[0])print(\"切换到了第1个窗口\")# 在第1个窗口中执行一些操作# ...（省略具体操作代码）# 切换到第2个窗口driver.switch_to.window(driver.window_handles[1])print(\"切换到了第2个窗口\")# 在第2个窗口中找到第1个 iframe 并切换到它driver.switch_to.frame(driver.find_element(By.XPATH, '第1个 iframe 的 XPATH'))print(\"切换到了第1个 iframe\")# 在第1个 iframe 中找到第2个嵌套的 iframe 并切换到它driver.switch_to.frame(driver.find_element(By.XPATH, '第2个嵌套 iframe 的 XPATH'))print(\"切换到了第2个嵌套的 iframe\")# 在嵌套的 iframe 中执行一些操作element = driver.find_element(By.XPATH, '嵌套 iframe 中元素的 XPATH')element.click()print(\"点击了嵌套 iframe 中的元素\")# 完成操作后，如果需要切换回最外层的窗口，可以使用以下代码driver.switch_to.default_content()print(\"切换回了最外层的窗口\")# 如果需要切换回上一级的 iframe，可以使用以下代码driver.switch_to.parent_frame()print(\"切换回了上一级的 iframe\")# 关闭浏览器driver.quit()---------------------# 窗口切换# 切换到第一个窗口driver.switch_to.window(driver.window_handles[0])print(\"切换到第一个窗口\")time.sleep(5)# 假设在此处进行一些操作...# 切换到第二个窗口if len(driver.window_handles) &gt; 1:    driver.switch_to.window(driver.window_handles[1])    print(\"切换到第二个窗口\")    time.sleep(5)else:    print(\"没有第二个窗口可以切换\")\n\nQt图形界面开发\nPyQt GUI 主要类的层次结构：\n# QObject &lt;= QWidget （组件）## QWidget &lt;= QFrame &lt;= QLabel## QWidget &lt;= QDialog## QWidget &lt;= QAbstracButtom (抽象的按钮)### QAbstracButtom &lt;= QPushButtom### QAbstracButtom &lt;= QCheckBox### QAbstracButtom &lt;= QRadioButtom\n\n一个简单的GUI图开界面：\nfrom PyQt6.QtWidgets import QApplication,QWidget #基本控件位于PyQt6.QtWidgets模块import sysapp=QApplication(sys.argv) #创建应用程序对象，在创建应用程序时需要一个列表对象，sys.argv可用于获取从命令行输入的参数列表window=QWidget() #窗口对象可以是QWidget、QFrame、QDialog类型。对一般小窗口使用QWidget类型即可window.show() #窗口默认是隐藏的，需要调用show函数才能展示app.exec() #让应用程序进入主事件循环中\n\n以面向对象方式实现PyQt GUI 程序：将图形窗口的定义封装成一个窗口类，实现统一调用的过程。可实现代码重用。\nfrom PyQt6.QtWidgets import QApplication,QWidget #基本控件位于PyQt6.QtWidgets模块import sysclass MyWindow(QWidget):  #根据自己需要，也可以将QFrame和QDialog等窗口类作为父类    def __init__(self):\t  #自定义一个窗口类构造函数        super().__init__()        self.initUI()    def initUI(self):\t #该函数用于初始化窗口中的控件，会在构造函数中调用        self.setWindowTitle('My Window')        def main():\t\t#模块中的主函数    app = QApplication(sys.argv)    win = MyWindow()\t#实例化窗口对象    win.show()    app.exec()if __name__ == '__main__':\t#如果当前模块为主模块，则调用主函数启动窗口，加上这段代码是为在模块中方便自己调试代码，当这个模块不作为主模块而被其它模块调用时，以下代码块内容都不会运行    main()\n\n处理事件：在Qt中对事件的处理机制采用的是信号和槽方式，用于对象之间的通信，是Qt库的核心机制。处理事件有三个要素\n\n事件：是用户界面上的控件进行的操作，如点击，键盘动作，又叫信号\n\n事件源：事件发生的场所，指控件\n\n事件处理程者：对控件动作进行响应处理的函数，一般是一个对象某个方法，又叫槽\nfrom PyQt6.QtWidgets import QApplication,QWidget,QLabel,QPushButton #基本控件位于PyQt6.QtWidgets模块import sysclass MyWindow(QWidget):  #根据自己需要，也可以将QFrame和QDialog等窗口类作为父类    def __init__(self):        super().__init__()        self.initUI()    def initUI(self):        self.setGeometry(600, 300,400,300)        self.setWindowTitle('My Window')        self.label = QLabel('Hello PyQt6!', self)\t#创建标签控件是成员变量，因为需要在其它函数中访问该控件。这里是在槽函数中访问该控件的        self.label.move(180, 120)        buttom=QPushButton('OK',self)        buttom.move(170,160)        buttom.clicked.connect(self.click_success) #chicked是一种信号，它是按钮的单击事件，click_success是槽，它是一个事件处理函数，注意在连接槽时，clicked和click_success后面都没有小括号。    def click_success(self):\t#槽，它是一个事件处理函数        sender = self.sender()\t#sender()函数返回发送信号的对象(事件源)，这里就是按钮控件        self.label.setText('Success!')        print(sender.text())\t#打印按钮的文本        def main():    app = QApplication(sys.argv)    win = MyWindow()    win.show()    app.exec()if __name__ == '__main__':    main()\n\n\n鼠标事件：对于控件的事件，将控件信号与槽函数连接起来就可以了，但在处理鼠标或键盘事件时，我们只需要重写QWidget类的一些函数就可以了，因为鼠标和键盘的事件非常特殊，它是QWiget类自带的，本身就带有处理的函数。鼠标事件就是鼠标的信号，有以下三种，实现鼠标事件只需要重写该函数，如下：\n\nmousePressEvent(event) ，鼠标按下，处理鼠标按下时调用的函数，event参数表示鼠标事件对象，保存了鼠标事件的一些信息。\n\nmouseReleaseEvent(event) ，鼠标松开（释放）\n\nmoueMoveEvent(event) ，鼠标移动\nfrom PyQt6.QtWidgets import QApplication,QWidget,QLabelfrom PyQt6.QtCore import Qtimport sysclass MyWindow(QWidget):      def __init__(self):        super().__init__()        self.initUI()    def initUI(self):        self.setGeometry(600, 300,400,300)        self.setWindowTitle('My Window')        self.label = QLabel('Hello PyQt6!', self)        self.label.move(180, 120)           def mousePressEvent(self, event): #重写鼠标按下函数，这也就是一个槽函数，响应鼠标按下的信号，鼠标的信号源就是这个窗口        if event.button() == Qt.MouseButton.LeftButton: #鼠标事件对象event的button()函数返回用户按下的鼠标键            self.label.setText('Left Button Clicked')        elif event.button()==Qt.MouseButton.RightButton:            self.label.setText('Right Button Clicked')        else:            self.label.setText('鼠标未知按下')    def mouseReleaseEvent(self, event): #重写鼠标释放函数        self.label.setText('Mouse Released')        def main():    app = QApplication(sys.argv)    win = MyWindow()    win.show()    app.exec()if __name__ == '__main__':    main()\n\n\n键盘事件：\n\nkeyPressEvent(event)，在按下键盘时调用的函数，event参数表示键盘事件对象，保存了键盘事件的一些信息\n\nkeyReleaseEvent(event)，在释放键盘时调用的函数\nfrom PyQt6.QtWidgets import QApplication,QWidget,QLabelfrom PyQt6.QtCore import Qtimport sysclass MyWindow(QWidget):      def __init__(self):        super().__init__()        self.initUI()    def initUI(self):        self.setGeometry(600, 300,400,300)        self.setWindowTitle('My Window')        self.label = QLabel('Hello PyQt6!', self)        self.label.move(180, 120)           def keyPressEvent(self, event):         self.label.setText('Key Pressed')        print(event.key())  #键盘事件对象的key方法能获取按下的键盘的ascII值    def keyReleaseEvent(self, event):         self.label.setText('Key Released')        def main():    app = QApplication(sys.argv)    win = MyWindow()    win.show()    app.exec()if __name__ == '__main__':    main()\n\n\n布局管理器：\n\n盒子布局管理器：QBoxLayout类，又分为二个子类QVBoxLayout，垂直布局；QHBoxLayout，水平布局\nfrom PyQt6.QtWidgets import QApplication,QWidget,QHBoxLayout,QPushButtonfrom PyQt6.QtCore import Qtimport sysclass MyWindow(QWidget):      def __init__(self):        super().__init__()        self.initUI()    def initUI(self):        self.setGeometry(600, 300,400,300)        self.setWindowTitle('My Window')        hboxLayout=QHBoxLayout(self)        button1=QPushButton('Button 1',self)        button2=QPushButton('Button 2',self)        button3=QPushButton('Button 3',self)        hboxLayout.addWidget(button1)        hboxLayout.addWidget(button2)        hboxLayout.addWidget(button3)        def main():    app = QApplication(sys.argv)    win = MyWindow()    win.show()    app.exec()if __name__ == '__main__':    main()\n\n网格布局管理器：QGridLayout类，由行列组成，我们可以将控件放在指定单元格中。\n\n表单布局管理器：QFormLayout类，表单一般由两列（第1列是标签列，第2列是控件列）和若干行构成，在表单布局中添加控件是通过addRow函数实现。\n\n\n\n常用控件\n\n文本输入控件：单行输入控件，QLineEdit；多行输入控件,QTextEdit\n单选按钮：QRadioButton类，单选按钮在同一组中是互斥的，通过QButtonGroup类可以进行分组，不同组间互不干扰。QButtonGroup类只是单选按钮容器，不属于控件类，不会有任何视觉展示，因此在进行布局管理时还需要使用相应的布局管理器。\n复选框：QCheckBox类，实现多选功能，提供两种状态的开和关。\n列表控件：QlistWidget，提供了一个选项列表供用户选择，给列表添加选项的函数有，addItem(str)，添加一个选项；addItems(list)，一次添加多个选项。\n下拉列表控件：QComboBox类，当列表控件占用空间太大，你希望空间紧凑时，可以使用该控件。\n表格控件：QTableWidget类，可以将一个列表的数据展现在表格控件中的一行中，当有大量数据需要展示和修改时，可使用该控件。\n\n\n界面设计工具：QTDesigner\n\n\n常见的编码和加密\n常见的编码有base64、unicode、urlencode编码，加密有MD5、SHA1、HMAC、DES、RSA等。\n\nbase64：base64是一种基于64个可打印ASCLL字符对任意字节数据进行编码的算法，其在编码后具有一定意义的加密作用。在逆向过程中经常会碰到base64编码。在python中使用base64：\nimport base64print(base64.b64encode('msb'.encode()))print(base64.b64decode('bXNi'.encode()))\n\nunicode和urlencode：unicode是计算机中字符集、编码的一项业界标准，被称为统一码、万国码，表现形式一般以“\\u” 或者 “&amp;#”开头。urlencode是URL编码，也称作百分号编码用于把URL中的符号进行转换。\n\nMD5：MD5消息摘要算法（英文：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5加密算法是不可逆的，所以解密一般都是通过暴力穷举方法，以及网站的接口实现解密。python代码实现加密：\nimport hashlibpwd = \"123\"# 生成MD5对象m = hashlib.md5()# 对数据进行加密m.update(pwd.encode('utf-8'))# 获取密文pwd = m.hexdigest()print(pwd)\n\nSHA1：SHA1（Secure Hash Algorithm）安全哈希算法主要适用于数字签名标准里面定义的数字签名算法，SHA1比MD5的安全性更强。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。一般在没有高度混淆的Js代码中，SHA1加密的关键词就是sha1。\nimport hashlibsha1 = hashlib.sha1()data1 = \"msb\"data2 = \"kkk\"sha1.update(data1.encode(\"utf-8\"))sha1_data1 = sha1.hexdigest()print(sha1_data1)sha1.update(data2.encode(\"utf-8\"))sha1_data2 = sha1.hexdigest()print(sha1_data2)\n\nHMAC：HMAC全称：散列消息鉴别码。HMAC加密算法是一种安全的基于加密hash函数和共享密钥的消息认证协议。实现原理是用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。\nimport hmacimport hashlibkey = \"key\".encode()text = \"msb\".encode()m = hmac.new(key, text, hashlib.sha256)print(m.digest())print(m.hexdigest())#new（key,msg=None,digestmod）方法创建哈希对象,key和digestmod参数必须指定，key和msg（需要加密的内容）均为bytes类型，digestmod指定加密算法，比如‘md5’,'sha1'等#对象digest（）方法：返回bytes类型哈希值#对象hexdigest（）方法：返回十六进制哈希值\n\nDES：\n\nDES全称：数据加密标准（Data Encryption Standard），属于对称加密算法。DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8位都用作奇偶校验），密钥可以是任意的56位数，而且可以任意时候改变。Js逆向时，DES加密的搜索关键词有DES、mode、padding等。\n# pyDes需要安装from pyDes import des, CBC, PAD_PKCS5import binascii# 秘钥KEY = 'dsj2020q'def des_encrypt(s):    \"\"\"    DES 加密    :param s: 原始字符串    :return: 加密后字符串，16进制    \"\"\"    secret_key = KEY    iv = secret_key    k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)    en = k.encrypt(s, padmode=PAD_PKCS5)    return binascii.b2a_hex(en).decode()def des_decrypt(s):    \"\"\"    DES 解密    :param s: 加密后的字符串，16进制    :return:  解密后的字符串    \"\"\"    secret_key = KEY    iv = secret_key    k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)    de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5)    return de.decode()text = 'msb'secret_str = des_encrypt(text)print(secret_str)clear_str = des_decrypt(secret_str)print(clear_str)\n\nAES：AES全程：高级加密标准，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。AES也是对称加密算法，如果能够获取到密钥，那么就能对密文解密。Js逆向时，AES加密的搜索关键词有AES、mode、padding等。\n#需要安装pip install pycryptodomeimport base64from Crypto.Cipher import AES# AES# 需要补位，str不是16的倍数那就补足为16的倍数def add_to_16(value):    while len(value) % 16 != 0:        value += '\\0'    return str.encode(value)  # 返回bytes# 加密方法def encrypt(key, text):    aes = AES.new(add_to_16(key), AES.MODE_ECB)  # 初始化加密器    encrypt_aes = aes.encrypt(add_to_16(text))  # 先进行aes加密    encrypted_text = str(base64.encodebytes(encrypt_aes), encoding='utf-8')    return encrypted_text# 解密方法def decrypt(key, text):    aes = AES.new(add_to_16(key), AES.MODE_ECB)  # 初始化加密器    base64_decrypted = base64.decodebytes(text.encode(encoding='utf-8'))    decrypted_text = str(aes.decrypt(base64_decrypted), encoding='utf-8').replace('\\0', '')  # 执行解密密并转码返回str    return decrypted_text\n\nRSA：RSA全称：Rivest-Shamir-Adleman, RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用，它被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗目前为止已知的所有密码攻击。注意Js代码中的RSA常见标志setPublickey。\n#需要安装：pip install pycryptodome import base64from Crypto.Cipher import PKCS1_v1_5from Crypto import Randomfrom Crypto.PublicKey import RSA# ------------------------生成密钥对------------------------def create_rsa_pair(is_save=False):    \"\"\"    创建rsa公钥私钥对    :param is_save: default:False    :return: public_key, private_key    \"\"\"    f = RSA.generate(2048)    private_key = f.exportKey(\"PEM\")  # 生成私钥    public_key = f.publickey().exportKey()  # 生成公钥    if is_save:        with open(\"crypto_private_key.pem\", \"wb\") as f:            f.write(private_key)        with open(\"crypto_public_key.pem\", \"wb\") as f:            f.write(public_key)    return public_key, private_keydef read_public_key(file_path=\"crypto_public_key.pem\") -&gt; bytes:    with open(file_path, \"rb\") as x:        b = x.read()        return bdef read_private_key(file_path=\"crypto_private_key.pem\") -&gt; bytes:    with open(file_path, \"rb\") as x:        b = x.read()        return b# ------------------------加密------------------------def encryption(text: str, public_key: bytes):    # 字符串指定编码（转为bytes）    text = text.encode(\"utf-8\")    # 构建公钥对象    cipher_public = PKCS1_v1_5.new(RSA.importKey(public_key))    # 加密（bytes）    text_encrypted = cipher_public.encrypt(text)    # base64编码，并转为字符串    text_encrypted_base64 = base64.b64encode(text_encrypted).decode()    return text_encrypted_base64# ------------------------解密------------------------def decryption(text_encrypted_base64: str, private_key: bytes):    # 字符串指定编码（转为bytes）    text_encrypted_base64 = text_encrypted_base64.encode(\"utf-8\")    # base64解码    text_encrypted = base64.b64decode(text_encrypted_base64)    # 构建私钥对象    cipher_private = PKCS1_v1_5.new(RSA.importKey(private_key))    # 解密（bytes）    text_decrypted = cipher_private.decrypt(text_encrypted, Random.new().read)    # 解码为字符串    text_decrypted = text_decrypted.decode()    return text_decryptedif __name__ == \"__main__\":    # 生成密钥对    # create_rsa_pair(is_save=True)    # public_key = read_public_key()    # private_key = read_private_key()    public_key, private_key = create_rsa_pair(is_save=False)    # 加密    text = \"msb\"    text_encrypted_base64 = encryption(text, public_key)    print(\"密文：\", text_encrypted_base64)    # 解密    text_decrypted = decryption(text_encrypted_base64, private_key)    print(\"明文：\", text_decrypted)\n\n\n\n"},{"title":"AI学习","url":"/2025/08/03/AI/","content":"学习AIPrompt, Agent, MCP 是什么\nuser prompt：用户提示词，一般就是我们提出的问题或者想说的话。当AI没有特定的人设时，就只会给出一个通用的回答。\nsystem prompt：把人设信息单独拎出来，放到另外一个prompt内面就是系统提示词，它主要用来描述AI的角色、性格、背景信息、语气等等。总之只要不是用户直接说出来的内容，都可以放进system prompt内面。\n每次用用户发送user prompt时，会将system prompt一起发送给AI，这样整个对话就显得更加自然了。在网页端的聊天机器人中，system prompt往往是系统预设的，用户不能随便更改。但是一般聊天机器人中，会提供一些允许用户在里面写下一些自己的偏好，这些偏好就会变成system prompt的一部分。\nAI Agent：负责在模型、Agent工具和最终用户之间传话的程序叫做AI Agent。它代替用户直接和AI交互，完成特定复杂的工作流程任务。\nAgent Tool：提供给AI调用的函数或者服务。\nFunction Calling：system prompt的描述是用自然语言随意写的，只需要AI能看得懂就行。但Function Calling则对这些描述进行了标准化，比如每个Tool都用一个Json对象来定义工具名、功能说明和所需要的参数，然后这些Json对象也从System Prompt中被剥离了出来，单独放到了一个字段里面。最后Function Calling也规定了AI使用工具时应该返回的格式，所以System Prompt中的格式定义就可以删掉了。这样一来，所有的工具描述都放在相同的地方，所有工具描述也都依照相同的格式；AI使用工具时的回复也都依照相同的格式。这样人们就能更加有针对性的训练AI模型，让它理解这种调用的场景。甚至如果AI生成了错误的回复，因为回复的格式是固定的，AI服务器端自己就可以检测到，并且进行重试，用户根本感觉不到。这样一来，不仅降低了用户端的开发难度，也节省了用户端重试带来的Token开销。正是有这样的好处，现在越来越多的AI Agent开始从System Prompt转身Function Calling。\nFunction Calling没有统一的标准，每家大厂的API定义都不一样，而且很多开源模型还不支持Function Calling，所以要实现一个跨模型通用的AI Agnet还很麻烦，所以System Prompt和Function Calling这两种方式现在在市面上是并在的。\nMCP：由于很多Agent Tool的功能其实是通用的，比如一个网页浏览的工具，可能多个Agent都需要，这样就可以把Tool变成服务统一的托管，让所有的Agent都来调用，这就是MCP。MCP是一个通信协议，专门用来规范Agent和Tool服务之间是怎么交互的，运行Tool的服务叫做MCP Server，调用它的Agent叫做MCP Client，MCP规范了MCP Server如何和MCP Client通信，以及MCP Server要提供哪些接口，比如说用来查询MCP Server中有哪些Tool，Tool的功能、描述需要的参数、格式等等的接口。\n除了普通的Tool这种函数调用的形式，MCP Server也可以直接提供数据，提供类似文件读写的服务叫做Resource，或者为Agent提供提示词的模板叫做Prompt。MCP Server既可以和Agent跑在同一台机器上，通过标准输入输出进行通信，也可以部署在网络上，通过HTTP进行通信。这里需要注意，虽然MCP是为了AI而制定出来的标准，但实际上MCP本身却和AI模型没有关系，它并关心Agent用的是哪个模型。MCP只负责帮Agent管理工具、资源和提示词。\nAI Agent使用的整个流程：用户问AI Agent或者MCP Client问题，Agent会把问题包装在User Prompt中，然后Agent通过MCP协议，从MCP Server里面获取所有的Tool的信息，AI Agent会把这些Tool的信息或者转化成System Prompt或者转化成Function Calling的格式，然后和用户请求User Prompt一起打包发送给AI模型，AI模型发现有一个叫做web_browse的网页浏览工具，于是通过普通回复或者Funtion Calling格式产生一个调用这个Tool的请求，希望去网上搜索答案，Agent收到了这个请求之后，通过MCP协议去调用MCP Server里的web_browse工具，web_browse访问指定的网站之后，将内容返还给Agent，Agent再转发给AI模型，AI模型再根据网页内容和自己的头脑风暴生成最终答案，最后由Agent把结果展示给用户。\nSystem Prompt、User Prompt、AI Agent、Agent Tool、Funtion Calling、MCP之间不是彼此取代的关系，而是像齿轮一样一起构成了AI自动化协作的完整体系。\n\nMCP Server推荐\n推荐一：文件系统filesystem\n\nFilesystem MCP 旨在为大型语言模型（LLM）和AI助手提供对本地文件系统的安全、受控访问。\n主要功能：\n文件读写：允许读取和写入文件内容，支持创建新文件或覆盖现有文件。\n目录管理：支持创建、列出和删除目录，以及移动文件或目录。\n文件搜索：能够在指定路径中搜索匹配特定模式的文件或目录。\n元数据获取：提供获取文件或目录的详细元数据，包括大小、创建时间、修改时间、访问时间、类型和权限等信息。\n\n\n\n\n推荐二：数据库mysqldb-mcp-server\n\n一种模型上下文协议（MCP）实现，支持与Mysql数据库进行安全交互。此服务器组件可促进AI应用程序（主机/客户端）与Mysql数据库之间的通信，提供安全的MySql数据库操作，通过受控接口使数据库探索和分析更安全、更有条理。\n\n\n推荐三：高德地图amap-maps\n\n高德地图是一个支持任何MCP协议客户端的服务器，允许用户轻松利用高德地图MCP服务器进行各种基于位置的服务。\n高德地图的主要特点：\n支持多种位置服务，包括地理编码、天气和距离测量。\n提供步行、驾车、公交等多种交通方式的API。\n允许根据关键字或位置详细搜索兴趣点（POI）\n\n\n\n\n推荐四：网页数据的采集Firecrawl\n\nFirecrawl MCP 工具是一款基于模型上下文协议（MCP）的企业级网页数据采集服务器。能够为大型语言模型（LLM）提供强大的网页抓取能力。\n主要功能：\nJavaScript 渲染：能够处理动态网页内容，突破传统抓取工具的局限，获取更全面的数据。\n批量处理：支持并行处理和队列管理，提高数据抓取效率。\n智能限速：根据网络状况和任务需求智能调整抓取速度，避免对目标网站造成过大压力。\n多种输出格式：支持将抓取的内容转换为MakeDown、HTML等格式，满足不同场景的需求。\n说明：去firecrawl官网注册后即可查看自己的api_key\n\n\n\n\n推荐五：Github\n\nGithub MCP 服务器是一个模型上下文协议（MCP）提供与Github API 无缝集成的服务器，从而实现面向开发人员的高级自动化工具和交互功能。\n使用案例\n自动化Github工作流和流程。\n从Github 存储仓库中提取和分析数据。\n构建与Github 生态系统交互的AI驱动的工具和应用程序。\n说明：去https://Githut.com/settings/tokens 申请自己的token\n\n\n\n\n推荐六：Git\n\n用于GIt 存储库交互和自动化的模型上下文协议服务器。\n直接的Git 仓库操作，包括读取、搜索和分析本地仓库。\n\n\n推荐七：记忆图谱 memory\n\n基于知识图谱的长期记忆系统用于维护上下文\n使用本地知识图谱的持久内存的基本实现。这使 Claude 可以在聊天中记住有关用户的信息。\n\n\n推荐八：控制台 desktop-commander\n\n在计算机上无缝执行终端命令和管理流程。使用强大的命令执行和文件作工具简化您的开发任务。\n\n\n推荐九：社交软件 Slack\n\n用于Slack API 的MCP服务器，使LLM能够与 Slack 工作区进行交互，用于频道管理和消息传递。\n说明：去 https://app,slack.com/intl/zh-cn 注册并获取自己的 team id\n\n\n其它推荐\n\n# 浏览器自动化\n{\n  \"mcpServers\": {\n    \"playwright-mcp\": {\n      \"command\": \"cmd\",\n      \"args\": [\n        \"/c\",\n        \"npx\",\n        \"-y\",\n        \"@smithery/cli@latest\",\n        \"run\",\n        \"@microsoft/playwright-mcp\",\n        \"--key\",\n        \"c7cb8987-b1e0-40d2-b676-c0f2f9980185\"\n      ]\n    }\n  }\n}\n  + ## A2A协议+ A2A协议：开启Agent间自然协作，在 AI Agent 的世界里，主要解决两大互联领域的挑战：  + 第一，Agent 与工具 Tool（工具）的交互，Agent 需要调用外部 API 、访问数据库、执行代码等，主要是通过 MCP 协议来实现  + 第二，Agent 与 Agent （其它智能体或用户）的交互，Agent 需要理解其他 Agent 的意图、协同完成任务、与用户进行自然的对话。主要通过 A2A 协议来实现。  + 通过 Github 地址：https://github.com/google/a2a 查看。## MCP教程+ MCP 的通信机制  + 根据 MCP 的规范，当前支持两种通信机制（传输方式）    + stdio （标准输入输出）：主要用在本地服务器上，操作你本地的软件或者文件。比如 Bleender 这种就只能用 Stdio 因为它没有在线服务。这也是MCP默认通信方式。    + SSE （Server-Sent-Events）：主要用在远程通信服务上，这个服务本身就有在线的API，比如你访问你的谷歌邮件，天气情况等。  + MCP 使用前的准备工作  + Stdio 的本地环境安装有两种    + 一种是python编写的服务，对应 uvx 指令，安装命令 pip install uv    + 一种是TypeScript编写的服务，对应 npx 指令，安装 node.js 就可以了。  + MCP 服务器可以同时提供三种类型能力或其中一种  + Resources：资源，类似于文件数据读取，可以是文件资源或是API 响应返回的内容。  + Tools：工具，第三方服务、功能函数，通过此可控制LLM 可调用哪些函数。  + Proｍpts：提示词，为用户预先定义好的完成特定任务的模板。  + MCP 的三个核心概念  + MCP Server：    + 基于各语言的MCP SDK开发的程序或服务    + 基于某种神秘的机制将现存的程序或服务进行了转换，使其成为了MCP Server  + MCP Tool：所属于MCP Server，一个MCP Server 可以有多个MCP Tool  + MCP Client：当一段代码，一个Agent，一个客户端，基于MCP的规范去使用、去调用MCP Server里的MCP Tool 时，它就是MCP Client  + MCP 的好处  + 简化开发：写一次，多次集成，无需为每个集成重写自定义代码  + 灵活性：切换AI 模型或工具时无需复杂重新配置  + 实时响应：MCP 连接保持活动状态，实现实时上下文更新和交互  + 安全性和合规性：内置访问控制和标准化的安全实践  + 可扩展性：随着您的AI 生态系统增长，轻松添加新功能，只需连接另一个MCP服务器  + MCP 的工作流程  1. 用户通过MCP Client/Agent 输入问题，MCP/Agent 会将用户的问题和MCP Tool的定义和使用方法告诉（输入给）大模型  2. 大模型收到上面给出的信息数据后，通过自身的思考、分析、处理，会返回（输出）给MCP Client/Agent应该调用哪个MCP Server内面的MCP Tool最合适  3. MCP Client/Agent 会去调用大模型指定的MCP Tool  4. MCP Server返回结果给MCP Client/Agent  5. 再由MCP Client/Agent将用户的提问和返回结果传递给大模型  6. 大模型结合用户的提问和MCP Server的返回结果，作进一步推理，并以一定的格式输出给MCP Client/Agent，最终用户就能得到返回的最终结果  + MCP 客户端代码结构  + 导入所需要的库  + 创建Client实例  + 连接到MCP服务器  + 发送查询  + 处理响应+ 运行MCP客户端   ```py  # 安装所需依赖：  uv pip install mcp-client # 也可以使用python的pip去安装  # 运行客户端：  uv run client.py  # 也可以使用python环境去运行\n\n\n\n\nMCP 客户端接入OpenAI、DeepSeek在线模型\n1.新增依赖，为了接入在线模型，需要安装额外的依赖uv add mcp openai python-dotenv2.创建一个.env 文件来存储API密钥OPENAI_API_KEY=your_openai_api_keyBASE_URL=base_urlMODEL=gpt-4o\n\nMCP 的核心原理\n\n参考URL链接：全网最细，一文带你弄懂 MCP 的核心原理！_mcp host-CSDN博客\n\n\n\n\n"},{"title":"Dock学习","url":"/2025/08/04/Docker/","content":"Ubuntu Servervim常用命令一、基本操作命令\n\n:w 保存当前文件\n:wq或:x 保存并退出Vim\n:q 退出Vim，如果文件有未保存的修改，会提示确认\n:q! 强制退出Vim，不保存当前文件的修改\n\n二、光标移动命令\n\nh 光标向左移动一个字符\n\nj 光标向下移动一行\n\nk 光标向上移动一行\n\nl 光标向右移动一个字符\n\ngg 将光标跳转到文件的第一行\n\nG 将光标跳转到文件的最后一行\n\n数字+G 将光标跳转到数字指定的行\n\n\n三、编辑命令\n\ni 进入插入模式，开始在当前光标位置插入文本\n\na 进入插入模式，在当前光标后插入文本\n\no 进入插入模式，在光标所在行的下一行插入文本\n\nO 进入插入模式，在光标所在行的上一行插入文件\n\nx 删除光标所在位置的字符\n\ndd 删除光标所在行的一整行\n\nD 删除从光标位置到行尾的文本\n\nyy 复制光标所在行的一行文本\n\np 粘贴复制的文本到光标所在位置的下一行\n\nu 撤消上一次的编辑操作\n\nCtrl+r 重做上一次撤销的编辑操作\n\n\n四、查找和替换命令\n\n/查找文本 查找文件中的文本内容\nn 查找下一个匹配项\nN 查找上一个匹配项\n:s/旧文本/新文本/ 替换当前行中第一个匹配的旧文本为新文本\n%s/旧文本/新文本/g 替换整个文件中所有匹配的旧文本为新文本\n\n使用root用户登录sudo passwd root先输入当前普通用户（如用户lxls）的密码，用于提权然后再输入为root用户所设置的密码，输入两次，这样就完成设置root用户密码了以root登录su root\n\n解锁SSH用root登录vim /etc/ssh/sshd_config找到相应代码行并注释#PermitRootLogin prohibit-password添加上PermitRootLogin yes保存修改，重启ssh服务service ssh restart\n\n搭建FTP服务器安装vsftpd：apt install vsftpdvsftpd服务将在安装过程完成后自动启动。通过打印服务状态进行验证：systemctl status vsftpd输出如下所示，表明vsftpd服务处于活动状态并正在运行：● vsftpd.service - vsftpd FTP server     Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; enabled; preset: enabled)     Active: active (running) since Mon 2025-07-28 01:13:07 UTC; 2h 24min ago    Process: 2416 ExecStartPre=/bin/mkdir -p /var/run/vsftpd/empty (code=exited, status=0/SUCCESS)   Main PID: 2418 (vsftpd)      Tasks: 3 (limit: 19041)     Memory: 1.8M (peak: 19.3M)        CPU: 862ms     CGroup: /system.slice/vsftpd.service             ├─2418 /usr/sbin/vsftpd /etc/vsftpd.conf             ├─2489 /usr/sbin/vsftpd /etc/vsftpd.conf             └─2491 /usr/sbin/vsftpd /etc/vsftpd.conf             允许上传和删除：修改vsftpd.conf文件：sudo vim /etc/vsftpd.conf，将 #write_enable=YES 前面的注释#去掉   允许root登录FTP：更改/etc/ftpusers，注释掉root用户：sudo vim /etc/ftpusers#root在终端中重启FTP服务：sudo /etc/init.d/vsftpd restart 或者运行service vsftpd restart确保vsftpd服务在系统启动时自动启动：sudo systemctl enable vsftpd.service\n\n镜像源配置新格式支持：从 Ubuntu 24.04 开始，支持新的 DEB822 格式，需将配置写入软件源文件/etc/apt/sources.list.d/ubuntu.sources 格式如下：# 阿里云Types: debURIs: http://mirrors.aliyun.com/ubuntu/Suites: noble noble-updates noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg更新完软件源后即可使用更新后的镜像源~更新软件源：sudo apt-get update更新软件（可选）：sudo apt-get upgrade\n\n网卡启动及配置\n安装网络管理工具\napt install net-tools\n\n查看网卡信息\nip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host noprefixroute       valid_lft forever preferred_lft forever2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000    link/ether 00:0c:29:d6:8e:66 brd ff:ff:ff:ff:ff:ff    altname enp2s0    inet 172.18.1.109/22 metric 100 brd 172.18.3.255 scope global dynamic ens32       valid_lft 86339sec preferred_lft 86339sec    inet6 fe80::20c:29ff:fed6:8e66/64 scope link       valid_lft forever preferred_lft forever3: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000    link/ether 00:0c:29:d6:8e:70 brd ff:ff:ff:ff:ff:ff    altname enp2s1    inet 11.82.10.99/24 brd 11.82.10.255 scope global ens33       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fed6:8e70/64 scope link       valid_lft forever preferred_lft forever\n\n打开网卡\nsudo ip link set eth0 up# eth0是根据查看网卡信息得到的，你的机器需要跟据实际显示作出修改，up如果换成down就是关闭网卡\n\n配置双网卡并设置静态路由\nubuntu server 20.04 采用读yaml配置文件的方式修改网卡配置，文件在/etc/netplan/下，一般为 00-installer-config.yaml，我的为：root@lxls:/etc/netplan# l50-cloud-init.yaml用vim编辑，在文件末尾添加另一块网卡，修改为静态ip,最终修改内容：root@lxls:/etc/netplan# cat 50*network:  version: 2  ethernets:    ens32:      dhcp4: true    #动态获取的IP地址，会自动配置网关、路由表和域名地址    ens33:      dhcp4: no      addresses: [11.82.10.99/24]            routes:        - to: 10.0.0.0/8   # 目标网络          via: 11.82.10.1  # 下一跳地址        - to: 11.0.0.0/8          via: 11.82.10.1      nameservers:            addresses: [11.3.127.13 ,11.3.127.12]              注意yaml对缩进和空格要求严格              \n\n应用更改\nsudo netplan apply\n\n添加内网路由（临时起作用，重启后失效，想重启后仍生效参加上面：配置双网卡并设置静态路由）\nroute add -net 11.0.0.0/8 gw 11.82.10.1 ens33route add -net 10.0.0.0/8 gw 11.82.10.1 ens33查看路由表：# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.18.0.1      0.0.0.0         UG    100    0        0 ens3210.0.0.0        11.82.10.1      255.0.0.0       UG    0      0        0 ens3311.0.0.0        11.82.10.1      255.0.0.0       UG    0      0        0 ens3311.82.10.0      0.0.0.0         255.255.255.0   U     0      0        0 ens33114.114.114.114 172.18.0.1      255.255.255.255 UGH   100    0        0 ens32172.18.0.0      0.0.0.0         255.255.252.0   U     100    0        0 ens32172.18.0.1      0.0.0.0         255.255.255.255 UH    100    0        0 ens32222.246.129.80  172.18.0.1      255.255.255.255 UGH   100    0        0 ens32\n\n删除路由命令\nsudo route del -net 0.0.0.0 dev enp0s3上述指令为删除指向互联网的默认路由。将所有数据包都通过enp0s3网卡的路由删除\n\n查看主机网络连接端口\n# netstat -tunlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      874/systemd-resolvetcp        0      0 127.0.0.54:53           0.0.0.0:*               LISTEN      874/systemd-resolvetcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1/inittcp        0      0 127.0.0.1:6012          0.0.0.0:*               LISTEN      5645/sshd: root@ptstcp6       0      0 :::21                   :::*                    LISTEN      1103/vsftpdtcp6       0      0 :::22                   :::*                    LISTEN      1/inittcp6       0      0 ::1:6012                :::*                    LISTEN      5645/sshd: root@ptsudp        0      0 127.0.0.54:53           0.0.0.0:*                           874/systemd-resolveudp        0      0 127.0.0.53:53           0.0.0.0:*                           874/systemd-resolveudp        0      0 172.18.1.109:68         0.0.0.0:*                           789/systemd-network\n\n常用命令查看磁盘使用情况：# df -hFilesystem                         Size  Used Avail Use% Mounted ontmpfs                              1.2G  1.6M  1.2G   1% /run/dev/mapper/ubuntu--vg-ubuntu--lv   98G  8.2G   85G   9% /tmpfs                              5.9G     0  5.9G   0% /dev/shmtmpfs                              5.0M     0  5.0M   0% /run/lock/dev/sda2                          2.0G  100M  1.7G   6% /boottmpfs                              1.2G   12K  1.2G   1% /run/user/0overlay                             98G  8.2G   85G   9% /var/lib/docker/overlay2/e15fb52a77f92480871a5ea8c73b13d23ad876f4364ec10bfb85cd1695081816/merged查看所有磁盘及分区：lsblk  # 列出所有块设备（硬盘、分区、逻辑卷）NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTSsda                         8:0    0  500G  0 disk├─sda1                      8:1    0    1M  0 part├─sda2                      8:2    0    2G  0 part /boot└─sda3                      8:3    0  498G  0 part  └─ubuntu--vg-ubuntu--lv 252:0    0  100G  0 lvm  /sr0                        11:0    1 1024M  0 rom# 扩展逻辑卷，使用卷组中全部空闲空间lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv# 扩展文件系统，让操作系统识别新增的空间。Ubuntu 默认使用 ext4 文件系统，执行：resize2fs /dev/ubuntu-vg/ubuntu-lv#如果你的文件系统是 xfs（较少见，可通过 df -T / 确认），则使用 xfs_growfs / 替代查看系统内核（即linux）版本：内核只有一个正统来源，那就是linus的开发团队，内核只提供操作系统的基本功能和特性，如内存管理、进度调度、文件管理等等root@lxls:/etc/docker# uname -r6.8.0-64-generic查看ubuntu的发行版本：发行版是由不同的厂商开发、定制不同的功能root@lxls:/etc/docker# cat /etc/lsb-releaseDISTRIB_ID=UbuntuDISTRIB_RELEASE=24.04DISTRIB_CODENAME=nobleDISTRIB_DESCRIPTION=\"Ubuntu 24.04.2 LTS\"#一个完整的系统，是由liunx的内核+发行版，才组成了一个可以使用的完整的系统# 查看进程，并过滤查看指定名称的进程ps -ef|grep nginx\n\nDocker国内镜像站\n以下同一些常见的国内镜像站\nDocker有多个国内镜像管理网站，以下是一些常见的介绍：1. 毫秒镜像：官网为https://docker.1ms.run，支持Cloudflare和境内CDN，搜索功能强大，配置简单且稳定。2. 腾讯云Docker镜像源：官网是https://mirror.ccs.tencentyun.com，仅限腾讯云服务器内访问，安全稳定。3. DaoCloud官方镜像源：官网为https://docker.m.daocloud.io，依托阿里云，存在白名单和限流机制。4. 1Panel镜像源：官网是https://docker.1panel.live，有Cloudflare支持，但部分地区可能受限。5. 轩辕镜像：免费版官网为https://docker.xuanyuan.me，会员版官网为https://xuanyuan.cloud，均采用Cloudflare+境内CDN，官网支持搜索镜像，配置简单，有会员解答群，屏蔽违法内容，由境内公司运营，非常稳定。6. 阿里云镜像服务：官网为https://cr.console.aliyun.com，仅阿里云服务器内推荐使用。7. 网易镜像源：地址为http://hub-mirror.c.163.com，可以提供镜像加速服务。8. 中国科技大学镜像站：地址是https://docker.mirrors.ustc.edu.cn，除了Docker镜像，还提供多种软件包的镜像服务，但仅供内部访问。9. OpenAtom Hub：官网为https://atomhub.openatom.cn，其中的AtomHub可信镜像仓库平台包含部分基础镜像。\n\n阿里云加速器地址\nhttps://qyef4ruk.mirror.aliyuncs.comUbuntu下操作文档，通过修改daemon配置文件/etc/docker/daemon.json来使用加速器sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  \"registry-mirrors\": [\"https://qyef4ruk.mirror.aliyuncs.com\"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n\n配置了国内镜像源（比如阿里的docker镜像源）是对 docker search 没有用的，因为docker命令最后还是通过他自己的地址搜索镜像，但是配置了国内镜像源可以加快 dockere pull 拉取镜像的速度。解决方法是指定镜像源地址搜索（绕过默认 API）：\n# 毫秒镜像docker search docker.1ms.run/nginx# 轩辕镜像源搜索 mysqldocker search hl1mitwelzr416b.xuanyuan.run/mysqldocker search docker.xuanyuan.me/nginx  \n\n使用Docker的优点\n容器对比KVM的好处：\n容器能够提供宿主机的性能，而KVM虚拟机是分配宿主机硬件资源，性能较弱。\n同样配置的宿主机，最多可以启动10个虚拟机的话，那么就可以启动100+的容器数量。\n启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，或许需要20秒，而启动一个容器只需要1秒。\nKVM需要硬件CPU的虚拟化支持，而容器不需要。\n容器不需要进行硬件虚拟化以及运行一个完整系统的额外开销，对系统资源利用率更高。\nDocker引擎容器在主机操作系统上作为一个独立的进程运行，与其它容器共享内核。\n\n\n\nDocker的安装部署\nDocker引擎：Docker Engine是C/S架构的。\n\nDocker Daemon（守护进程），安装使用Docker，得先运行Docker Daemon，用于管理Docker，如：\n\n镜像 images，是一个只读的系统模板，用于创建容器，类似于编程开发中面向对象的类，构建容器的过程，就是运行镜像，生成容器实例。也可以通过Dockerfile文本描述镜像内容，将你要部署项目的操作，写成一个部署脚本，且该脚本还能够构建出镜像文件，包含如下的指令。\nFROM 定义基础镜像\nMAINTAINER作者\nRUN 运行Linux命令\nADD 添加文件/目录\nENV 环境变量\nCMD 运行进程\n\n\n容器 containers，是一个镜像运行的运行实例。你的应用程序就跑在容器中。\n网络 network\n数据卷 Data Volumes\n\n\nRest接口：提供和Daemon交互的API接口。（Representational State Transfer Application Programming Interface，表述性状态转移应用程序接口）是一种基于 HTTP 协议设计的软件架构风格，用于实现不同系统之间的通信和数据交互。它并非严格的标准，而是一套设计原则，旨在让接口更简洁、可扩展、易于理解和维护。\n\nDocker Client：客户端（各种命令行操作）使用 REST API 和 Docker Daemon 进行访问。\n\nDocker平台组成：客户端、Docker主机、镜像仓库。\n\n客户端：\n基于Dockerfile构建自己的镜像\n下载别人的镜像Docker pull\n启动Docker容器\n\n\nDocker主机：在服务器上通过启动镜像，生成运行着的容器\n镜像仓库（DockerHub）：是网络中的一个仓库，用于管理Docker的镜像Image，提供上传和下载功能，作用好比github\n\n\n容器创建过程：\n\n获取镜像，如 Docker pull centos ，从镜像仓库拉取\n使用镜像创建容器\n分配文件系统，挂载一个读写层，在读写层加载镜像\n分配网络/网桥接口，创建一个网络接口，让容器和宿主机通信\n容器获取IP地址\n执行容器命令，如：/bin/bash\n反馈容器启动结果\n\n\n安装Docker：提前准备好一个宿主机（用vmware去创建一个linux机器，然后安装Docker去使用）\n1. 移除旧的或错误的 Docker 源配置sudo rm /etc/apt/sources.list.d/docker.list  # 删除可能存在的错误配置2. 添加 Docker 官方 GPG 密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg3. 添加 Docker 官方软件源echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null4. 更新软件包索引sudo apt update5. 再次尝试安装 Dockersudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin验证安装结果sudo docker run hello-world6. 配置 Docker 镜像加速（可选），我使用的是阿里云sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  \"registry-mirrors\": [\"https://qyef4ruk.mirror.aliyuncs.com\"]}EOF重启 Docker 服务：sudo systemctl daemon-reloadsudo systemctl restart docker查看 Docker 服务状态sudo systemctl status docker查看版本# docker --versionDocker version 28.3.2, build 578ccf6# 将其它用户添加到docker组，使其它用户也能执行docker命令usermod -aG docker lxls# 移除一个组的用户命令，sudo gpasswd -d lxls rootRemoving user lxls from group root# 查看是否还在该组内：groups lxlslxls : lxls adm cdrom sudo dip plugdev lxd docker\n\n常用命令\n查看docker服务信息：docker info\n\n获取、查看、删除镜像\n\n搜索镜像：docker search nginx 国内需要加上加速镜像站地址，docker search docker.1ms.run/nginx\n\n下载镜像： docker pull nginx  下载指定版本镜像，docker pull nginx:1.26.0\n\n查看所有镜像： docker images\n\n删除镜像（可根据名字或id来删除）：docker  rmi  e784f4560448\n\n批量删除多个镜像：docker rmi  ‘docker images -aq’  或者 docker rmi $(docker images -aq)\n\n查看镜像的详细信息：docker inspect 镜像id\n\n查看镜像的构建历史：docker history 镜像id\n\n\n导出、导入镜像\n\n提交变化后的容器，打包成新的镜像：docker commit -m “news message”   容器id   新的镜像名\n保存镜像为tar包文件（方便传输给别人）：docker save -o mynginx.tar mynginx:v1.0\n加载tar包文件成为docker镜像：docker load -i mynginx.tar\n\n容器管理\n\n创建+启动容器：docker run 镜像名，如果镜像不存在本地，则会在线去下载该镜像，这也是前台运行容器，运行时会占用一个终端屏幕，显示实时信息。\n运行一个容器并进入容器内面：docker run -it afb6fca bash#参数解释 -i 交互式命令操作；-t 开启一个终端；afb6fca 是镜像的id；bash 进入容器后，使用的解释器#重要的三个参数：-d 后台启动；-p 端口映射；--name 容器名#退出容器exit\n\n查看运行中的容器：docker ps\n\n查看所有容器（包括停止、挂掉的容器）：docker ps -a\n\n查看容器内的进程信息：docker top 容器id\n\n停止容器：docker stop nginx\n\n启动容器：docker start 592\n\n重启容器：docker restart 592\n\n查看容器资源占用情况：docker stats 592\n\n查看容器日志：docker logs -f  592   # -f 表示实时刷新日志\n\n查看容器的详细信息：docker  inspect 容器id\n\n删除指定容器：docker rm 592\n\n强制删除指定容器（正在运行的容器）：docker rm -f 592\n\n批量删除容器：docker rm ‘docker ps -aq’  或者 docker rm $(docker ps -aq)\n\n后台启动容器：docker run -d –name mynginx nginx\n\n后台启动并暴露端口：docker run -d –name mynginx -p 80:80 nginx\n\n进入一个已经运行的容器内部（后台运行的容器）：docker exec -it myngix /bin/bash\n\n将容器内的数据拷贝到宿主机上：docker cp 容器id:容器内目录  目的的主机路径\n\n\n将镜像发布到社区，供别人pull使用：\n\n登录docker hub：docker login  # 这里只是进入网页登录界面，后面会再提示需要输入用户名和密码\n\n重新给镜像打标签：docker tag mynginx:v1.0 cffljx/mynginx:v1.0  #docker官方对镜像取名有格式要求\n\n推送镜像：docker push cffljx/mynginx:v1.0\n\n\n镜像分层原理\nDocker通过联合文件系统（union file system），将镜像不同的每一层，整合成一个文件系统，为用户隐藏了多层的视角。当通过一个image启动容器时，docker会在该image最顶层，添加一个可读写文件系统作为容器，然后运行该容器。\n\n只读镜像，不能修改，包括：\n\n宿主机提供linux内核：boot-file system（bootfs）Linux内核，bootfs主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux启动时会加载bootfs文件系统\ndocker获取基础镜像：rootfs（root-file system）Linux发行版，rootfs在bootfs之上，包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同操作系统的发行版，比如ubuntu、centos等等\n依赖环境1：其它镜像，如：jdk\n依赖环境2：其它镜像，如tomcat\n\n\n容器层、可写层：如代码修改后，重启容器生效。\n\n具体的程序运行：可以写入的容器，如你想运行的代码程序\n\n\n镜像定义：docker镜像不包含linux内核，和宿主机共用。\n如果我们想定义一个mysql5.6镜像，我们需要这么做：1.获取基础镜像，选择一个发行版平台（ubuntu、centos)2.在基础镜像中安装mysql5.6软件3.导出镜像，命令为mysql5.6镜像文件# 从这个过程，我们可以感觉出这是一层一层的添加的，docker的层级概念就出来了，底层是centos镜像，上层是mysql镜像，centos镜像层属于父镜像。\n\n可写的容器层：当容器启动后，一个新的可写层被加载到镜像的顶部，这一层通常被称为 容器层，容器层下的都称为 镜像层。所有对容器的修改动作，都只会发生在 容器层 里，只有 容器层 是可写的，其余  镜像层 都是只读的。\n\n\n\n文件操作\n说明（都是在容器层中进行的）\n\n\n\n添加文件\n在容器中创建文件时，新文件被添加到容器层中\n\n\n读取文件\n在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件，一旦找到，立即将其复制到容器层，然后打开并读入内存\n\n\n修改文件\n在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件，一旦找到，立即将其复制到容器层，然后修改之\n\n\n删除文件\n在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件，找到后，会在容器层中记录下此删除操作。（只作记录删除操作）\n\n\n只有当需要修改时才会复制一份数据，这种特性被称为Copy-on-Write（写时复制特性）。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。所以镜像层都是只读的，可以被多个容器共享。\n\n\n镜像定制Dockerfiledockerfile相当于一个脚本，通过dockerfile自己的指令，来构建软件依赖，文件依赖、存储等等，用于构建docker镜像，部署一个用于运行你所需的容器环境。\ndockerfile主要组成部分：\n\n基础镜像信息 FROM centos:6.8\n制作镜像操作指令 RUN yum install opeenssh-server -y\n容器启动后要执行的指令 CMD [“/bin/bash”]\n\n容器能够运行，必须在容器内有一个进程在前台执行。\ndockerfile指令：\n\nFROM  这个镜像的妈妈是谁？（指定基础镜像）\n\nMAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可没有）\n\nRUN 你想让它干什么（在命令前面加上RUN即可）\n\nADD 添加宿主机的文件到容器内，还多了一个自动解压功能\n\nCOPY 作用和ADD一样，都是拷贝宿主机的文件到容器内，COPY就是仅仅拷贝\n\nWORKDIR 我是 cd ，今天刚化了妆（设置当前工作目录）\n\nVOLUME 给它一个存放行李的地方（设置卷，挂载主机目录）\n\nEXPOSE 它要打开的门是啥（指定对外端口），在容器内暴露一个端口\n\nCMD 奔跑吧，兄弟（指定容器启动后的要干的事情）\n# 实例 # 1.创建一个 dockerfile 文件，内容如下FROM nginxRUN echo '&lt;meta charse=utf-8&gt;阿布用docker运行nginx服务' &gt; /usr/share/nginx/html/index.html# 2.构建dockerfiledocker build .# 3.修改一下镜像名字docker tag 镜像id cffljx/my_nginx# 4.运行该镜像docker run -d -p 80:80 cffljx/my_nginx# 5.查看宿主机的80端口http://宿主机IP地址\n\nCMD [\"参数1\",\"参数2\"]CMD [\"/bin/bash\"]#该容器运行时执行的命令，等同于命令行的直接操作，docker run -it centos cat /etc/os-releaseCMD [\"cat\",\"/etc/os-release\"]# 注意：docker不是虚拟机的概念，虚拟机里的程序运行，基本上都是在后台运行，利用systemctl运行，但容器内没有后台进程的概念，必须在前台运行。# 容器就是为了主进程而存在的，主进程退出了，容器也就失去意义，自动退出。所以：CMD systemctl start nginx 写法是错误的，容器会立即退出。因为 systemctl start nginx 是希望以守护进程形式启动nginx,且命令会转化为：CMD [\"sh\",\"-c\",\"systemctl start nginx\"]这样的命令主进程是 sh 解释器，执行完毕后立即结束了，因此容器也就退出了。正确写法如下：CMD [\"nginx\",\"-g\",\"daemon off;\"]ENTRYPOINT 的作用和 CMD 一样，都是在指定容器启动程序以及参数当指定了 ENTRYPOINT 之后，CMD指令的语义就有了变化，而是把CMD的内容当作参数传递给 ENTRYPOINT 指令简单讲就是 docker启动命令时，如果用的是CMD指令后面再加参数，就会替换前面CMD命令和参数，而ENTRYPOINT指令的话，能加参数，与前面的参数一起工作。\n\nARG和ENV命令：设置环境变量\nENV NAME=\"cffljx\"后续所有的操作，通过 $NAME 就可以直接获取变量值。ARG和ENV一样，设置环境变量，区别在于 ENV 无论在构建镜像时，还是容器运行，该变量都可以使用；而 ARG 只是用于构建镜像需要设置的变量，容器运行时就消失了。 \n\nVOLUME\n容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载，写入到宿主机上，进行维护。这时就要用到 VOLUME 参数\nVOLUME /data #将容器内的/data文件夹，在容器运行时，该目录自动挂载为匿名卷，任何向该目录中写入数据的操作，都不会被容器记录，保证容器存储层无状态理念。# DockerfileFROM centosMAINTAINER cffljxVOLUME [\"/data1\",\"/data2\"]# 该容器运行时候，这2个目录自动和宿主机的目录做好映射关系通过命令：docker  inspect 2018 查看内面的\"Mounts\": [],内容，就能知道挂载在宿主机的哪个地方\n\nEXPOSE ：指定容器运行时对外提供的端口服务\ndocker port 容器docker run -p 宿主机端口:容器端口docker run -P # 作用是随机宿主机端口:容器内端口\n\nWORKDIR：用于在dockerfile中，目录的切换，更改工作目录\nWORKDIR　/opt\n\nUSER：用于改变环境，用于切换用户\nUSER rootUSER cffljx\n\n存储两种方式，注意区分：1.目录挂载：-v /app/nghtml:/usr/share/nginx/html#目录挂载是将宿主机的文件映射到容器内，容器内原来的文件消失不见，全部与外面的宿主机文件一样2.卷映射： -v ngconfig:/etc/nginx#卷映射分为具名挂载，-v 卷名:容器目录名;和匿名挂载, -v 容器目录名，匿名挂载会自动生成一个卷名#卷映射是将容器内的文件映射到外面宿主机中，容器内原来的文件还在，并且外面的宿主机中也有和容器内一样的文件。同时卷 ngconfig 统一放在宿主机的 /var/lib/docker/volumes目录下面,容器/etc/nginx目录内的文件，对应在 /var/lib/docker/volumes/ngconfig/_data 目录内#以上二种方法可以保证容器内的数据不会丢失,并解决了直接进到容器内，不方便修改文件数据的麻烦。卷挂载时的文件处理规则：1.宿主机目录存在，容器内目录为空。结果：宿主机目录内容会 \"填充\" 到容器内挂载点2.宿主机目录存在，容器内目录有内容。结果：容器内原有内容被 \"隐藏\"，无法访问（但未删除）3.宿主机目录不存在。结果：Docker 会自动创建该目录#查看卷命令：docker volume lsDRIVER    VOLUME NAMElocal     hexo_datalocal     my_hexo_data#创建卷：docker volume cffljx #创建了一个名为cffljx的卷，宿主机会统一放到/var/lib/docker/volumes目录下#查看卷的详细信息：docker volume inspect my_hexo_data[    {        \"CreatedAt\": \"2025-07-30T17:28:37+08:00\",        \"Driver\": \"local\",        \"Labels\": null,        \"Mountpoint\": \"/var/lib/docker/volumes/my_hexo_data/_data\",  #这里是卷的位置        \"Name\": \"my_hexo_data\",        \"Options\": null,        \"Scope\": \"local\"    }]\n\n\n日常工作中，使用卷映射到宿主机上的目录在固定位置，不太灵活，不如使用目录挂载。但配置文件目录挂载要先做好相关准备工作，否则容器启动会失败。例如，将容器的 /etc/nginx 目录（内含配置文件）映射到宿主机，需要注意必须先确保宿主机目录包含完整的 nginx 配置文件，否则直接挂载空目录会覆盖容器内默认配置，导致 nginx 启动失败。正确操作步骤如下：\n1. 先在宿主机创建目录，用于存放 nginx 配置mkdir -p /path/on/host/nginx  # 替换为宿主机实际路径，如 ~/nginx-config2. 从 nginx 容器中复制默认配置到宿主机目录先临时启动一个 nginx 容器，将容器内 /etc/nginx 的所有文件复制到宿主机目录（确保配置完整）：# 临时启动容器（--rm 表示退出后删除）docker run --rm -d --name temp-nginx nginx# 复制容器内 /etc/nginx 所有文件到宿主机目录docker cp temp-nginx:/etc/nginx/. /path/on/host/nginx/# 停止临时容器（会自动删除）docker stop temp-nginx此时宿主机的 /path/on/host/nginx 已包含完整的默认配置（与容器内一致）。3. 挂载目录并启动容器通过 -v 参数将宿主机目录挂载到容器的 /etc/nginx，确保配置文件完整，nginx 可正常运行：用 docker run 启动：docker run -d --name my-nginx -p 80:80 -v /path/on/host/nginx:/etc/nginx nginx # 挂载宿主机目录到容器内 /etc/nginx  用 Docker Compose 配置：yamlservices:  nginx:    container_name: my-nginx    image: nginx    ports:      - \"80:80\"    volumes:      - /path/on/host/nginx:/etc/nginx  # 挂载配置目录    restart: always    关键注意事项：必须先复制默认配置：容器内的 /etc/nginx 包含 nginx 运行必需的配置文件（如 nginx.conf、conf.d/ 目录等），直接挂载空目录会覆盖这些文件，导致 nginx 因缺少配置而启动失败。权限问题：确保宿主机目录 /path/on/host/nginx 的权限允许容器内的 nginx 用户（通常是 nginx 或 www-data）访问，必要时调整权限：chmod -R 755 /path/on/host/nginx  # 临时放宽权限测试修改配置后需重启容器：在宿主机修改 /path/on/host/nginx 下的配置文件后，需重启容器使配置生效：docker restart my-nginx通过以上步骤，既能将 /etc/nginx 映射到宿主机方便管理配置，又能保证 nginx 正常运行。核心是先确保宿主机目录包含完整的默认配置，再进行挂载。\n\n数据卷容器当一个容器内创建了卷时，称为数据卷容器。容器之间可以通过继承关系来实现各容器之间的数据同步共享。\n# 实例# 创建一个dockerfile文件，内容如下：FROM centosVOLUME [\"volume01\",\"volume02\"]CMD echo \"---end---\"CMD /bin/bash# 根据dockerfile文件创建一个镜像docker build -f dockerfile -t cffljx/centos:1.0# 这时启动cffljx/centos:1.0镜像成容器后，这个容器内面就有二个卷：volume0和volume02docker run -it --name docker01  cffljx/centos:1.0# 再以cffljx/centos:1.0镜像启动第二个容器，就能以继承第一个容器的卷：volume0和volume02docker run -it --name docker02 --volumes-from docker01 cffljx/centos:1.0# 这时候就实现了容器之间的数据共享和同步，同时容器卷之间是双向拷贝同步的，一个卷删除后，其它卷的数据不会丢失# 实例二：多个mysql实现数据共享docker run -d -p 3306:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345 --name mysql01 mysql:5.7docker run -d -p 3306:3306  -e MYSQL_ROOT_PASSWORD=12345 --name mysql02 --volumes-form mysql01 mysql:5.7# 这个时候，也可以实现两个容器数据同步# 结论：容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！\n\n容器启动流程docker run 启动容器的时候，docker后台操作流程是：\n\n检查本地是否有该镜像，没有就下载\n\n利用镜像创建且启动一个容器\n\n分配容器文件系统，在只读的镜像层挂载读写层\n\n宿主机的网桥接口会分配一个虚拟接口到容器中\n\n容器获得地址池里的ip地址\n\n执行用户指定的程序\n\n若程序里没有进程在运行，容器执行完毕后立即终止\ndocker start 可以启动一个处于 stop 状态的容器\n\n**最佳实践：**命令+以下三项（都需要参考官方镜像的说明来进行编写）\n\n网络：需不需要将容器端口暴露在外面\n存储：配置和数据持久化需要\n环境变量：给容器运行需要的基本变量值\n\n网络掌握网络机制，才能轻松构建集群。\n\ndocker服务启动后，会生成一个docker0的网卡，地址为172.17.0.1，以后每个容器运行时docker都会分配一个172.17.0.X 的地址给容器，并加入到这个网卡的网络中。\n\n各容器之间通过容器ip+容器端口可以互相访问。\n\n因为各容器运行时的ip是动态变化的，我们可以通过主机域名访问的方式来访问容器。\n\ndocker0网络不支持主机域名，我们可以通过自定义网络来解决这个问题。\n\n创建自定义网络，如 mynet ，容器名就是稳定域名。\n# 创建自定义网络命令：docker network create mynet8452e1c4db05397e60fc1200e4f7e188b236e217b0f754e1f30b5057f1c90749# 查看docker网络命令：docker network lsNETWORK ID     NAME      DRIVER    SCOPE4fa58b08a8e2   bridge    bridge    local3ed18df33c8e   host      host      local8452e1c4db05   mynet     bridge    localbd723318f340   none      null      local# 启动二个容器加入自定义网络的：docker run -d -p 80:80 --name app1 --network mynet nginxdocker run -d -p 80:80 --name app2 --network mynet nginx# 这时，进入到容器app1中,就可以通过容器名访问了docker exec -it app1 bashcurl http://app2:80# 也可以直接将容器加入指定网络中，实现跨网络连通docker network connect mynet 容器名\n\n实例：Redis主从同步集群\n\n容器带来的网卡，都是一对对的，evth-pair 就是一对的虚拟设备接口，它们都是成对出现的，一段连着协议，一段彼此相连。因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的。openstac,Docker容器之间的连接，OVS的连接，都是使用 evth-pair 技术\n\n所有的容器在不指定网络的情况下，都是 docker0 路由的，docker 会给我们的容器分配一个默认的可用IP 。\n\nDocker 使用的是 Linux 桥接，宿主机中是一个Docker容器的网桥 docker0 ，容器间通讯都是通过docker0转接通信的，并不是直接互联。\n\nDocker 中所有的网络接口都是虚拟的，虚拟的转发效率高。当容器删除后，对应网桥一对就没有了。\n\n容器互联参数 –link 就是我们在hosts配置中增加了一条  ip地址  容器名  的记录，目前不建议使用了，我们推荐使用自定义网络\n\n\nCompose批量管理容器工具compose（创作，撰写），使用docker compose时，需要先准备一个 compose.yaml 文件，接下来将你需要启动的所有容器的配置都写入这个文件内。\n\n上线：docker compose up -d  #用在第一次创建并启动\n下线：docker compose down\n启动：docker compose start x1 x2 x3   # 用在之前启动过，x代表在compose.yaml中配置的应用\n停止：docker compose stop x1 x2 x3   # 把这些应用停止\n扩容：docker compose scale x2=3  # 把x2应用启动3份\n\ncompose.yaml文件语法格式：\n\n顶级元素\nname：名字，这次应用部署的名字\nservices：服务，需要部署的服务，服务代表将要启动的每一个应用\nnetworks：网络，启动的应用要用到哪个网络\nvolumes：卷，启动的应用要用到哪些卷\nconfigs：配置\nsecrets：密钥\n\n\n\nname: myblogservices:     mysql:         container_name: mysql # 容器不定义名字时，ymal文件运行后会自动赋一个名字         image: mysql:8.0         ports:          - \"3306:3306\"         environment: # 有多列时采用 - 数组形式，只有一项可以用字典键值形式表示             - MYSQL_ROOT_PASSWORD=123456             - MYSQL_DATABASE=wordpress         volumes:             - mysql-data:/var/lib/mysql #卷挂载方式挂载数据文件             - /app/myconf:/etc/mysql/conf.d #目录挂载方式挂载配置文件         restart: always # 总是会自动重启         networks:          - blog     wordpress:         image: wordpress         ports:          - \"8080:80\"         environment:         WORDPRESS_DB_HOST: mysql         WORDPRESS_DB_USER: root         WORDPRESS_DB_PASSWORD: 123456         WORDPRESS_DB_NAME: wordpress         volumes:          - wordpress:/var/www/html         restart: always         networks:          - blog         depends_on: # 依赖关系，会先启动          - mysqlvolumes: #services中用到的卷都要在这里声明     mysql-data:     wordpress:networks: #services中用到的网络都要在这里声明   blog:\n\n\n启动：docker compose -f compose.yaml up -d  # 如果文件是compose.yaml默认名字，可以省略参数  -f compose.yaml  直接写成  docker compose up -d\n启动后，如果修改了yaml文件内容，再次运行时只会重新开始修改后的容器，原来正常运行的容器不会变。\n停止：docker compose -f compose.yaml -down ，会移除容器和网络，但卷不会移除，下次启动挂载后数据还在。\n如果要移除卷，用命令：docker compose -f compose.yaml down  -v\n查看错误：docker logs 容器的名字\n\nDockerfile构建自定义镜像将自己的应用打包制作成镜像，就要用到 dockerfile ，常见指令如下：\n\nFROM  指定镜像基础环境\n\nRUN  运行自定义命令\n\nCMD  容器启动命令或参数\n\nLABEL  自定义标签\n\nEXPOSE  指定暴露端口\n\nENV  环境变量\n\nADD  添加文件到镜像\n\nCOPY 复制文件到镜像\n\nENTRYPOINT 容器固定启动命令\n\nVOLUME 数据卷\n\nUSER  指定用户和用户组\n\nWORKDIR  指定默认工作目录\n\nARG  指定构建参数\n#构建实例一般分4步# 1.编写dockerfile文件，添加以下指令FROM openjdk:17LABEL author=cffljxCOPY app.jar /app.jarEXPOSE 8080ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]#2.docker build 构建成为一个镜像，下面命令中，-t 表示tag镜像名，最后的 . 确定构建时的层级不能省略。docker build -f dockerfile -t myjavapp:v1.0 .# 3.docker run 运行镜像# 4.docer push 发布镜像到 DockerHub等仓库，供别人下载使用# 实例测试：创建一个自己的centos# Docker Hub中99%镜像都是从这个基础镜像过来的 FROM scratch ，然后配置需要的软件和配置来进行构建# 1.编写一个文件:mydockerfile-centosFROM　centosMAINTAINER cffljx&lt;cffljx@126.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo \"---end---\"CMD /bin/bash# 2.通过这个文件构建镜像docker build -f mydockerfile-centos -t mycentos:0.1 .# 3.测试运行docker run -it mycentos:0.1\n\n我们拿到一个镜像，可以通过 docker history 镜像id 来学习它是怎样构建的\n\ndocker history --no-trunc --format \"table {{.CreatedBy}}\" ff20900769a2 \n\n"}]